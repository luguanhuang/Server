// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: enum.proto

#include "enum.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
namespace KKSG {
}  // namespace KKSG
namespace KKSG {
bool KickType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> KickType_strings[7] = {};

static const char KickType_names[] =
  "KICK_CHANGE_PROFESSION"
  "KICK_DEL_ROLE"
  "KICK_GMFORBID"
  "KICK_HG"
  "KICK_NORMAL"
  "KICK_RELOGIN"
  "KICK_SERVER_SHUTDOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry KickType_entries[] = {
  { {KickType_names + 0, 22}, 5 },
  { {KickType_names + 22, 13}, 4 },
  { {KickType_names + 35, 13}, 2 },
  { {KickType_names + 48, 7}, 6 },
  { {KickType_names + 55, 11}, 0 },
  { {KickType_names + 66, 12}, 1 },
  { {KickType_names + 78, 20}, 3 },
};

static const int KickType_entries_by_number[] = {
  4, // 0 -> KICK_NORMAL
  5, // 1 -> KICK_RELOGIN
  2, // 2 -> KICK_GMFORBID
  6, // 3 -> KICK_SERVER_SHUTDOWN
  1, // 4 -> KICK_DEL_ROLE
  0, // 5 -> KICK_CHANGE_PROFESSION
  3, // 6 -> KICK_HG
};

const std::string& KickType_Name(
    KickType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          KickType_entries,
          KickType_entries_by_number,
          7, KickType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      KickType_entries,
      KickType_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     KickType_strings[idx].get();
}
bool KickType_Parse(
    const std::string& name, KickType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      KickType_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<KickType>(int_value);
  }
  return success;
}
bool ErrorCode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 65:
    case 66:
    case 67:
    case 68:
    case 69:
    case 70:
    case 71:
    case 72:
    case 73:
    case 74:
    case 75:
    case 76:
    case 77:
    case 78:
    case 79:
    case 80:
    case 81:
    case 82:
    case 83:
    case 84:
    case 85:
    case 86:
    case 87:
    case 88:
    case 89:
    case 90:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 97:
    case 98:
    case 99:
    case 100:
    case 101:
    case 102:
    case 103:
    case 104:
    case 105:
    case 106:
    case 107:
    case 108:
    case 109:
    case 110:
    case 111:
    case 112:
    case 113:
    case 114:
    case 115:
    case 116:
    case 117:
    case 118:
    case 119:
    case 120:
    case 121:
    case 122:
    case 123:
    case 124:
    case 125:
    case 126:
    case 127:
    case 128:
    case 129:
    case 130:
    case 131:
    case 132:
    case 133:
    case 134:
    case 135:
    case 136:
    case 137:
    case 138:
    case 139:
    case 140:
    case 141:
    case 142:
    case 143:
    case 144:
    case 145:
    case 146:
    case 147:
    case 148:
    case 149:
    case 150:
    case 151:
    case 152:
    case 153:
    case 154:
    case 155:
    case 156:
    case 157:
    case 158:
    case 159:
    case 160:
    case 161:
    case 162:
    case 163:
    case 164:
    case 165:
    case 166:
    case 167:
    case 168:
    case 169:
    case 170:
    case 171:
    case 172:
    case 173:
    case 174:
    case 175:
    case 176:
    case 177:
    case 178:
    case 179:
    case 180:
    case 181:
    case 182:
    case 183:
    case 184:
    case 185:
    case 186:
    case 187:
    case 188:
    case 189:
    case 190:
    case 191:
    case 192:
    case 193:
    case 194:
    case 195:
    case 196:
    case 197:
    case 198:
    case 199:
    case 200:
    case 201:
    case 202:
    case 203:
    case 204:
    case 205:
    case 206:
    case 207:
    case 208:
    case 209:
    case 210:
    case 211:
    case 212:
    case 213:
    case 214:
    case 215:
    case 216:
    case 217:
    case 218:
    case 219:
    case 220:
    case 221:
    case 222:
    case 223:
    case 224:
    case 225:
    case 226:
    case 227:
    case 228:
    case 229:
    case 230:
    case 231:
    case 232:
    case 233:
    case 234:
    case 235:
    case 236:
    case 237:
    case 238:
    case 239:
    case 240:
    case 241:
    case 242:
    case 243:
    case 244:
    case 245:
    case 246:
    case 247:
    case 248:
    case 249:
    case 250:
    case 251:
    case 252:
    case 253:
    case 254:
    case 255:
    case 256:
    case 257:
    case 258:
    case 259:
    case 260:
    case 261:
    case 262:
    case 263:
    case 264:
    case 265:
    case 266:
    case 267:
    case 268:
    case 269:
    case 270:
    case 271:
    case 272:
    case 273:
    case 274:
    case 275:
    case 276:
    case 277:
    case 278:
    case 279:
    case 280:
    case 281:
    case 282:
    case 283:
    case 284:
    case 285:
    case 286:
    case 287:
    case 288:
    case 289:
    case 290:
    case 291:
    case 292:
    case 293:
    case 294:
    case 295:
    case 296:
    case 297:
    case 298:
    case 299:
    case 300:
    case 301:
    case 302:
    case 303:
    case 304:
    case 305:
    case 306:
    case 500:
    case 501:
    case 502:
    case 503:
    case 504:
    case 505:
    case 510:
    case 511:
    case 512:
    case 513:
    case 514:
    case 515:
    case 516:
    case 517:
    case 518:
    case 519:
    case 520:
    case 521:
    case 522:
    case 523:
    case 524:
    case 525:
    case 526:
    case 527:
    case 528:
    case 529:
    case 530:
    case 531:
    case 532:
    case 533:
    case 534:
    case 535:
    case 536:
    case 537:
    case 538:
    case 539:
    case 540:
    case 541:
    case 542:
    case 543:
    case 544:
    case 545:
    case 546:
    case 547:
    case 548:
    case 549:
    case 550:
    case 551:
    case 552:
    case 553:
    case 554:
    case 555:
    case 556:
    case 557:
    case 558:
    case 559:
    case 560:
    case 561:
    case 562:
    case 563:
    case 564:
    case 565:
    case 566:
    case 567:
    case 568:
    case 569:
    case 570:
    case 571:
    case 572:
    case 573:
    case 574:
    case 575:
    case 576:
    case 577:
    case 578:
    case 579:
    case 580:
    case 581:
    case 582:
    case 583:
    case 584:
    case 585:
    case 586:
    case 587:
    case 588:
    case 589:
    case 590:
    case 591:
    case 592:
    case 593:
    case 594:
    case 595:
    case 596:
    case 597:
    case 598:
    case 599:
    case 600:
    case 601:
    case 602:
    case 603:
    case 604:
    case 605:
    case 606:
    case 607:
    case 608:
    case 609:
    case 610:
    case 611:
    case 612:
    case 613:
    case 614:
    case 615:
    case 616:
    case 617:
    case 618:
    case 619:
    case 620:
    case 621:
    case 622:
    case 623:
    case 624:
    case 625:
    case 626:
    case 627:
    case 628:
    case 629:
    case 631:
    case 632:
    case 650:
    case 651:
    case 652:
    case 653:
    case 654:
    case 655:
    case 656:
    case 657:
    case 658:
    case 659:
    case 660:
    case 661:
    case 662:
    case 663:
    case 664:
    case 665:
    case 666:
    case 667:
    case 668:
    case 669:
    case 670:
    case 671:
    case 672:
    case 673:
    case 674:
    case 675:
    case 676:
    case 677:
    case 678:
    case 679:
    case 680:
    case 681:
    case 682:
    case 683:
    case 684:
    case 685:
    case 686:
    case 687:
    case 688:
    case 689:
    case 690:
    case 691:
    case 692:
    case 693:
    case 694:
    case 695:
    case 696:
    case 697:
    case 698:
    case 699:
    case 700:
    case 701:
    case 702:
    case 703:
    case 704:
    case 705:
    case 706:
    case 707:
    case 708:
    case 709:
    case 710:
    case 711:
    case 712:
    case 713:
    case 714:
    case 715:
    case 716:
    case 717:
    case 718:
    case 719:
    case 720:
    case 721:
    case 722:
    case 723:
    case 724:
    case 725:
    case 726:
    case 727:
    case 728:
    case 729:
    case 730:
    case 731:
    case 732:
    case 733:
    case 734:
    case 735:
    case 736:
    case 737:
    case 738:
    case 739:
    case 740:
    case 741:
    case 742:
    case 743:
    case 744:
    case 745:
    case 746:
    case 747:
    case 748:
    case 749:
    case 750:
    case 751:
    case 752:
    case 753:
    case 754:
    case 756:
    case 757:
    case 758:
    case 759:
    case 760:
    case 761:
    case 762:
    case 763:
    case 764:
    case 765:
    case 766:
    case 767:
    case 768:
    case 769:
    case 770:
    case 771:
    case 772:
    case 773:
    case 774:
    case 775:
    case 776:
    case 777:
    case 778:
    case 779:
    case 780:
    case 781:
    case 782:
    case 783:
    case 784:
    case 785:
    case 786:
    case 787:
    case 788:
    case 789:
    case 790:
    case 791:
    case 792:
    case 793:
    case 794:
    case 795:
    case 796:
    case 797:
    case 798:
    case 799:
    case 800:
    case 801:
    case 802:
    case 803:
    case 804:
    case 805:
    case 806:
    case 807:
    case 808:
    case 809:
    case 810:
    case 811:
    case 812:
    case 813:
    case 814:
    case 815:
    case 816:
    case 817:
    case 818:
    case 819:
    case 820:
    case 821:
    case 822:
    case 823:
    case 824:
    case 825:
    case 826:
    case 827:
    case 828:
    case 829:
    case 830:
    case 831:
    case 832:
    case 833:
    case 834:
    case 835:
    case 836:
    case 837:
    case 838:
    case 839:
    case 840:
    case 841:
    case 842:
    case 843:
    case 844:
    case 845:
    case 846:
    case 847:
    case 848:
    case 849:
    case 850:
    case 851:
    case 852:
    case 853:
    case 854:
    case 855:
    case 856:
    case 857:
    case 858:
    case 859:
    case 860:
    case 861:
    case 862:
    case 863:
    case 864:
    case 865:
    case 866:
    case 867:
    case 868:
    case 869:
    case 870:
    case 871:
    case 872:
    case 873:
    case 874:
    case 875:
    case 876:
    case 877:
    case 878:
    case 879:
    case 880:
    case 881:
    case 882:
    case 883:
    case 884:
    case 885:
    case 886:
    case 887:
    case 888:
    case 889:
    case 890:
    case 891:
    case 892:
    case 893:
    case 894:
    case 895:
    case 896:
    case 897:
    case 898:
    case 899:
    case 900:
    case 901:
    case 902:
    case 903:
    case 904:
    case 905:
    case 906:
    case 907:
    case 908:
    case 909:
    case 910:
    case 911:
    case 912:
    case 913:
    case 914:
    case 915:
    case 916:
    case 917:
    case 918:
    case 919:
    case 920:
    case 921:
    case 922:
    case 923:
    case 924:
    case 925:
    case 926:
    case 927:
    case 928:
    case 929:
    case 930:
    case 931:
    case 932:
    case 933:
    case 934:
    case 935:
    case 936:
    case 937:
    case 938:
    case 939:
    case 940:
    case 941:
    case 942:
    case 943:
    case 944:
    case 945:
    case 946:
    case 947:
    case 948:
    case 949:
    case 950:
    case 951:
    case 952:
    case 953:
    case 954:
    case 955:
    case 956:
    case 957:
    case 958:
    case 959:
    case 960:
    case 961:
    case 962:
    case 963:
    case 964:
    case 965:
    case 966:
    case 967:
    case 968:
    case 969:
    case 970:
    case 971:
    case 972:
    case 973:
    case 974:
    case 975:
    case 976:
    case 977:
    case 978:
    case 979:
    case 980:
    case 981:
    case 982:
    case 983:
    case 984:
    case 985:
    case 986:
    case 987:
    case 988:
    case 989:
    case 990:
    case 991:
    case 992:
    case 993:
    case 994:
    case 995:
    case 996:
    case 997:
    case 998:
    case 999:
    case 1000:
    case 1001:
    case 1002:
    case 1003:
    case 1004:
    case 1005:
    case 1006:
    case 1007:
    case 1008:
    case 1009:
    case 1010:
    case 1011:
    case 1012:
    case 1013:
    case 1014:
    case 1015:
    case 1016:
    case 1017:
    case 1018:
    case 1019:
    case 1020:
    case 1021:
    case 1022:
    case 1023:
    case 1024:
    case 1025:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ErrorCode_strings[810] = {};

static const char ErrorCode_names[] =
  "ATLAS_CARD_NOT_ENOUGH"
  "CanNotDelInGuildArena"
  "ERR_ABYSS_LEVEL"
  "ERR_ACCOUNT_DATA_ERROR"
  "ERR_ACCOUNT_INVALID"
  "ERR_ACCOUNT_NOT_EXIST"
  "ERR_ACCOUNT_QUEUING"
  "ERR_ACCOUNT_ROLE_FULL"
  "ERR_ACHIVE_NOTCOMPLETE"
  "ERR_ACHIVE_NOTCONFIG"
  "ERR_ACTIVITY"
  "ERR_ACTIVITY_HASGETCHEST"
  "ERR_ACTIVITY_NOCHESTINDEX"
  "ERR_ACTIVITY_NOTENOUGHVALUE"
  "ERR_ACTIVITY_SPECIALCHESTCOUNTLIMIT"
  "ERR_ACT_NOT_OPEN"
  "ERR_ADDFRIEND_DUMMYROLE"
  "ERR_ALIVE_TIMEOUT"
  "ERR_ALREADY_BUYAILEEN"
  "ERR_ALREADY_CHARGE_BACK"
  "ERR_ALREADY_IN_CAMP"
  "ERR_ALREADY_IN_QQGROUP"
  "ERR_ALREADY_REPORTED"
  "ERR_ANCIENTPOWER_DEAD"
  "ERR_ANCIENTPOWER_LESSPOINT"
  "ERR_ANTI_CHEAT_DETECTED"
  "ERR_APOLLO_CDN"
  "ERR_ARENA_ADDCOUNTLACKCOIN"
  "ERR_ARENA_COUNTLIMIT"
  "ERR_ARENA_ERROR"
  "ERR_ARENA_REWARDTAKEN"
  "ERR_ARGENTA_DAILY_GET"
  "ERR_ARTIFACT_CANTFUSE"
  "ERR_ARTIFACT_CANTINSCRIPTION"
  "ERR_ARTIFACT_CANTRECAST"
  "ERR_ARTIFACT_COMPOSE_CANTCOMPOSE"
  "ERR_ARTIFACT_COMPOSE_LEVELNOTEQUAL"
  "ERR_ARTIFACT_COMPOSE_NUMBER"
  "ERR_ARTIFACT_COMPOSE_QUALITYNOTEQUAL"
  "ERR_ARTIFACT_FUSEFAILED"
  "ERR_ARTIFACT_FUSE_CONDITION"
  "ERR_ARTIFACT_INSCRIPTION_LEVEL"
  "ERR_ATLAS_NOT_BREAK"
  "ERR_AUCTGOLDLESS"
  "ERR_AUCT_AUCTOVER"
  "ERR_AUCT_AUTOREFRESH_TIME"
  "ERR_AUCT_BUYSELF"
  "ERR_AUCT_COMMONERR"
  "ERR_AUCT_DRAGONCOINLESS"
  "ERR_AUCT_HAVEBIDDING"
  "ERR_AUCT_ITEMOUTSALE"
  "ERR_AUCT_ITEMSALED"
  "ERR_AUCT_ITEM_LESS"
  "ERR_AUCT_ITEM_LOCK"
  "ERR_AUCT_ONSALEMAX"
  "ERR_AUCT_POINTLESS"
  "ERR_AUCT_PRICECHAGE"
  "ERR_AUCT_PRICE_CHANGE"
  "ERR_AUCT_PRICE_NOTCHANGE"
  "ERR_AUCT_SURPASSSELF"
  "ERR_AUDIOTXT"
  "ERR_AUDIO_CHAT"
  "ERR_AUDIO_NOT_EXIST"
  "ERR_AUTH_TOKEN_INVALID"
  "ERR_BACKFLOWSHOP_ALREADYBUY"
  "ERR_BACKFLOWSHOP_LACKDIAMOND"
  "ERR_BACKFLOWSHOP_LACKDRAGONCOIN"
  "ERR_BACKFLOWSHOP_LESSFRESHCOUNT"
  "ERR_BACKFLOWSHOP_NOTHAVEGOOD"
  "ERR_BACKFLOWSHOP_SHOPCLOSE"
  "ERR_BACKFLOW_ALREADYGET"
  "ERR_BACKFLOW_BUYEND"
  "ERR_BACKFLOW_LESSPOINT"
  "ERR_BAGEXPAND_LESSITEM"
  "ERR_BAGEXPAND_MAXCOUNT"
  "ERR_BAG_FULL"
  "ERR_BAG_FULL_CANT_COMPOSE"
  "ERR_BAG_FULL_GIVE_MAIL_REWARD"
  "ERR_BAG_FULL_TAKEOFF_ARTIFACT"
  "ERR_BAG_FULL_TAKEOFF_EMBLEM"
  "ERR_BAG_FULL_TAKEOFF_EQUIP"
  "ERR_BAG_FULL_TAKEOFF_FASHION"
  "ERR_BAG_FULL_TAKEOFF_JADE"
  "ERR_BATTLEFIELD_LEVEL"
  "ERR_BATTLEFIELD_NOT_OPEN"
  "ERR_BIND_SKILL_MISSSLOT"
  "ERR_BIND_SKILL_NOT_LEARN"
  "ERR_BIND_SKILL_OUTRANGE"
  "ERR_BLACK_CHAT"
  "ERR_BLACK_INOTHER"
  "ERR_BLACK_INSELF"
  "ERR_BLACK_MAX"
  "ERR_BLACK_NOTEXIST"
  "ERR_BLACK_REPEATED"
  "ERR_BLACK_SELF"
  "ERR_BUY_LIMIT"
  "ERR_CANNOT_PICK_THIS_ITEM"
  "ERR_CANTCHOOSEHERO"
  "ERR_CANT_FUSE"
  "ERR_CAN_INGORE"
  "ERR_CAN_NOT_DEL_IN_GUILD_TERRITOYR"
  "ERR_CAN_NOT_USE_PET_SKILL_BOOK"
  "ERR_CARDMATCH_BEGINFAILED"
  "ERR_CARDMATCH_CHANGELIMIT"
  "ERR_CARDMATCH_ENDSOON"
  "ERR_CARDMATCH_NOBEGIN"
  "ERR_CARDMATCH_SIGNUP_LIMIT"
  "ERR_CAREER_PVP_NOTOPEN"
  "ERR_CHANGEPRO_COUNT"
  "ERR_CHANGEPRO_INVALID"
  "ERR_CHANGEPRO_ITEMLIMIT"
  "ERR_CHANGEPRO_KICK"
  "ERR_CHANGEPRO_LEVEL"
  "ERR_CHANGEPRO_SAMEPRO"
  "ERR_CHANGEPRO_TIME"
  "ERR_CHANGE_SAMESCENE"
  "ERR_CHAPTERCHEST_ALREADY_FETCHED"
  "ERR_CHAPTERCHEST_NEEDSTAR"
  "ERR_CHAT_BLACK_INOTHER"
  "ERR_CHAT_BLACK_INSELF"
  "ERR_CHAT_LENGTHLIMIT"
  "ERR_CHAT_LEVELLIMIT"
  "ERR_CHAT_PUNISH"
  "ERR_CHAT_TIMELIMIT"
  "ERR_CHECKIN_FULL"
  "ERR_CHECKIN_LACKDRAGONCOIN"
  "ERR_CHEST_TAKED"
  "ERR_COMMENDWATCH_COUNTLIMIT"
  "ERR_COMPETEDRAGON_WRONG_DNID"
  "ERR_CROSS_IBBUY"
  "ERR_CROSS_ZONE_UNUSABLE"
  "ERR_CUSTOMBATTLE_BATTLENOTFIND"
  "ERR_CUSTOMBATTLE_BOUNTYMODE_NOTOPEN"
  "ERR_CUSTOMBATTLE_CREATECONFINVALID"
  "ERR_CUSTOMBATTLE_CREATFAILED"
  "ERR_CUSTOMBATTLE_CREATORLEAVE"
  "ERR_CUSTOMBATTLE_HASJOIN"
  "ERR_CUSTOMBATTLE_INVALIDREQUEST"
  "ERR_CUSTOMBATTLE_JOINFAILED"
  "ERR_CUSTOMBATTLE_JOINFULL"
  "ERR_CUSTOMBATTLE_JOININVALIDPASSWORD"
  "ERR_CUSTOMBATTLE_JOINNOTINREADYTIME"
  "ERR_CUSTOMBATTLE_JOINNOTRELATED"
  "ERR_CUSTOMBATTLE_LEVELLIMIT"
  "ERR_CUSTOMBATTLE_MATCHFAILED"
  "ERR_CUSTOMBATTLE_NAMEINVALID"
  "ERR_CUSTOMBATTLE_NAMEMAX"
  "ERR_CUSTOMBATTLE_NAMEMIN"
  "ERR_CUSTOMBATTLE_NOTCREATER"
  "ERR_CUSTOMBATTLE_NOTJOIN"
  "ERR_CUSTOMBATTLE_PASSWORDINVALID"
  "ERR_CUSTOMBATTLE_REWARDCANGET"
  "ERR_CUSTOMBATTLE_REWARDCD"
  "ERR_CUSTOMBATTLE_REWARDHASGET"
  "ERR_CUSTOMBATTLE_ROELNOTEXIST"
  "ERR_CUSTOMBATTLE_WORLDNOTOPEN"
  "ERR_CUSTOM_GMLIMIT"
  "ERR_CUSTOM_NOMATCHING"
  "ERR_CUSTOM_NOTOPEN"
  "ERR_CUSTOM_SAMEMATCH"
  "ERR_DAILY_TASK_CANNT_REFRESH"
  "ERR_DAILY_TASK_NO_BUY_COUNT"
  "ERR_DAILY_TASK_NO_REFRESH_COUNT"
  "ERR_DAILY_TASK_OTHER_NO_HELPCOUNT"
  "ERR_DAILY_TASK_QUALITY_MAX"
  "ERR_DAILY_WEDDY_CANDY_OVERMAX"
  "ERR_DECLARATION_TOO_LONG"
  "ERR_DECLAREWAR_OUT_TIME"
  "ERR_DECOMPOSE_CANNOT"
  "ERR_DECOMPOSE_FAILED"
  "ERR_DECOMPOSE_NOTFIND"
  "ERR_DG_ALREADY_IN_DG"
  "ERR_DG_APPLY_FULL"
  "ERR_DG_DGNAME_EXIST"
  "ERR_DG_DGUILD_NOT_EXIST"
  "ERR_DG_FULL"
  "ERR_DG_IN_CD"
  "ERR_DG_ITEM_NOT_FOUND"
  "ERR_DG_LOCK_NAME"
  "ERR_DG_NOT_IN_APPROVAL"
  "ERR_DG_NOT_IN_GUILD"
  "ERR_DG_NOT_IN_SAME"
  "ERR_DG_NO_PERMISSION"
  "ERR_DG_OTHER_BUYING"
  "ERR_DG_POSITION_FULL"
  "ERR_DG_PPT_REQ"
  "ERR_DG_SHOP_NO_COUNT"
  "ERR_DG_WAITAPPROVAL"
  "ERR_DOENTERSCENE_FAILED"
  "ERR_DOODAD_FULL"
  "ERR_DRAGONCOIN_LIMIT"
  "ERR_DRAGON_PROGRESS_INVALID"
  "ERR_DRAGON_TICKET_NOTENOUGH"
  "ERR_EMBLEM_CANTIDENTIFY"
  "ERR_EMBLEM_MAXLEVEL"
  "ERR_EMBLEM_NOEMPTYSLOT"
  "ERR_EMBLEM_NOIDENTIFY"
  "ERR_EMBLEM_NOTHIRDSLOT"
  "ERR_ENCHANT_ALREADYHAVE"
  "ERR_ENCHANT_LACKITEM"
  "ERR_ENCHANT_MINLEVEL"
  "ERR_ENCHANT_NOTHAVE"
  "ERR_ENCHANT_NOTHAVEATTRID"
  "ERR_ENCHANT_TRANSFER_LEVEL_LIMIT"
  "ERR_ENCHANT_WRONGPOS"
  "ERR_ENHANCE_ERROR"
  "ERR_ENHANCE_FAILED"
  "ERR_ENHANCE_LACKITEM"
  "ERR_ENHANCE_MAX"
  "ERR_ENHANCE_NO_EQUIP_CAN_TRANSFORM"
  "ERR_ENHANCE_SUCCEED"
  "ERR_ENHANCE_TRANSLEVEL"
  "ERR_ENHANCE_TRANSPOS"
  "ERR_EQUIP_CANTFORGE"
  "ERR_EQUIP_FORGE_FAILED"
  "ERR_EQUIP_FORGE_LACK_ITEM"
  "ERR_EQUIP_FORGE_LACK_STONE"
  "ERR_EXPBACK_ALREADYGET"
  "ERR_EXTRA_EMBLEM_SLOT_FULL"
  "ERR_EXTRA_EMBLEM_SLOT_LEVEL"
  "ERR_FAILED"
  "ERR_FASHIONCOMPOSE_FAILED"
  "ERR_FASHIONCOMPOSE_LEVEL_REQ"
  "ERR_FASHIONCOMPOSE_POS"
  "ERR_FASHIONCOMPOSE_QUALITY"
  "ERR_FASHIONCOMPOSE_TIMELIMIT"
  "ERR_FASHION_COLOR_LOOK"
  "ERR_FASHION_COLOR_UNLOOK"
  "ERR_FASHION_ERROR_COLOR"
  "ERR_FASHION_ITEM_NOT_ENOUGH"
  "ERR_FASHION_NOEXIST_EFFECTS"
  "ERR_FASHION_NOT_EXIST"
  "ERR_FASHION_NO_HAIR"
  "ERR_FASHOIN_ALREADY_EXIST"
  "ERR_FISHING_ALREADYSEAT"
  "ERR_FISHING_NUMNOTENOUGH"
  "ERR_FISHING_SEATNOTEMPTY"
  "ERR_FLOWER_COSTLIMIT"
  "ERR_FLOWER_COUNTLIMIT"
  "ERR_FLOWER_ROLELIMIT"
  "ERR_FLOWER_SELF"
  "ERR_FM_NOANCHOR"
  "ERR_FM_NOINAUDIO"
  "ERR_FM_NOINROOM"
  "ERR_FORGE_NOREPLACE"
  "ERR_FRIEND_DEGREE_NOTENOUGH"
  "ERR_FRIEND_HASSEND"
  "ERR_FRIEND_IS_PARTNER"
  "ERR_FRIEND_MAX"
  "ERR_FRIEND_MAXOTHER"
  "ERR_FRIEND_NOTEXIST"
  "ERR_FRIEND_REPEATED"
  "ERR_FRIEND_SELF"
  "ERR_FRIEND_SENDLIMIT"
  "ERR_FRIEND_TAKENLIMIT"
  "ERR_FUSE_BREAKLACKEXP"
  "ERR_FUSE_EXPMAX"
  "ERR_FUSE_MAX"
  "ERR_GAOJIGU_MODEL_DUPLICATE_FASHIONID"
  "ERR_GARDEN_COOKINGLEVEL_LOW"
  "ERR_GARDEN_COOKING_EXCEED"
  "ERR_GARDEN_ERR_SEED"
  "ERR_GARDEN_EXPELSPRITE_MAX"
  "ERR_GARDEN_FOODBOOK_ACTIVED"
  "ERR_GARDEN_FOOD_NOALLOW"
  "ERR_GARDEN_NOALLOW"
  "ERR_GARDEN_NOEXIST_FOODID"
  "ERR_GARDEN_NOHARVESTSTATE"
  "ERR_GARDEN_NOSEED"
  "ERR_GARDEN_NOTEXIST_FARMLAND"
  "ERR_GARDEN_NOTEXIST_SEEDID"
  "ERR_GARDEN_NOTEXIST_SPRITE"
  "ERR_GARDEN_NOTINGARDEN"
  "ERR_GARDEN_PLANT_CD"
  "ERR_GARDEN_PLANT_CUL_ERR"
  "ERR_GARDEN_QUESTS_NOENOUGH"
  "ERR_GARDEN_STEALEDTIMES_EXCEED"
  "ERR_GARDEN_STEAL_LIMIT"
  "ERR_GCASTLE_FIGHT_END"
  "ERR_GCASTLE_NOT_IN_ACT"
  "ERR_GCASTLE_NOT_IN_FIGHT"
  "ERR_GCASTLE_ROLE_FULL"
  "ERR_GCASTLE_ROLE_LEVEL"
  "ERR_GIFTIB_NOTGOODS"
  "ERR_GMF_DOWN_FIGHTING"
  "ERR_GMF_DOWN_HAVEFAILED"
  "ERR_GMF_NOPOWER_KICK_LEADER"
  "ERR_GMF_UPBATTLE_REPEAT"
  "ERR_GMF_UP_FULL"
  "ERR_GMF_UP_INCOOL"
  "ERR_GOLDCLICK_LIMIT"
  "ERR_GROUPCHAT_FULLGROUP"
  "ERR_GROUPCHAT_FULLGROUP_OTHER"
  "ERR_GROUPCHAT_GROUPFULLMEMBERS"
  "ERR_GROUPCHAT_LEADERNOCOUNT"
  "ERR_GROUPCHAT_NO_MANAGER"
  "ERR_GROUPCHAT_ROLENOCOUNT"
  "ERR_GROUPCHAT_TIMEOUT"
  "ERR_GS_CLOSED"
  "ERR_GS_UNREADY"
  "ERR_GUILDACMPPATY_DISTANCE"
  "ERR_GUILDACMPPATY_ERRSTAGE"
  "ERR_GUILDACMPPATY_NOTOPEN"
  "ERR_GUILDACMPPATY_SPRITE_ONTEXIST"
  "ERR_GUILDAUCT_PUBLIC_TIME"
  "ERR_GUILDBONUS_ALLGET"
  "ERR_GUILDBONUS_ALREADYGET"
  "ERR_GUILDBONUS_EXCEED"
  "ERR_GUILDBONUS_MAXNUM"
  "ERR_GUILDBONUS_NOTEXIST"
  "ERR_GUILDBUFF_CD"
  "ERR_GUILDBUFF_GUILD"
  "ERR_GUILDBUFF_ITEM"
  "ERR_GUILDBUFF_POS"
  "ERR_GUILDCAMP_OTHER_NOTIN"
  "ERR_GUILDCAMP_SELF_NOTIN"
  "ERR_GUILDCAMP_SPRITE_NOTEXIST"
  "ERR_GUILDCARD_ALLCOUNTLIMIT"
  "ERR_GUILDCARD_CHANGELIMIT"
  "ERR_GUILDCARD_COUNTLIMIT"
  "ERR_GUILDCHECKIN_ALLCOUNT"
  "ERR_GUILDCHECKIN_BOXLIMIT"
  "ERR_GUILDCHECKIN_LIMIT"
  "ERR_GUILDCHECKIN_MONEY"
  "ERR_GUILDCHECKIN_TAKEN"
  "ERR_GUILDPARTY_ENDING"
  "ERR_GUILDPARTY_HAVESUMMON"
  "ERR_GUILDPARTY_SUMMONING"
  "ERR_GUILDPARTY_TRADIING"
  "ERR_GUILD_ALREADY_BIND"
  "ERR_GUILD_ALREADY_IN_GUILD"
  "ERR_GUILD_APPLYFULL"
  "ERR_GUILD_CHECKINBONUS_ASKTOOMUCH"
  "ERR_GUILD_CHECKINBONUS_TIMEERROR"
  "ERR_GUILD_ELITE_FULL"
  "ERR_GUILD_EXP_LIMIT"
  "ERR_GUILD_FULL"
  "ERR_GUILD_INHERIT_CAN_NOT"
  "ERR_GUILD_INHERIT_CD_TIME"
  "ERR_GUILD_INHERIT_GAP"
  "ERR_GUILD_INHERIT_LVL"
  "ERR_GUILD_INHERIT_MAP_WRONG"
  "ERR_GUILD_INHERIT_NOT_EXIT"
  "ERR_GUILD_INHERIT_OTHER_TIMES"
  "ERR_GUILD_INHERIT_TIMES"
  "ERR_GUILD_LADDER_NOT_OPEN"
  "ERR_GUILD_LEVEL_REQ"
  "ERR_GUILD_LOCK_NAME"
  "ERR_GUILD_LVL_LIMIT"
  "ERR_GUILD_MEMBER_NOT_EXIST"
  "ERR_GUILD_NAME_EXIST"
  "ERR_GUILD_NAME_NULL"
  "ERR_GUILD_NAME_TOO_LONG"
  "ERR_GUILD_NAME_TOO_SHORT"
  "ERR_GUILD_NOT_BIND"
  "ERR_GUILD_NOT_EXIST"
  "ERR_GUILD_NOT_IN_GUILD"
  "ERR_GUILD_NO_PERMISSION"
  "ERR_GUILD_OFFICER_FULL"
  "ERR_GUILD_OPENLIMIT"
  "ERR_GUILD_PPT_REQ"
  "ERR_GUILD_VICE_FULL"
  "ERR_GUILD_WAITAPPROVAL"
  "ERR_HAS_JOIN_OTHER_GUILD_BOSS"
  "ERR_HAVE_GOT_AWARD"
  "ERR_HEROBATTLE_ALREADYGET"
  "ERR_HEROBATTLE_CANTGETPRIZE"
  "ERR_HERO_ALREADY_CHOSEN"
  "ERR_HERO_EXPERIENCE_HAVE"
  "ERR_HERO_INVALID"
  "ERR_HERO_LACKMONEY"
  "ERR_HG_FORBID"
  "ERR_HORSE_ACTIVITY"
  "ERR_HORSE_INTEAM"
  "ERR_HORSE_TEAM"
  "ERR_IBGIFT_DAY_MAXBUYCOUNT"
  "ERR_IBGIFT_FRIEND"
  "ERR_IBGIFT_MAX_COUNT"
  "ERR_IBGIFT_NOT_ENOUCH"
  "ERR_IBGIFT_OVERMAXUNRECV"
  "ERR_IBSHOP_BUSY"
  "ERR_IBSHOP_BUYLV"
  "ERR_IBSHOP_ERRPARAM"
  "ERR_IBSHOP_LACKDIAMOND"
  "ERR_IBSHOP_LACKDRAGON"
  "ERR_IBSHOP_LACKGOODS"
  "ERR_IBSHOP_LIMITCOUNT"
  "ERR_IBSHOP_OPENGROUP"
  "ERR_IBSHOP_VIPLEVEL"
  "ERR_ILLEGAL_CODE"
  "ERR_INSPIRE_COOLDOWN"
  "ERR_INVALID_IBBUY"
  "ERR_INVALID_NAME"
  "ERR_INVALID_PAYROLE"
  "ERR_INVALID_REQUEST"
  "ERR_INVALID_STATE"
  "ERR_INVFIGHT_INV_COUNT_MAX"
  "ERR_INVFIGHT_INV_DELAY"
  "ERR_INVFIGHT_INV_REPEAT"
  "ERR_INVFIGHT_INV_TIME_OVER"
  "ERR_INVFIGHT_INV_TO_COUNT_MAX"
  "ERR_INVFIGHT_ME_LEVEL"
  "ERR_INVFIGHT_ME_SCENE"
  "ERR_INVFIGHT_OTHER_LEVEL"
  "ERR_INVFIGHT_OTHER_SCENE"
  "ERR_INVFIGHT_ROLE_LOGOUT"
  "ERR_ITEM_CANNOTBEEQUIPED"
  "ERR_ITEM_COOLDOWN"
  "ERR_ITEM_LEVELLIMIT"
  "ERR_ITEM_NEED_DIAMOND"
  "ERR_ITEM_NEED_DRAGONCOIN"
  "ERR_ITEM_NOTEXIST"
  "ERR_ITEM_NOT_ENOUGH"
  "ERR_ITEM_NOT_ENOUGH_COMMON"
  "ERR_ITEM_WRONG_PROFESSION"
  "ERR_JADEATTACH_NOEMPTYSLOT"
  "ERR_JADECOMPOSE_NOTFIND"
  "ERR_JADE_COUNTNOTENOUGH"
  "ERR_JADE_DRAGONNOTENOUGH"
  "ERR_JADE_GOLDNOTENOUGH"
  "ERR_JADE_MAXLEVEL"
  "ERR_JADE_MINEQUIPLEVEL"
  "ERR_JADE_NOEMPTYSLOT"
  "ERR_JADE_OPENJADELACKCOIN"
  "ERR_JADE_REPLACE"
  "ERR_JADE_SAME_TYPE"
  "ERR_JADE_WRONGTYPE"
  "ERR_KINGBACK_REWARD_COUNT_LIMIT"
  "ERR_LACKCOIN"
  "ERR_LACKDIAMOND"
  "ERR_LEAGUE_ALREADY_FIGHTED"
  "ERR_LEAGUE_ALREADY_HAS_TEAM"
  "ERR_LEAGUE_HAS_MEMBER_NOT_TEAM"
  "ERR_LEAGUE_HAS_NO_TEAM"
  "ERR_LEAGUE_INV_ALREADY_HAS_TEAM"
  "ERR_LEAGUE_INV_NOT_IN_TEAM"
  "ERR_LEAGUE_NOT_IN_APPLY_TIME"
  "ERR_LEAGUE_NOT_IN_MATCH_TIME"
  "ERR_LEAGUE_NOT_IN_TEAM"
  "ERR_LEAGUE_ROLE_ALREADY_BATTLE"
  "ERR_LEAGUE_ROLE_ALREADY_UP"
  "ERR_LEAGUE_ROLE_FIGHTING"
  "ERR_LEAGUE_TEAM_CANNOT_CROSS"
  "ERR_LEAGUE_TEAM_IN_BATTLE"
  "ERR_LEAGUE_TEAM_IN_MATCH"
  "ERR_LEAGUE_TEAM_NOT_EXIST"
  "ERR_LEAGUE_TEAM_NOT_IN_BATTLE"
  "ERR_LEAGUE_TEAM_NOT_IN_MATCH"
  "ERR_LEAGUE_TEAM_ROLE_NUM_INVALID"
  "ERR_LEVELSEAL_PROP_NOT_ENGOUTH"
  "ERR_LIVENESS_NOT_ENOUGH"
  "ERR_LOCKED_ROLE"
  "ERR_LOGIN_FORBID"
  "ERR_LOGIN_MAXNUM"
  "ERR_LOGIN_NOSERVER"
  "ERR_LOGIN_NOT_IN_WHITE_LIST"
  "ERR_LOGIN_TIMEOUT"
  "ERR_LOGIN_VERIFY_FAILED"
  "ERR_MARRIAGE_ALREADY_APPLYDIVORCE"
  "ERR_MARRIAGE_DISTANCE_TOOFAR"
  "ERR_MARRIAGE_LEVEL_NOTENOUGH"
  "ERR_MARRIAGE_NEED_TEAM"
  "ERR_MARRIAGE_NEED_TWO_NOTMARRY"
  "ERR_MARRIAGE_NOTINMARRIAGE"
  "ERR_MARRIAGE_NOT_DIVORCESTATUS"
  "ERR_MARRIAGE_ONLY_APPLIER_CANCLEDIVORCE"
  "ERR_MENTOR_ALREADY_COMPLETE_MENTOR"
  "ERR_MENTOR_ALREADY_INRELATION"
  "ERR_MENTOR_ASKMAXTODAY"
  "ERR_MENTOR_COMPLETE_IN_RELATION_NEED_DAYS"
  "ERR_MENTOR_COMPLETE_OTHER_OFFLINE_NEED_DAYS"
  "ERR_MENTOR_CUR_STATUS_CANNOT_APPLYMASTER"
  "ERR_MENTOR_CUR_STATUS_CANNOT_APPLYSTUDENT"
  "ERR_MENTOR_CUR_STATUS_CANNOT_BREAK"
  "ERR_MENTOR_INHERIT_ING"
  "ERR_MENTOR_OTHER_ALREADY_APPLY_INHERIT"
  "ERR_MENTOR_OTHER_APPLY_BREAK"
  "ERR_MENTOR_OTHER_ONLINE"
  "ERR_MENTOR_REFRESHTOOFAST"
  "ERR_MIDAS_BALANCE_NOTENOUTH"
  "ERR_MIDAS_FAILED"
  "ERR_MILITARY_TRIGGER_CHECK"
  "ERR_MOBA_CANTMATCH"
  "ERR_MOBA_MOBMAXLEVEL"
  "ERR_MOBA_SIGNAL_TOOFAST"
  "ERR_MOBA_UPGRADENUM_EMPTY"
  "ERR_MS_UNNORMAL"
  "ERR_MS_UNREADY"
  "ERR_NAME_ALLNUM"
  "ERR_NAME_EXIST"
  "ERR_NAME_HAS_INVALID_CHAR"
  "ERR_NAME_TOO_LONG"
  "ERR_NAME_TOO_SHORT"
  "ERR_NEED_FIRST_PROMOTE"
  "ERR_NEED_MARRIAGE_TEAM"
  "ERR_NOCONDITION"
  "ERR_NOMAIL_GETREWARD"
  "ERR_NOTGUILD"
  "ERR_NOT_BESPEAK"
  "ERR_NOT_DEL_GUILD_IN_TERR"
  "ERR_NOT_IN_CAMP"
  "ERR_NPCFL_BUY_GG_COUNT_LESS"
  "ERR_NPCFL_DRAGON_COIN_LESS"
  "ERR_NPCFL_EXP_LESS"
  "ERR_NPCFL_GIVE_GIFT_COUNT_LESS"
  "ERR_NPCFL_ITEM_LESS"
  "ERR_NPCFL_NEED_REFRESH"
  "ERR_NPCFL_NPC_LEVEL_MAX"
  "ERR_NPCFL_UNITE_LEVEL_LESS"
  "ERR_OP_EXP_NOT_OPEN"
  "ERR_OP_ROLE_LEAVE"
  "ERR_OTHER_GAOJIGU_NOTOPEN"
  "ERR_OTHER_HAS_ALLIANCE"
  "ERR_PAIRPET_INVITEINVALID"
  "ERR_PAIRPET_INVITEREPEAT"
  "ERR_PAIRPET_OTHER"
  "ERR_PAIRPET_OTHERNOTIN"
  "ERR_PAIRPET_OUTRANGE"
  "ERR_PAIRPET_SCENEINVALID"
  "ERR_PAIRPET_SELF"
  "ERR_PANDORA_LACKOF_FIRE"
  "ERR_PANDORA_LACKOF_HEART"
  "ERR_PARTNER_ALREADY_APPLY_LEAVE"
  "ERR_PARTNER_ALREADY_HAS"
  "ERR_PARTNER_CD_NOT_OK"
  "ERR_PARTNER_CHEST_TAKED"
  "ERR_PARTNER_FDEGREE_NOT_ENOUGH"
  "ERR_PARTNER_ITEM_NOT_FOUND"
  "ERR_PARTNER_LEVEL_NOT_ENOUGH"
  "ERR_PARTNER_LN_NOT_ENOUGH"
  "ERR_PARTNER_NOT_APPLY_LEAVE"
  "ERR_PARTNER_NOT_ENOUGH_DRAGON"
  "ERR_PARTNER_NOT_IN_MAIN_HALL"
  "ERR_PARTNER_NO_PARTNER"
  "ERR_PARTNER_NUM_INVALID"
  "ERR_PARTNER_OTHER_BUYING"
  "ERR_PARTNER_SHOP_NO_COUNT"
  "ERR_PASSWORD_ERROR"
  "ERR_PETSYS_NOT_OPEN"
  "ERR_PET_EXP_EQUAL"
  "ERR_PET_IS_FULL"
  "ERR_PET_NOT_EXIST"
  "ERR_PET_SEAT_NOT_ENOUGH"
  "ERR_PE_CAN_NOT_RELEASE"
  "ERR_PK_NOMATCH"
  "ERR_PK_OPENTIME"
  "ERR_PLATSHARE_FAILED"
  "ERR_PLAT_BANACC"
  "ERR_POK_MATCH_ENDSOON"
  "ERR_PROFESSION_TYPE"
  "ERR_PROF_ERROR"
  "ERR_PROF_LEVELREQ"
  "ERR_PROF_LEVELREQ2"
  "ERR_PVP_ROLE_INBATTLE"
  "ERR_PVP_TEAM_MATCH"
  "ERR_QA_ALEADY_IN_ROOM"
  "ERR_QA_IN_OTHER_TYPE"
  "ERR_QA_LEVEL_NOT_ENOUGH"
  "ERR_QA_NOT_IN_TIME"
  "ERR_QA_NO_COUNT"
  "ERR_QA_NO_DATA"
  "ERR_QA_NO_GUILD"
  "ERR_QA_NO_GUILD_ROOM"
  "ERR_QA_OVER_NAME_TIME"
  "ERR_QUERYBOX_TIMELEFT"
  "ERR_QUESTCAREER_NOT_ONLINE"
  "ERR_RANDOMFRIEND_CD"
  "ERR_RECONNECT_FAIL"
  "ERR_REGISTER_NUM_LIMIT"
  "ERR_REINFORCE_LACKMONEY"
  "ERR_REINFORCE_LEVELLIMIT"
  "ERR_RELOGIN"
  "ERR_REPORT_FORBID"
  "ERR_REQUEST_REPEAT"
  "ERR_RESWAR_ACTIVITY"
  "ERR_RESWAR_CD"
  "ERR_RESWAR_DIFF_GUILD"
  "ERR_RESWAR_GROUP"
  "ERR_RESWAR_LACKPLAYER"
  "ERR_RESWAR_LEADER"
  "ERR_RESWAR_LEAVETEAM"
  "ERR_RESWAR_STATE"
  "ERR_RESWAR_TEAM"
  "ERR_RESWAR_TEAMFIGHTING"
  "ERR_REVIVE_ITEMLIMIT"
  "ERR_REVIVE_MAXNUM"
  "ERR_REVIVE_MONEYLIMIT"
  "ERR_REWARD_LIMIT"
  "ERR_REWARD_NOTEXIST"
  "ERR_REWARD_TAKEN"
  "ERR_ROLE_IN_OTHER_SERVER"
  "ERR_ROLE_LOGOUT"
  "ERR_ROLE_NOTEXIST"
  "ERR_ROLE_NOT_ONLINE"
  "ERR_SCENE_COOLDOWN"
  "ERR_SCENE_LEVELREQ"
  "ERR_SCENE_NEEDPREVCOMPLETE"
  "ERR_SCENE_NEED_PRESCENE"
  "ERR_SCENE_NEED_PRETASK"
  "ERR_SCENE_NOFATIGUE"
  "ERR_SCENE_NOT_IN_CONFIG"
  "ERR_SCENE_NOT_PET"
  "ERR_SCENE_TIMELIMIT"
  "ERR_SCENE_TODYCOUNTLIMIT"
  "ERR_SELF_GIFT_SELF"
  "ERR_SELF_HAS_ALLIANCE"
  "ERR_SERVER_UNNORMAL"
  "ERR_SESSION_KICKOFF"
  "ERR_SHOP_ARENALIMIT"
  "ERR_SHOP_COUNTLIMIT"
  "ERR_SHOP_DAILYCOUNTLIMIT"
  "ERR_SHOP_GUILDLIMIT"
  "ERR_SHOP_INVALID"
  "ERR_SHOP_ITEMNOTEXIST"
  "ERR_SHOP_LACKMONEY"
  "ERR_SHOP_LEVELLIMIT"
  "ERR_SHOP_OPENLIMIT"
  "ERR_SHOP_PKLIMIT"
  "ERR_SHOP_PPTLIMIT"
  "ERR_SHOP_TIMELIMIT"
  "ERR_SHOP_VIPLIMIT"
  "ERR_SHOP_WEEKCOUNTLIMIT"
  "ERR_SKILL_CONFIGERROR"
  "ERR_SKILL_GUILD_CONTRIBUTE"
  "ERR_SKILL_ITEMREQ"
  "ERR_SKILL_LEVELREQ"
  "ERR_SKILL_MAXLEVEL"
  "ERR_SKILL_NEED_EXPRESKILL"
  "ERR_SKILL_NEED_PRESKILL"
  "ERR_SKILL_NOT_MATCH"
  "ERR_SKILL_POINT"
  "ERR_SKILL_PREPOINTLIMIT"
  "ERR_SKILL_PROFESSION_ERROR"
  "ERR_SKYCITY_IN_TEAM"
  "ERR_SKYCITY_LV"
  "ERR_SKYCITY_NOT_OPEN"
  "ERR_SKYCITY_TEAM_OUTTIME"
  "ERR_SKY_ALREADY_FIGHTED"
  "ERR_SKY_ALREADY_HAS_TEAM"
  "ERR_SKY_HAS_NOT_TEAM_MEMBER"
  "ERR_SKY_HAS_NO_TEAM"
  "ERR_SKY_INV_ALREADY_HAS_TEAM"
  "ERR_SKY_INV_NOT_TEAM_MEMBER"
  "ERR_SKY_NOT_TEAM_MEMBER"
  "ERR_SKY_TEAM_IN_BATTLE"
  "ERR_SKY_TEAM_IN_MATCH"
  "ERR_SKY_TEAM_NO_DAILY_NUM"
  "ERR_SKY_TEAM_ROLE_NUM_INVALID"
  "ERR_SLOTATTR_LEVELLIMIT"
  "ERR_SLOTATTR_MONEYLIMIT"
  "ERR_SLOTATTR_NOEQUIP"
  "ERR_SMELTCOUNT_ZERO"
  "ERR_SMELTING_INVALID"
  "ERR_SMELTING_LACKMONEY"
  "ERR_SMELTING_TRANSINVALID"
  "ERR_SMELT_MAXVALUE"
  "ERR_SMELT_MINLEVEL"
  "ERR_SPACTIVITY_NOPRIZE"
  "ERR_SPACTIVITY_NOTENOUGH_MONEY"
  "ERR_SPACTIVITY_NOTOPEN"
  "ERR_SPACTIVITY_NOTPRIZETIME"
  "ERR_SPACTIVITY_PRIZE_GET"
  "ERR_SPACTIVITY_TASK_GET"
  "ERR_SPACTIVITY_TASK_NOT_COMPLETE"
  "ERR_SPRITE_ALREADY_INFIGHT"
  "ERR_SPRITE_ALREADY_ISLEADER"
  "ERR_SPRITE_ALREADY_OUTFIGHT"
  "ERR_SPRITE_AWAKE_LACKOFCOST"
  "ERR_SPRITE_AWAKE_MAX"
  "ERR_SPRITE_AWAKE_ROLE_LEVELLIMIT"
  "ERR_SPRITE_EVOLUTION_LACKOFCOST"
  "ERR_SPRITE_EVOLUTION_LEVELLIMIT"
  "ERR_SPRITE_EVOLUTION_LEVELMAX"
  "ERR_SPRITE_EVOLUTION_ROLE_LEVELLIMIT"
  "ERR_SPRITE_INFIGHT_FULL"
  "ERR_SPRITE_INFIGHT_SAMETYPE"
  "ERR_SPRITE_LEVELMAX"
  "ERR_SPRITE_LEVELUP_LACKOFCOST"
  "ERR_SPRITE_NOTFIND"
  "ERR_SPRITE_NOTREBIRTH"
  "ERR_SPRITE_NOTTRAIN"
  "ERR_SPRITE_RESETTRAIN_LACKITEM"
  "ERR_SPRITE_TRAIN_CHOOSEMAX"
  "ERR_SPRITE_TRAIN_LACKITEM"
  "ERR_SPRITE_TRAIN_MAX"
  "ERR_SPRITE_TRAIN_NOT_ENOUGH"
  "ERR_STATE_CANTCHANGE"
  "ERR_STATE_ERROR"
  "ERR_SUCCESS"
  "ERR_SWEEP_NOT_THREE_STAR"
  "ERR_SWEEP_POWERPOINT_LESS"
  "ERR_SWEEP_TICKET_LESS"
  "ERR_SYS_NOTOPEN"
  "ERR_TASK_ALREADY_ASKED"
  "ERR_TASK_ALREADY_FINISH"
  "ERR_TASK_ALREADY_TAKE"
  "ERR_TASK_ASKITEM_REFRESH"
  "ERR_TASK_CANNOT_GIVEUP"
  "ERR_TASK_CANNOT_HELP"
  "ERR_TASK_CANNT_HELPSELF"
  "ERR_TASK_NOT_ACCEPT"
  "ERR_TASK_NOT_FINISH"
  "ERR_TASK_NOT_FOUND"
  "ERR_TASK_NOT_TASK_ITEM"
  "ERR_TASK_NO_ASKINFO"
  "ERR_TASK_NO_ASK_HELPNUM"
  "ERR_TASK_NO_REFRESH_COUNT"
  "ERR_TASK_NO_TABLE"
  "ERR_TEAMBUY_COUNT_MAX"
  "ERR_TEAMBUY_DIAMOND_LESS"
  "ERR_TEAMBUY_DRAGONCOIN_LESS"
  "ERR_TEAMCOST_DIAMOND"
  "ERR_TEAMCOST_DRAGON"
  "ERR_TEAMCOST_NUMLIMIT"
  "ERR_TEAM_ALREADY_INOTHERTEAM"
  "ERR_TEAM_ALREADY_INTEAM"
  "ERR_TEAM_CANNOT_FORNOW"
  "ERR_TEAM_CHANGE_EXP_TO_CROSS"
  "ERR_TEAM_COST_CANCEL"
  "ERR_TEAM_COST_WIN"
  "ERR_TEAM_CROSS_TEAM_CHANGE_EXP"
  "ERR_TEAM_DIAMOND_COST_LIMIT"
  "ERR_TEAM_DISAGREE_BATTLE"
  "ERR_TEAM_EXPEDITIONID_NOT_EXIST"
  "ERR_TEAM_EXPEDITION_DAYCOUNT"
  "ERR_TEAM_FASTMATCH_BUFF"
  "ERR_TEAM_FULL"
  "ERR_TEAM_GODDESS_DAYCOUNT"
  "ERR_TEAM_GUILD_DAYCOUNT"
  "ERR_TEAM_IDIP"
  "ERR_TEAM_INVITE_ROLE_IS_IN_BATTLE"
  "ERR_TEAM_INV_IN_FAMILY"
  "ERR_TEAM_INV_LOGOUT"
  "ERR_TEAM_INV_TIMEOUT"
  "ERR_TEAM_IN_BATTLE"
  "ERR_TEAM_LEADER_NOTHELPER"
  "ERR_TEAM_LEVEL_REQUARE"
  "ERR_TEAM_MATCHING"
  "ERR_TEAM_MEMBER_NOT_EXIST"
  "ERR_TEAM_MEMBER_NOT_ONLINE"
  "ERR_TEAM_MEMCOUNT_OVER"
  "ERR_TEAM_NEED_ATLEAST_2_MEMBER"
  "ERR_TEAM_NEST_DAYCOUNT"
  "ERR_TEAM_NOJOININBATTLE"
  "ERR_TEAM_NOT_EXIST"
  "ERR_TEAM_NOT_IN_HALL"
  "ERR_TEAM_NOT_OPENTIME"
  "ERR_TEAM_NOT_PASS"
  "ERR_TEAM_ONLY_LEADER_CAN_DO"
  "ERR_TEAM_ONLY_LEADER_CAN_KICK"
  "ERR_TEAM_ONLY_LEADER_CAN_STARTBATTLE"
  "ERR_TEAM_PPTLIMIT"
  "ERR_TEAM_SEAL_TYPE"
  "ERR_TEAM_SERVER_NOT_MATCH"
  "ERR_TEAM_SERVER_OPEN_TIME"
  "ERR_TEAM_STATE_ERROR"
  "ERR_TEAM_TICKET_CONFIG"
  "ERR_TEAM_TICKET_LESS"
  "ERR_TEAM_TICKET_SEAL"
  "ERR_TEAM_TOWER_DAYCOUNT"
  "ERR_TEAM_USE_TICKET_COUNT_LESS"
  "ERR_TEAM_VOTE"
  "ERR_TEAM_WEEK_NEST_EXP"
  "ERR_TEAM_WRONG_PASSWORD"
  "ERR_TIMEOUT"
  "ERR_TITLE_LACKITEM"
  "ERR_TITLE_MAX"
  "ERR_TITLE_PPTLIMIT"
  "ERR_TOWER_FLOOR_NOTENOUGH"
  "ERR_TOWER_INSWEEP"
  "ERR_TRANSFERR_OTHER_ROLES_LEAVE"
  "ERR_TRANSFER_LACKMONEY"
  "ERR_TRANS_ITEMNOTENOUGH"
  "ERR_TRANS_NONE"
  "ERR_TRANS_OTHERNOTEXIST"
  "ERR_TRANS_PASSIVE"
  "ERR_TRANS_SCENE_INVALID"
  "ERR_TRANS_STATE_FAILED"
  "ERR_TSHOW_LEVEL_NOTENOUGH"
  "ERR_UNKNOWN"
  "ERR_UNOPEN_FUNCTION"
  "ERR_UNUSE1"
  "ERR_VERSION_FAILED"
  "ERR_WATCH_LIVEISFULL"
  "ERR_WATCH_LIVEISOVER"
  "ERR_WATCH_WAIT"
  "ERR_WEDDINGCAR_CANT_IN_PET"
  "ERR_WEDDINGCAR_OTHER_RUNNING"
  "ERR_WEDDING_ALREADY_APPLY"
  "ERR_WEDDING_ALREADY_HOLDED"
  "ERR_WEDDING_ALREADY_INVITE"
  "ERR_WEDDING_ALREADY_REFUSE"
  "ERR_WEDDING_ALREADY_TAKECAR"
  "ERR_WEDDING_ALREADY_VOWS"
  "ERR_WEDDING_HP_NOT_ENOUGH"
  "ERR_WEDDING_INVITE_OVERMAX"
  "ERR_WEDDING_IS_HOLDING"
  "ERR_WEDDING_NEED_TWO_MARRIAGE"
  "ERR_WEDDING_NOT_APPLY"
  "ERR_WEDDING_NOT_EXISTS"
  "ERR_WEDDING_NOT_INVITE"
  "ERR_WEDDING_NOT_OWNER"
  "ERR_WEDDING_NOT_RUNNING"
  "ERR_WEDDING_OPER_CD"
  "ERR_WORD_FORBID"
  "ERR_WORLDBOSSGUILD_COUNTLIMIT"
  "ERR_WORLDBOSSGUILD_UNMATCH"
  "ERR_WORLDBOSS_DEAD"
  "GUILD_SKILL_GUILD_LEVEL_LIMIT"
  "GUILD_SKILL_STUDY_LEVEL_LIMIT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ErrorCode_entries[] = {
  { {ErrorCode_names + 0, 21}, 296 },
  { {ErrorCode_names + 21, 21}, 604 },
  { {ErrorCode_names + 42, 15}, 850 },
  { {ErrorCode_names + 57, 22}, 11 },
  { {ErrorCode_names + 79, 19}, 234 },
  { {ErrorCode_names + 98, 21}, 4 },
  { {ErrorCode_names + 119, 19}, 262 },
  { {ErrorCode_names + 138, 21}, 10 },
  { {ErrorCode_names + 159, 22}, 16 },
  { {ErrorCode_names + 181, 20}, 17 },
  { {ErrorCode_names + 201, 12}, 897 },
  { {ErrorCode_names + 213, 24}, 52 },
  { {ErrorCode_names + 237, 25}, 51 },
  { {ErrorCode_names + 262, 27}, 53 },
  { {ErrorCode_names + 289, 35}, 54 },
  { {ErrorCode_names + 324, 16}, 895 },
  { {ErrorCode_names + 340, 23}, 195 },
  { {ErrorCode_names + 363, 17}, 104 },
  { {ErrorCode_names + 380, 21}, 803 },
  { {ErrorCode_names + 401, 23}, 1023 },
  { {ErrorCode_names + 424, 19}, 186 },
  { {ErrorCode_names + 443, 22}, 552 },
  { {ErrorCode_names + 465, 20}, 838 },
  { {ErrorCode_names + 485, 21}, 908 },
  { {ErrorCode_names + 506, 26}, 907 },
  { {ErrorCode_names + 532, 23}, 305 },
  { {ErrorCode_names + 555, 14}, 763 },
  { {ErrorCode_names + 569, 26}, 55 },
  { {ErrorCode_names + 595, 20}, 31 },
  { {ErrorCode_names + 615, 15}, 30 },
  { {ErrorCode_names + 630, 21}, 75 },
  { {ErrorCode_names + 651, 21}, 778 },
  { {ErrorCode_names + 672, 21}, 941 },
  { {ErrorCode_names + 693, 28}, 944 },
  { {ErrorCode_names + 721, 23}, 940 },
  { {ErrorCode_names + 744, 32}, 815 },
  { {ErrorCode_names + 776, 34}, 812 },
  { {ErrorCode_names + 810, 27}, 814 },
  { {ErrorCode_names + 837, 36}, 813 },
  { {ErrorCode_names + 873, 23}, 942 },
  { {ErrorCode_names + 896, 27}, 943 },
  { {ErrorCode_names + 923, 30}, 956 },
  { {ErrorCode_names + 953, 19}, 302 },
  { {ErrorCode_names + 972, 16}, 202 },
  { {ErrorCode_names + 988, 17}, 581 },
  { {ErrorCode_names + 1005, 25}, 301 },
  { {ErrorCode_names + 1030, 16}, 185 },
  { {ErrorCode_names + 1046, 18}, 189 },
  { {ErrorCode_names + 1064, 23}, 184 },
  { {ErrorCode_names + 1087, 20}, 179 },
  { {ErrorCode_names + 1107, 20}, 180 },
  { {ErrorCode_names + 1127, 18}, 190 },
  { {ErrorCode_names + 1145, 18}, 297 },
  { {ErrorCode_names + 1163, 18}, 298 },
  { {ErrorCode_names + 1181, 18}, 188 },
  { {ErrorCode_names + 1199, 18}, 183 },
  { {ErrorCode_names + 1217, 19}, 181 },
  { {ErrorCode_names + 1236, 21}, 578 },
  { {ErrorCode_names + 1257, 24}, 299 },
  { {ErrorCode_names + 1281, 20}, 182 },
  { {ErrorCode_names + 1301, 12}, 681 },
  { {ErrorCode_names + 1313, 14}, 700 },
  { {ErrorCode_names + 1327, 19}, 241 },
  { {ErrorCode_names + 1346, 22}, 769 },
  { {ErrorCode_names + 1368, 27}, 1021 },
  { {ErrorCode_names + 1395, 28}, 1019 },
  { {ErrorCode_names + 1423, 31}, 1020 },
  { {ErrorCode_names + 1454, 31}, 1017 },
  { {ErrorCode_names + 1485, 28}, 1018 },
  { {ErrorCode_names + 1513, 26}, 1022 },
  { {ErrorCode_names + 1539, 23}, 1011 },
  { {ErrorCode_names + 1562, 19}, 952 },
  { {ErrorCode_names + 1581, 22}, 1012 },
  { {ErrorCode_names + 1603, 22}, 844 },
  { {ErrorCode_names + 1625, 22}, 845 },
  { {ErrorCode_names + 1647, 12}, 572 },
  { {ErrorCode_names + 1659, 25}, 809 },
  { {ErrorCode_names + 1684, 29}, 577 },
  { {ErrorCode_names + 1713, 29}, 810 },
  { {ErrorCode_names + 1742, 27}, 575 },
  { {ErrorCode_names + 1769, 26}, 573 },
  { {ErrorCode_names + 1795, 28}, 574 },
  { {ErrorCode_names + 1823, 25}, 576 },
  { {ErrorCode_names + 1848, 21}, 966 },
  { {ErrorCode_names + 1869, 24}, 965 },
  { {ErrorCode_names + 1893, 23}, 24 },
  { {ErrorCode_names + 1916, 24}, 23 },
  { {ErrorCode_names + 1940, 23}, 22 },
  { {ErrorCode_names + 1963, 14}, 218 },
  { {ErrorCode_names + 1977, 17}, 93 },
  { {ErrorCode_names + 1994, 16}, 92 },
  { {ErrorCode_names + 2010, 13}, 221 },
  { {ErrorCode_names + 2023, 18}, 94 },
  { {ErrorCode_names + 2041, 18}, 266 },
  { {ErrorCode_names + 2059, 14}, 267 },
  { {ErrorCode_names + 2073, 13}, 59 },
  { {ErrorCode_names + 2086, 25}, 972 },
  { {ErrorCode_names + 2111, 18}, 697 },
  { {ErrorCode_names + 2129, 13}, 968 },
  { {ErrorCode_names + 2142, 14}, 707 },
  { {ErrorCode_names + 2156, 34}, 704 },
  { {ErrorCode_names + 2190, 30}, 628 },
  { {ErrorCode_names + 2220, 25}, 528 },
  { {ErrorCode_names + 2245, 25}, 531 },
  { {ErrorCode_names + 2270, 21}, 530 },
  { {ErrorCode_names + 2291, 21}, 529 },
  { {ErrorCode_names + 2312, 26}, 689 },
  { {ErrorCode_names + 2338, 22}, 762 },
  { {ErrorCode_names + 2360, 19}, 735 },
  { {ErrorCode_names + 2379, 21}, 736 },
  { {ErrorCode_names + 2400, 23}, 738 },
  { {ErrorCode_names + 2423, 18}, 741 },
  { {ErrorCode_names + 2441, 19}, 733 },
  { {ErrorCode_names + 2460, 21}, 737 },
  { {ErrorCode_names + 2481, 18}, 734 },
  { {ErrorCode_names + 2499, 20}, 1016 },
  { {ErrorCode_names + 2519, 32}, 101 },
  { {ErrorCode_names + 2551, 25}, 102 },
  { {ErrorCode_names + 2576, 22}, 560 },
  { {ErrorCode_names + 2598, 21}, 559 },
  { {ErrorCode_names + 2619, 20}, 85 },
  { {ErrorCode_names + 2639, 19}, 84 },
  { {ErrorCode_names + 2658, 15}, 274 },
  { {ErrorCode_names + 2673, 18}, 86 },
  { {ErrorCode_names + 2691, 16}, 49 },
  { {ErrorCode_names + 2707, 26}, 50 },
  { {ErrorCode_names + 2733, 15}, 932 },
  { {ErrorCode_names + 2748, 27}, 527 },
  { {ErrorCode_names + 2775, 28}, 971 },
  { {ErrorCode_names + 2803, 15}, 775 },
  { {ErrorCode_names + 2818, 23}, 759 },
  { {ErrorCode_names + 2841, 30}, 830 },
  { {ErrorCode_names + 2871, 35}, 900 },
  { {ErrorCode_names + 2906, 34}, 823 },
  { {ErrorCode_names + 2940, 28}, 820 },
  { {ErrorCode_names + 2968, 29}, 856 },
  { {ErrorCode_names + 2997, 24}, 818 },
  { {ErrorCode_names + 3021, 31}, 816 },
  { {ErrorCode_names + 3052, 27}, 828 },
  { {ErrorCode_names + 3079, 25}, 826 },
  { {ErrorCode_names + 3104, 36}, 827 },
  { {ErrorCode_names + 3140, 35}, 825 },
  { {ErrorCode_names + 3175, 31}, 824 },
  { {ErrorCode_names + 3206, 27}, 821 },
  { {ErrorCode_names + 3233, 28}, 831 },
  { {ErrorCode_names + 3261, 28}, 862 },
  { {ErrorCode_names + 3289, 24}, 860 },
  { {ErrorCode_names + 3313, 24}, 861 },
  { {ErrorCode_names + 3337, 27}, 829 },
  { {ErrorCode_names + 3364, 24}, 819 },
  { {ErrorCode_names + 3388, 32}, 855 },
  { {ErrorCode_names + 3420, 29}, 840 },
  { {ErrorCode_names + 3449, 25}, 839 },
  { {ErrorCode_names + 3474, 29}, 854 },
  { {ErrorCode_names + 3503, 29}, 822 },
  { {ErrorCode_names + 3532, 29}, 817 },
  { {ErrorCode_names + 3561, 18}, 867 },
  { {ErrorCode_names + 3579, 21}, 891 },
  { {ErrorCode_names + 3600, 18}, 866 },
  { {ErrorCode_names + 3618, 20}, 890 },
  { {ErrorCode_names + 3638, 28}, 982 },
  { {ErrorCode_names + 3666, 27}, 983 },
  { {ErrorCode_names + 3693, 31}, 981 },
  { {ErrorCode_names + 3724, 33}, 1001 },
  { {ErrorCode_names + 3757, 26}, 984 },
  { {ErrorCode_names + 3783, 29}, 950 },
  { {ErrorCode_names + 3812, 24}, 758 },
  { {ErrorCode_names + 3836, 23}, 756 },
  { {ErrorCode_names + 3859, 20}, 33 },
  { {ErrorCode_names + 3879, 20}, 32 },
  { {ErrorCode_names + 3899, 21}, 34 },
  { {ErrorCode_names + 3920, 20}, 985 },
  { {ErrorCode_names + 3940, 17}, 994 },
  { {ErrorCode_names + 3957, 19}, 986 },
  { {ErrorCode_names + 3976, 23}, 987 },
  { {ErrorCode_names + 3999, 11}, 988 },
  { {ErrorCode_names + 4010, 12}, 995 },
  { {ErrorCode_names + 4022, 21}, 996 },
  { {ErrorCode_names + 4043, 16}, 993 },
  { {ErrorCode_names + 4059, 22}, 1007 },
  { {ErrorCode_names + 4081, 19}, 991 },
  { {ErrorCode_names + 4100, 18}, 999 },
  { {ErrorCode_names + 4118, 20}, 992 },
  { {ErrorCode_names + 4138, 19}, 997 },
  { {ErrorCode_names + 4157, 20}, 1000 },
  { {ErrorCode_names + 4177, 14}, 989 },
  { {ErrorCode_names + 4191, 20}, 998 },
  { {ErrorCode_names + 4211, 19}, 990 },
  { {ErrorCode_names + 4230, 23}, 954 },
  { {ErrorCode_names + 4253, 15}, 672 },
  { {ErrorCode_names + 4268, 20}, 583 },
  { {ErrorCode_names + 4288, 27}, 252 },
  { {ErrorCode_names + 4315, 27}, 247 },
  { {ErrorCode_names + 4342, 23}, 224 },
  { {ErrorCode_names + 4365, 19}, 44 },
  { {ErrorCode_names + 4384, 22}, 42 },
  { {ErrorCode_names + 4406, 21}, 222 },
  { {ErrorCode_names + 4427, 22}, 223 },
  { {ErrorCode_names + 4449, 23}, 729 },
  { {ErrorCode_names + 4472, 20}, 631 },
  { {ErrorCode_names + 4492, 20}, 629 },
  { {ErrorCode_names + 4512, 19}, 728 },
  { {ErrorCode_names + 4531, 25}, 833 },
  { {ErrorCode_names + 4556, 32}, 730 },
  { {ErrorCode_names + 4588, 20}, 632 },
  { {ErrorCode_names + 4608, 17}, 25 },
  { {ErrorCode_names + 4625, 18}, 27 },
  { {ErrorCode_names + 4643, 20}, 26 },
  { {ErrorCode_names + 4663, 15}, 29 },
  { {ErrorCode_names + 4678, 34}, 290 },
  { {ErrorCode_names + 4712, 19}, 28 },
  { {ErrorCode_names + 4731, 22}, 213 },
  { {ErrorCode_names + 4753, 20}, 214 },
  { {ErrorCode_names + 4773, 19}, 717 },
  { {ErrorCode_names + 4792, 22}, 724 },
  { {ErrorCode_names + 4814, 25}, 718 },
  { {ErrorCode_names + 4839, 26}, 719 },
  { {ErrorCode_names + 4865, 22}, 197 },
  { {ErrorCode_names + 4887, 26}, 834 },
  { {ErrorCode_names + 4913, 27}, 835 },
  { {ErrorCode_names + 4940, 10}, 9 },
  { {ErrorCode_names + 4950, 25}, 693 },
  { {ErrorCode_names + 4975, 28}, 106 },
  { {ErrorCode_names + 5003, 22}, 694 },
  { {ErrorCode_names + 5025, 26}, 692 },
  { {ErrorCode_names + 5051, 28}, 691 },
  { {ErrorCode_names + 5079, 22}, 874 },
  { {ErrorCode_names + 5101, 24}, 872 },
  { {ErrorCode_names + 5125, 23}, 871 },
  { {ErrorCode_names + 5148, 27}, 841 },
  { {ErrorCode_names + 5175, 27}, 1010 },
  { {ErrorCode_names + 5202, 21}, 88 },
  { {ErrorCode_names + 5223, 19}, 873 },
  { {ErrorCode_names + 5242, 25}, 87 },
  { {ErrorCode_names + 5267, 23}, 169 },
  { {ErrorCode_names + 5290, 24}, 168 },
  { {ErrorCode_names + 5314, 24}, 170 },
  { {ErrorCode_names + 5338, 20}, 114 },
  { {ErrorCode_names + 5358, 21}, 112 },
  { {ErrorCode_names + 5379, 20}, 113 },
  { {ErrorCode_names + 5399, 15}, 111 },
  { {ErrorCode_names + 5414, 15}, 627 },
  { {ErrorCode_names + 5429, 16}, 731 },
  { {ErrorCode_names + 5445, 15}, 732 },
  { {ErrorCode_names + 5460, 19}, 859 },
  { {ErrorCode_names + 5479, 27}, 925 },
  { {ErrorCode_names + 5506, 18}, 216 },
  { {ErrorCode_names + 5524, 21}, 677 },
  { {ErrorCode_names + 5545, 14}, 89 },
  { {ErrorCode_names + 5559, 19}, 208 },
  { {ErrorCode_names + 5578, 19}, 91 },
  { {ErrorCode_names + 5597, 19}, 90 },
  { {ErrorCode_names + 5616, 15}, 220 },
  { {ErrorCode_names + 5631, 20}, 209 },
  { {ErrorCode_names + 5651, 21}, 210 },
  { {ErrorCode_names + 5672, 21}, 1025 },
  { {ErrorCode_names + 5693, 15}, 1024 },
  { {ErrorCode_names + 5708, 12}, 969 },
  { {ErrorCode_names + 5720, 37}, 192 },
  { {ErrorCode_names + 5757, 27}, 541 },
  { {ErrorCode_names + 5784, 25}, 540 },
  { {ErrorCode_names + 5809, 19}, 543 },
  { {ErrorCode_names + 5828, 26}, 963 },
  { {ErrorCode_names + 5854, 27}, 563 },
  { {ErrorCode_names + 5881, 23}, 599 },
  { {ErrorCode_names + 5904, 18}, 545 },
  { {ErrorCode_names + 5922, 25}, 598 },
  { {ErrorCode_names + 5947, 25}, 517 },
  { {ErrorCode_names + 5972, 17}, 544 },
  { {ErrorCode_names + 5989, 28}, 516 },
  { {ErrorCode_names + 6017, 26}, 519 },
  { {ErrorCode_names + 6043, 26}, 520 },
  { {ErrorCode_names + 6069, 22}, 562 },
  { {ErrorCode_names + 6091, 19}, 539 },
  { {ErrorCode_names + 6110, 24}, 542 },
  { {ErrorCode_names + 6134, 26}, 561 },
  { {ErrorCode_names + 6160, 30}, 518 },
  { {ErrorCode_names + 6190, 22}, 713 },
  { {ErrorCode_names + 6212, 21}, 761 },
  { {ErrorCode_names + 6233, 22}, 686 },
  { {ErrorCode_names + 6255, 24}, 687 },
  { {ErrorCode_names + 6279, 21}, 688 },
  { {ErrorCode_names + 6300, 22}, 706 },
  { {ErrorCode_names + 6322, 19}, 811 },
  { {ErrorCode_names + 6341, 21}, 556 },
  { {ErrorCode_names + 6362, 23}, 557 },
  { {ErrorCode_names + 6385, 27}, 546 },
  { {ErrorCode_names + 6412, 23}, 579 },
  { {ErrorCode_names + 6435, 15}, 523 },
  { {ErrorCode_names + 6450, 17}, 522 },
  { {ErrorCode_names + 6467, 19}, 582 },
  { {ErrorCode_names + 6486, 23}, 901 },
  { {ErrorCode_names + 6509, 29}, 934 },
  { {ErrorCode_names + 6538, 30}, 904 },
  { {ErrorCode_names + 6568, 27}, 903 },
  { {ErrorCode_names + 6595, 24}, 936 },
  { {ErrorCode_names + 6619, 25}, 902 },
  { {ErrorCode_names + 6644, 21}, 935 },
  { {ErrorCode_names + 6665, 13}, 105 },
  { {ErrorCode_names + 6678, 14}, 256 },
  { {ErrorCode_names + 6692, 26}, 806 },
  { {ErrorCode_names + 6718, 26}, 805 },
  { {ErrorCode_names + 6744, 25}, 804 },
  { {ErrorCode_names + 6769, 33}, 808 },
  { {ErrorCode_names + 6802, 25}, 690 },
  { {ErrorCode_names + 6827, 21}, 586 },
  { {ErrorCode_names + 6848, 25}, 124 },
  { {ErrorCode_names + 6873, 21}, 125 },
  { {ErrorCode_names + 6894, 21}, 847 },
  { {ErrorCode_names + 6915, 23}, 123 },
  { {ErrorCode_names + 6938, 16}, 589 },
  { {ErrorCode_names + 6954, 19}, 587 },
  { {ErrorCode_names + 6973, 18}, 590 },
  { {ErrorCode_names + 6991, 17}, 588 },
  { {ErrorCode_names + 7008, 25}, 852 },
  { {ErrorCode_names + 7033, 24}, 851 },
  { {ErrorCode_names + 7057, 29}, 857 },
  { {ErrorCode_names + 7086, 27}, 115 },
  { {ErrorCode_names + 7113, 25}, 117 },
  { {ErrorCode_names + 7138, 24}, 116 },
  { {ErrorCode_names + 7162, 25}, 128 },
  { {ErrorCode_names + 7187, 25}, 121 },
  { {ErrorCode_names + 7212, 22}, 118 },
  { {ErrorCode_names + 7234, 22}, 119 },
  { {ErrorCode_names + 7256, 22}, 120 },
  { {ErrorCode_names + 7278, 21}, 1004 },
  { {ErrorCode_names + 7299, 25}, 1005 },
  { {ErrorCode_names + 7324, 24}, 1008 },
  { {ErrorCode_names + 7348, 23}, 842 },
  { {ErrorCode_names + 7371, 22}, 550 },
  { {ErrorCode_names + 7393, 26}, 99 },
  { {ErrorCode_names + 7419, 19}, 217 },
  { {ErrorCode_names + 7438, 33}, 205 },
  { {ErrorCode_names + 7471, 32}, 204 },
  { {ErrorCode_names + 7503, 20}, 143 },
  { {ErrorCode_names + 7523, 19}, 227 },
  { {ErrorCode_names + 7542, 14}, 107 },
  { {ErrorCode_names + 7556, 25}, 620 },
  { {ErrorCode_names + 7581, 25}, 615 },
  { {ErrorCode_names + 7606, 21}, 608 },
  { {ErrorCode_names + 7627, 21}, 609 },
  { {ErrorCode_names + 7648, 27}, 611 },
  { {ErrorCode_names + 7675, 26}, 607 },
  { {ErrorCode_names + 7701, 29}, 625 },
  { {ErrorCode_names + 7730, 23}, 610 },
  { {ErrorCode_names + 7753, 25}, 515 },
  { {ErrorCode_names + 7778, 19}, 132 },
  { {ErrorCode_names + 7797, 19}, 777 },
  { {ErrorCode_names + 7816, 19}, 215 },
  { {ErrorCode_names + 7835, 26}, 110 },
  { {ErrorCode_names + 7861, 20}, 97 },
  { {ErrorCode_names + 7881, 19}, 776 },
  { {ErrorCode_names + 7900, 23}, 155 },
  { {ErrorCode_names + 7923, 24}, 154 },
  { {ErrorCode_names + 7947, 18}, 551 },
  { {ErrorCode_names + 7965, 19}, 96 },
  { {ErrorCode_names + 7984, 22}, 98 },
  { {ErrorCode_names + 8006, 23}, 100 },
  { {ErrorCode_names + 8029, 22}, 142 },
  { {ErrorCode_names + 8051, 19}, 126 },
  { {ErrorCode_names + 8070, 17}, 108 },
  { {ErrorCode_names + 8087, 19}, 141 },
  { {ErrorCode_names + 8106, 22}, 109 },
  { {ErrorCode_names + 8128, 29}, 768 },
  { {ErrorCode_names + 8157, 18}, 906 },
  { {ErrorCode_names + 8175, 25}, 703 },
  { {ErrorCode_names + 8200, 27}, 702 },
  { {ErrorCode_names + 8227, 23}, 783 },
  { {ErrorCode_names + 8250, 24}, 781 },
  { {ErrorCode_names + 8274, 16}, 698 },
  { {ErrorCode_names + 8290, 18}, 701 },
  { {ErrorCode_names + 8308, 13}, 1009 },
  { {ErrorCode_names + 8321, 18}, 655 },
  { {ErrorCode_names + 8339, 16}, 751 },
  { {ErrorCode_names + 8355, 14}, 705 },
  { {ErrorCode_names + 8369, 26}, 801 },
  { {ErrorCode_names + 8395, 17}, 802 },
  { {ErrorCode_names + 8412, 20}, 832 },
  { {ErrorCode_names + 8432, 21}, 800 },
  { {ErrorCode_names + 8453, 24}, 836 },
  { {ErrorCode_names + 8477, 15}, 849 },
  { {ErrorCode_names + 8492, 16}, 277 },
  { {ErrorCode_names + 8508, 19}, 276 },
  { {ErrorCode_names + 8527, 22}, 272 },
  { {ErrorCode_names + 8549, 21}, 273 },
  { {ErrorCode_names + 8570, 20}, 270 },
  { {ErrorCode_names + 8590, 21}, 271 },
  { {ErrorCode_names + 8611, 20}, 292 },
  { {ErrorCode_names + 8631, 19}, 291 },
  { {ErrorCode_names + 8650, 16}, 203 },
  { {ErrorCode_names + 8666, 20}, 553 },
  { {ErrorCode_names + 8686, 17}, 774 },
  { {ErrorCode_names + 8703, 16}, 6 },
  { {ErrorCode_names + 8719, 19}, 928 },
  { {ErrorCode_names + 8738, 19}, 257 },
  { {ErrorCode_names + 8757, 17}, 1015 },
  { {ErrorCode_names + 8774, 26}, 669 },
  { {ErrorCode_names + 8800, 22}, 671 },
  { {ErrorCode_names + 8822, 23}, 668 },
  { {ErrorCode_names + 8845, 26}, 670 },
  { {ErrorCode_names + 8871, 29}, 673 },
  { {ErrorCode_names + 8900, 21}, 664 },
  { {ErrorCode_names + 8921, 21}, 665 },
  { {ErrorCode_names + 8942, 24}, 666 },
  { {ErrorCode_names + 8966, 24}, 667 },
  { {ErrorCode_names + 8990, 24}, 663 },
  { {ErrorCode_names + 9014, 24}, 41 },
  { {ErrorCode_names + 9038, 17}, 161 },
  { {ErrorCode_names + 9055, 19}, 40 },
  { {ErrorCode_names + 9074, 21}, 199 },
  { {ErrorCode_names + 9095, 24}, 58 },
  { {ErrorCode_names + 9119, 17}, 39 },
  { {ErrorCode_names + 9136, 19}, 43 },
  { {ErrorCode_names + 9155, 26}, 937 },
  { {ErrorCode_names + 9181, 25}, 175 },
  { {ErrorCode_names + 9206, 26}, 47 },
  { {ErrorCode_names + 9232, 23}, 46 },
  { {ErrorCode_names + 9255, 23}, 48 },
  { {ErrorCode_names + 9278, 24}, 909 },
  { {ErrorCode_names + 9302, 22}, 295 },
  { {ErrorCode_names + 9324, 17}, 45 },
  { {ErrorCode_names + 9341, 22}, 231 },
  { {ErrorCode_names + 9363, 20}, 57 },
  { {ErrorCode_names + 9383, 25}, 56 },
  { {ErrorCode_names + 9408, 16}, 254 },
  { {ErrorCode_names + 9424, 18}, 558 },
  { {ErrorCode_names + 9442, 18}, 235 },
  { {ErrorCode_names + 9460, 31}, 1006 },
  { {ErrorCode_names + 9491, 12}, 150 },
  { {ErrorCode_names + 9503, 15}, 151 },
  { {ErrorCode_names + 9518, 26}, 749 },
  { {ErrorCode_names + 9544, 27}, 709 },
  { {ErrorCode_names + 9571, 30}, 764 },
  { {ErrorCode_names + 9601, 22}, 711 },
  { {ErrorCode_names + 9623, 31}, 753 },
  { {ErrorCode_names + 9654, 26}, 752 },
  { {ErrorCode_names + 9680, 28}, 750 },
  { {ErrorCode_names + 9708, 28}, 742 },
  { {ErrorCode_names + 9736, 22}, 708 },
  { {ErrorCode_names + 9758, 30}, 722 },
  { {ErrorCode_names + 9788, 26}, 720 },
  { {ErrorCode_names + 9814, 24}, 721 },
  { {ErrorCode_names + 9838, 28}, 757 },
  { {ErrorCode_names + 9866, 25}, 727 },
  { {ErrorCode_names + 9891, 24}, 714 },
  { {ErrorCode_names + 9915, 25}, 712 },
  { {ErrorCode_names + 9940, 29}, 743 },
  { {ErrorCode_names + 9969, 28}, 715 },
  { {ErrorCode_names + 9997, 32}, 710 },
  { {ErrorCode_names + 10029, 30}, 300 },
  { {ErrorCode_names + 10059, 23}, 931 },
  { {ErrorCode_names + 10082, 15}, 275 },
  { {ErrorCode_names + 10097, 16}, 162 },
  { {ErrorCode_names + 10113, 16}, 163 },
  { {ErrorCode_names + 10129, 18}, 79 },
  { {ErrorCode_names + 10147, 27}, 303 },
  { {ErrorCode_names + 10174, 17}, 78 },
  { {ErrorCode_names + 10191, 23}, 95 },
  { {ErrorCode_names + 10214, 33}, 922 },
  { {ErrorCode_names + 10247, 28}, 916 },
  { {ErrorCode_names + 10275, 28}, 914 },
  { {ErrorCode_names + 10303, 22}, 951 },
  { {ErrorCode_names + 10325, 30}, 915 },
  { {ErrorCode_names + 10355, 26}, 921 },
  { {ErrorCode_names + 10381, 30}, 923 },
  { {ErrorCode_names + 10411, 39}, 924 },
  { {ErrorCode_names + 10450, 34}, 887 },
  { {ErrorCode_names + 10484, 29}, 807 },
  { {ErrorCode_names + 10513, 22}, 682 },
  { {ErrorCode_names + 10535, 41}, 794 },
  { {ErrorCode_names + 10576, 43}, 793 },
  { {ErrorCode_names + 10619, 40}, 893 },
  { {ErrorCode_names + 10659, 41}, 892 },
  { {ErrorCode_names + 10700, 34}, 889 },
  { {ErrorCode_names + 10734, 22}, 869 },
  { {ErrorCode_names + 10756, 38}, 888 },
  { {ErrorCode_names + 10794, 28}, 886 },
  { {ErrorCode_names + 10822, 23}, 684 },
  { {ErrorCode_names + 10845, 25}, 683 },
  { {ErrorCode_names + 10870, 27}, 767 },
  { {ErrorCode_names + 10897, 16}, 726 },
  { {ErrorCode_names + 10913, 26}, 868 },
  { {ErrorCode_names + 10939, 18}, 880 },
  { {ErrorCode_names + 10957, 20}, 896 },
  { {ErrorCode_names + 10977, 23}, 875 },
  { {ErrorCode_names + 11000, 25}, 870 },
  { {ErrorCode_names + 11025, 15}, 616 },
  { {ErrorCode_names + 11040, 14}, 306 },
  { {ErrorCode_names + 11054, 15}, 622 },
  { {ErrorCode_names + 11069, 14}, 5 },
  { {ErrorCode_names + 11083, 25}, 165 },
  { {ErrorCode_names + 11108, 17}, 623 },
  { {ErrorCode_names + 11125, 18}, 624 },
  { {ErrorCode_names + 11143, 22}, 626 },
  { {ErrorCode_names + 11165, 22}, 953 },
  { {ErrorCode_names + 11187, 15}, 898 },
  { {ErrorCode_names + 11202, 20}, 725 },
  { {ErrorCode_names + 11222, 12}, 584 },
  { {ErrorCode_names + 11234, 15}, 876 },
  { {ErrorCode_names + 11249, 25}, 760 },
  { {ErrorCode_names + 11274, 15}, 187 },
  { {ErrorCode_names + 11289, 27}, 979 },
  { {ErrorCode_names + 11316, 26}, 980 },
  { {ErrorCode_names + 11342, 18}, 976 },
  { {ErrorCode_names + 11360, 30}, 978 },
  { {ErrorCode_names + 11390, 19}, 975 },
  { {ErrorCode_names + 11409, 22}, 973 },
  { {ErrorCode_names + 11431, 23}, 974 },
  { {ErrorCode_names + 11454, 26}, 977 },
  { {ErrorCode_names + 11480, 19}, 249 },
  { {ErrorCode_names + 11499, 17}, 964 },
  { {ErrorCode_names + 11516, 25}, 167 },
  { {ErrorCode_names + 11541, 22}, 680 },
  { {ErrorCode_names + 11563, 25}, 878 },
  { {ErrorCode_names + 11588, 24}, 881 },
  { {ErrorCode_names + 11612, 17}, 884 },
  { {ErrorCode_names + 11629, 22}, 885 },
  { {ErrorCode_names + 11651, 20}, 877 },
  { {ErrorCode_names + 11671, 24}, 882 },
  { {ErrorCode_names + 11695, 16}, 883 },
  { {ErrorCode_names + 11711, 23}, 580 },
  { {ErrorCode_names + 11734, 24}, 678 },
  { {ErrorCode_names + 11758, 31}, 661 },
  { {ErrorCode_names + 11789, 23}, 660 },
  { {ErrorCode_names + 11812, 21}, 654 },
  { {ErrorCode_names + 11833, 23}, 657 },
  { {ErrorCode_names + 11856, 30}, 651 },
  { {ErrorCode_names + 11886, 26}, 674 },
  { {ErrorCode_names + 11912, 28}, 685 },
  { {ErrorCode_names + 11940, 25}, 659 },
  { {ErrorCode_names + 11965, 27}, 662 },
  { {ErrorCode_names + 11992, 29}, 653 },
  { {ErrorCode_names + 12021, 28}, 652 },
  { {ErrorCode_names + 12049, 22}, 658 },
  { {ErrorCode_names + 12071, 23}, 650 },
  { {ErrorCode_names + 12094, 24}, 675 },
  { {ErrorCode_names + 12118, 25}, 676 },
  { {ErrorCode_names + 12143, 18}, 2 },
  { {ErrorCode_names + 12161, 19}, 260 },
  { {ErrorCode_names + 12180, 17}, 602 },
  { {ErrorCode_names + 12197, 15}, 269 },
  { {ErrorCode_names + 12212, 17}, 258 },
  { {ErrorCode_names + 12229, 23}, 261 },
  { {ErrorCode_names + 12252, 22}, 259 },
  { {ErrorCode_names + 12274, 14}, 174 },
  { {ErrorCode_names + 12288, 15}, 198 },
  { {ErrorCode_names + 12303, 20}, 782 },
  { {ErrorCode_names + 12323, 15}, 796 },
  { {ErrorCode_names + 12338, 21}, 765 },
  { {ErrorCode_names + 12359, 19}, 8 },
  { {ErrorCode_names + 12378, 14}, 19 },
  { {ErrorCode_names + 12392, 17}, 20 },
  { {ErrorCode_names + 12409, 18}, 21 },
  { {ErrorCode_names + 12427, 21}, 219 },
  { {ErrorCode_names + 12448, 18}, 255 },
  { {ErrorCode_names + 12466, 21}, 500 },
  { {ErrorCode_names + 12487, 20}, 230 },
  { {ErrorCode_names + 12507, 23}, 502 },
  { {ErrorCode_names + 12530, 18}, 503 },
  { {ErrorCode_names + 12548, 15}, 505 },
  { {ErrorCode_names + 12563, 14}, 501 },
  { {ErrorCode_names + 12577, 15}, 504 },
  { {ErrorCode_names + 12592, 20}, 524 },
  { {ErrorCode_names + 12612, 21}, 229 },
  { {ErrorCode_names + 12633, 21}, 1003 },
  { {ErrorCode_names + 12654, 26}, 766 },
  { {ErrorCode_names + 12680, 19}, 212 },
  { {ErrorCode_names + 12699, 18}, 696 },
  { {ErrorCode_names + 12717, 22}, 207 },
  { {ErrorCode_names + 12739, 23}, 74 },
  { {ErrorCode_names + 12762, 24}, 73 },
  { {ErrorCode_names + 12786, 11}, 3 },
  { {ErrorCode_names + 12797, 17}, 863 },
  { {ErrorCode_names + 12814, 18}, 723 },
  { {ErrorCode_names + 12832, 19}, 568 },
  { {ErrorCode_names + 12851, 13}, 571 },
  { {ErrorCode_names + 12864, 21}, 797 },
  { {ErrorCode_names + 12885, 16}, 569 },
  { {ErrorCode_names + 12901, 21}, 592 },
  { {ErrorCode_names + 12922, 17}, 591 },
  { {ErrorCode_names + 12939, 20}, 695 },
  { {ErrorCode_names + 12959, 16}, 570 },
  { {ErrorCode_names + 12975, 15}, 567 },
  { {ErrorCode_names + 12990, 23}, 605 },
  { {ErrorCode_names + 13013, 20}, 288 },
  { {ErrorCode_names + 13033, 17}, 228 },
  { {ErrorCode_names + 13050, 21}, 289 },
  { {ErrorCode_names + 13071, 16}, 139 },
  { {ErrorCode_names + 13087, 19}, 140 },
  { {ErrorCode_names + 13106, 16}, 138 },
  { {ErrorCode_names + 13122, 24}, 879 },
  { {ErrorCode_names + 13146, 15}, 564 },
  { {ErrorCode_names + 13161, 17}, 211 },
  { {ErrorCode_names + 13178, 19}, 148 },
  { {ErrorCode_names + 13197, 18}, 70 },
  { {ErrorCode_names + 13215, 18}, 35 },
  { {ErrorCode_names + 13233, 26}, 38 },
  { {ErrorCode_names + 13259, 23}, 122 },
  { {ErrorCode_names + 13282, 22}, 164 },
  { {ErrorCode_names + 13304, 19}, 36 },
  { {ErrorCode_names + 13323, 23}, 191 },
  { {ErrorCode_names + 13346, 17}, 585 },
  { {ErrorCode_names + 13363, 19}, 67 },
  { {ErrorCode_names + 13382, 24}, 37 },
  { {ErrorCode_names + 13406, 18}, 848 },
  { {ErrorCode_names + 13424, 21}, 679 },
  { {ErrorCode_names + 13445, 19}, 899 },
  { {ErrorCode_names + 13464, 19}, 103 },
  { {ErrorCode_names + 13483, 19}, 238 },
  { {ErrorCode_names + 13502, 19}, 82 },
  { {ErrorCode_names + 13521, 24}, 83 },
  { {ErrorCode_names + 13545, 19}, 240 },
  { {ErrorCode_names + 13564, 16}, 242 },
  { {ErrorCode_names + 13580, 21}, 61 },
  { {ErrorCode_names + 13601, 18}, 62 },
  { {ErrorCode_names + 13619, 19}, 80 },
  { {ErrorCode_names + 13638, 18}, 127 },
  { {ErrorCode_names + 13656, 16}, 239 },
  { {ErrorCode_names + 13672, 17}, 81 },
  { {ErrorCode_names + 13689, 18}, 236 },
  { {ErrorCode_names + 13707, 17}, 237 },
  { {ErrorCode_names + 13724, 23}, 846 },
  { {ErrorCode_names + 13747, 21}, 13 },
  { {ErrorCode_names + 13768, 26}, 137 },
  { {ErrorCode_names + 13794, 17}, 15 },
  { {ErrorCode_names + 13811, 18}, 14 },
  { {ErrorCode_names + 13829, 18}, 71 },
  { {ErrorCode_names + 13847, 25}, 716 },
  { {ErrorCode_names + 13872, 23}, 77 },
  { {ErrorCode_names + 13895, 19}, 176 },
  { {ErrorCode_names + 13914, 15}, 18 },
  { {ErrorCode_names + 13929, 23}, 532 },
  { {ErrorCode_names + 13952, 26}, 76 },
  { {ErrorCode_names + 13978, 19}, 554 },
  { {ErrorCode_names + 13997, 14}, 566 },
  { {ErrorCode_names + 14011, 20}, 521 },
  { {ErrorCode_names + 14031, 24}, 555 },
  { {ErrorCode_names + 14055, 23}, 798 },
  { {ErrorCode_names + 14078, 24}, 785 },
  { {ErrorCode_names + 14102, 27}, 792 },
  { {ErrorCode_names + 14129, 19}, 786 },
  { {ErrorCode_names + 14148, 28}, 789 },
  { {ErrorCode_names + 14176, 27}, 787 },
  { {ErrorCode_names + 14203, 23}, 784 },
  { {ErrorCode_names + 14226, 22}, 791 },
  { {ErrorCode_names + 14248, 21}, 788 },
  { {ErrorCode_names + 14269, 25}, 799 },
  { {ErrorCode_names + 14294, 29}, 790 },
  { {ErrorCode_names + 14323, 23}, 173 },
  { {ErrorCode_names + 14346, 23}, 172 },
  { {ErrorCode_names + 14369, 20}, 171 },
  { {ErrorCode_names + 14389, 19}, 853 },
  { {ErrorCode_names + 14408, 20}, 152 },
  { {ErrorCode_names + 14428, 22}, 166 },
  { {ErrorCode_names + 14450, 25}, 153 },
  { {ErrorCode_names + 14475, 18}, 739 },
  { {ErrorCode_names + 14493, 18}, 294 },
  { {ErrorCode_names + 14511, 22}, 535 },
  { {ErrorCode_names + 14533, 30}, 537 },
  { {ErrorCode_names + 14563, 22}, 843 },
  { {ErrorCode_names + 14585, 27}, 536 },
  { {ErrorCode_names + 14612, 24}, 538 },
  { {ErrorCode_names + 14636, 23}, 534 },
  { {ErrorCode_names + 14659, 32}, 533 },
  { {ErrorCode_names + 14691, 26}, 285 },
  { {ErrorCode_names + 14717, 27}, 547 },
  { {ErrorCode_names + 14744, 27}, 287 },
  { {ErrorCode_names + 14771, 27}, 283 },
  { {ErrorCode_names + 14798, 20}, 740 },
  { {ErrorCode_names + 14818, 32}, 548 },
  { {ErrorCode_names + 14850, 31}, 282 },
  { {ErrorCode_names + 14881, 31}, 281 },
  { {ErrorCode_names + 14912, 29}, 280 },
  { {ErrorCode_names + 14941, 36}, 549 },
  { {ErrorCode_names + 14977, 23}, 286 },
  { {ErrorCode_names + 15000, 27}, 293 },
  { {ErrorCode_names + 15027, 19}, 279 },
  { {ErrorCode_names + 15046, 29}, 284 },
  { {ErrorCode_names + 15075, 18}, 278 },
  { {ErrorCode_names + 15093, 21}, 947 },
  { {ErrorCode_names + 15114, 19}, 747 },
  { {ErrorCode_names + 15133, 30}, 748 },
  { {ErrorCode_names + 15163, 26}, 745 },
  { {ErrorCode_names + 15189, 25}, 746 },
  { {ErrorCode_names + 15214, 20}, 744 },
  { {ErrorCode_names + 15234, 27}, 754 },
  { {ErrorCode_names + 15261, 20}, 618 },
  { {ErrorCode_names + 15281, 15}, 7 },
  { {ErrorCode_names + 15296, 11}, 0 },
  { {ErrorCode_names + 15307, 24}, 60 },
  { {ErrorCode_names + 15331, 25}, 232 },
  { {ErrorCode_names + 15356, 21}, 233 },
  { {ErrorCode_names + 15377, 15}, 621 },
  { {ErrorCode_names + 15392, 22}, 597 },
  { {ErrorCode_names + 15414, 23}, 596 },
  { {ErrorCode_names + 15437, 21}, 511 },
  { {ErrorCode_names + 15458, 24}, 601 },
  { {ErrorCode_names + 15482, 22}, 606 },
  { {ErrorCode_names + 15504, 20}, 595 },
  { {ErrorCode_names + 15524, 23}, 603 },
  { {ErrorCode_names + 15547, 19}, 510 },
  { {ErrorCode_names + 15566, 19}, 513 },
  { {ErrorCode_names + 15585, 18}, 512 },
  { {ErrorCode_names + 15603, 22}, 970 },
  { {ErrorCode_names + 15625, 19}, 600 },
  { {ErrorCode_names + 15644, 23}, 594 },
  { {ErrorCode_names + 15667, 25}, 967 },
  { {ErrorCode_names + 15692, 17}, 514 },
  { {ErrorCode_names + 15709, 21}, 193 },
  { {ErrorCode_names + 15730, 24}, 194 },
  { {ErrorCode_names + 15754, 27}, 253 },
  { {ErrorCode_names + 15781, 20}, 612 },
  { {ErrorCode_names + 15801, 19}, 613 },
  { {ErrorCode_names + 15820, 21}, 617 },
  { {ErrorCode_names + 15841, 28}, 525 },
  { {ErrorCode_names + 15869, 23}, 63 },
  { {ErrorCode_names + 15892, 22}, 837 },
  { {ErrorCode_names + 15914, 28}, 1014 },
  { {ErrorCode_names + 15942, 20}, 864 },
  { {ErrorCode_names + 15962, 17}, 865 },
  { {ErrorCode_names + 15979, 30}, 1013 },
  { {ErrorCode_names + 16009, 27}, 894 },
  { {ErrorCode_names + 16036, 24}, 145 },
  { {ErrorCode_names + 16060, 31}, 68 },
  { {ErrorCode_names + 16091, 28}, 129 },
  { {ErrorCode_names + 16119, 23}, 948 },
  { {ErrorCode_names + 16142, 13}, 65 },
  { {ErrorCode_names + 16155, 25}, 250 },
  { {ErrorCode_names + 16180, 23}, 130 },
  { {ErrorCode_names + 16203, 13}, 526 },
  { {ErrorCode_names + 16216, 33}, 160 },
  { {ErrorCode_names + 16249, 22}, 593 },
  { {ErrorCode_names + 16271, 19}, 565 },
  { {ErrorCode_names + 16290, 20}, 858 },
  { {ErrorCode_names + 16310, 18}, 157 },
  { {ErrorCode_names + 16328, 25}, 268 },
  { {ErrorCode_names + 16353, 22}, 69 },
  { {ErrorCode_names + 16375, 17}, 147 },
  { {ErrorCode_names + 16392, 25}, 136 },
  { {ErrorCode_names + 16417, 26}, 144 },
  { {ErrorCode_names + 16443, 22}, 619 },
  { {ErrorCode_names + 16465, 30}, 134 },
  { {ErrorCode_names + 16495, 22}, 131 },
  { {ErrorCode_names + 16517, 23}, 206 },
  { {ErrorCode_names + 16540, 18}, 64 },
  { {ErrorCode_names + 16558, 20}, 156 },
  { {ErrorCode_names + 16578, 21}, 133 },
  { {ErrorCode_names + 16599, 17}, 304 },
  { {ErrorCode_names + 16616, 27}, 149 },
  { {ErrorCode_names + 16643, 29}, 135 },
  { {ErrorCode_names + 16672, 36}, 146 },
  { {ErrorCode_names + 16708, 17}, 614 },
  { {ErrorCode_names + 16725, 18}, 251 },
  { {ErrorCode_names + 16743, 25}, 949 },
  { {ErrorCode_names + 16768, 25}, 699 },
  { {ErrorCode_names + 16793, 20}, 159 },
  { {ErrorCode_names + 16813, 22}, 772 },
  { {ErrorCode_names + 16835, 20}, 770 },
  { {ErrorCode_names + 16855, 20}, 773 },
  { {ErrorCode_names + 16875, 23}, 201 },
  { {ErrorCode_names + 16898, 30}, 771 },
  { {ErrorCode_names + 16928, 13}, 158 },
  { {ErrorCode_names + 16941, 22}, 656 },
  { {ErrorCode_names + 16963, 23}, 66 },
  { {ErrorCode_names + 16986, 11}, 12 },
  { {ErrorCode_names + 16997, 18}, 264 },
  { {ErrorCode_names + 17015, 13}, 263 },
  { {ErrorCode_names + 17028, 18}, 265 },
  { {ErrorCode_names + 17046, 25}, 246 },
  { {ErrorCode_names + 17071, 17}, 245 },
  { {ErrorCode_names + 17088, 31}, 795 },
  { {ErrorCode_names + 17119, 22}, 178 },
  { {ErrorCode_names + 17141, 23}, 960 },
  { {ErrorCode_names + 17164, 14}, 958 },
  { {ErrorCode_names + 17178, 23}, 959 },
  { {ErrorCode_names + 17201, 17}, 957 },
  { {ErrorCode_names + 17218, 23}, 962 },
  { {ErrorCode_names + 17241, 22}, 961 },
  { {ErrorCode_names + 17263, 25}, 177 },
  { {ErrorCode_names + 17288, 11}, 1 },
  { {ErrorCode_names + 17299, 19}, 1002 },
  { {ErrorCode_names + 17318, 10}, 905 },
  { {ErrorCode_names + 17328, 18}, 196 },
  { {ErrorCode_names + 17346, 20}, 244 },
  { {ErrorCode_names + 17366, 20}, 243 },
  { {ErrorCode_names + 17386, 14}, 248 },
  { {ErrorCode_names + 17400, 26}, 938 },
  { {ErrorCode_names + 17426, 28}, 939 },
  { {ErrorCode_names + 17454, 25}, 933 },
  { {ErrorCode_names + 17479, 26}, 926 },
  { {ErrorCode_names + 17505, 26}, 911 },
  { {ErrorCode_names + 17531, 26}, 945 },
  { {ErrorCode_names + 17557, 27}, 927 },
  { {ErrorCode_names + 17584, 24}, 918 },
  { {ErrorCode_names + 17608, 25}, 919 },
  { {ErrorCode_names + 17633, 26}, 955 },
  { {ErrorCode_names + 17659, 22}, 929 },
  { {ErrorCode_names + 17681, 29}, 946 },
  { {ErrorCode_names + 17710, 21}, 913 },
  { {ErrorCode_names + 17731, 22}, 910 },
  { {ErrorCode_names + 17753, 22}, 912 },
  { {ErrorCode_names + 17775, 21}, 920 },
  { {ErrorCode_names + 17796, 23}, 930 },
  { {ErrorCode_names + 17819, 19}, 917 },
  { {ErrorCode_names + 17838, 15}, 200 },
  { {ErrorCode_names + 17853, 29}, 779 },
  { {ErrorCode_names + 17882, 26}, 780 },
  { {ErrorCode_names + 17908, 18}, 72 },
  { {ErrorCode_names + 17926, 29}, 226 },
  { {ErrorCode_names + 17955, 29}, 225 },
};

static const int ErrorCode_entries_by_number[] = {
  688, // 0 -> ERR_SUCCESS
  779, // 1 -> ERR_UNKNOWN
  537, // 2 -> ERR_PASSWORD_ERROR
  571, // 3 -> ERR_RELOGIN
  5, // 4 -> ERR_ACCOUNT_NOT_EXIST
  489, // 5 -> ERR_NAME_EXIST
  392, // 6 -> ERR_INVALID_NAME
  687, // 7 -> ERR_STATE_ERROR
  549, // 8 -> ERR_PROFESSION_TYPE
  220, // 9 -> ERR_FAILED
  7, // 10 -> ERR_ACCOUNT_ROLE_FULL
  3, // 11 -> ERR_ACCOUNT_DATA_ERROR
  764, // 12 -> ERR_TIMEOUT
  622, // 13 -> ERR_SKILL_CONFIGERROR
  625, // 14 -> ERR_SKILL_LEVELREQ
  624, // 15 -> ERR_SKILL_ITEMREQ
  8, // 16 -> ERR_ACHIVE_NOTCOMPLETE
  9, // 17 -> ERR_ACHIVE_NOTCONFIG
  630, // 18 -> ERR_SKILL_POINT
  550, // 19 -> ERR_PROF_ERROR
  551, // 20 -> ERR_PROF_LEVELREQ
  552, // 21 -> ERR_PROF_LEVELREQ2
  87, // 22 -> ERR_BIND_SKILL_OUTRANGE
  86, // 23 -> ERR_BIND_SKILL_NOT_LEARN
  85, // 24 -> ERR_BIND_SKILL_MISSSLOT
  205, // 25 -> ERR_ENHANCE_ERROR
  207, // 26 -> ERR_ENHANCE_LACKITEM
  206, // 27 -> ERR_ENHANCE_FAILED
  210, // 28 -> ERR_ENHANCE_SUCCEED
  208, // 29 -> ERR_ENHANCE_MAX
  29, // 30 -> ERR_ARENA_ERROR
  28, // 31 -> ERR_ARENA_COUNTLIMIT
  169, // 32 -> ERR_DECOMPOSE_FAILED
  168, // 33 -> ERR_DECOMPOSE_CANNOT
  170, // 34 -> ERR_DECOMPOSE_NOTFIND
  595, // 35 -> ERR_SCENE_LEVELREQ
  599, // 36 -> ERR_SCENE_NOFATIGUE
  603, // 37 -> ERR_SCENE_TODYCOUNTLIMIT
  596, // 38 -> ERR_SCENE_NEEDPREVCOMPLETE
  411, // 39 -> ERR_ITEM_NOTEXIST
  408, // 40 -> ERR_ITEM_LEVELLIMIT
  406, // 41 -> ERR_ITEM_CANNOTBEEQUIPED
  195, // 42 -> ERR_EMBLEM_NOEMPTYSLOT
  412, // 43 -> ERR_ITEM_NOT_ENOUGH
  194, // 44 -> ERR_EMBLEM_MAXLEVEL
  420, // 45 -> ERR_JADE_MAXLEVEL
  416, // 46 -> ERR_JADECOMPOSE_NOTFIND
  415, // 47 -> ERR_JADEATTACH_NOEMPTYSLOT
  417, // 48 -> ERR_JADE_COUNTNOTENOUGH
  124, // 49 -> ERR_CHECKIN_FULL
  125, // 50 -> ERR_CHECKIN_LACKDRAGONCOIN
  12, // 51 -> ERR_ACTIVITY_NOCHESTINDEX
  11, // 52 -> ERR_ACTIVITY_HASGETCHEST
  13, // 53 -> ERR_ACTIVITY_NOTENOUGHVALUE
  14, // 54 -> ERR_ACTIVITY_SPECIALCHESTCOUNTLIMIT
  27, // 55 -> ERR_ARENA_ADDCOUNTLACKCOIN
  423, // 56 -> ERR_JADE_OPENJADELACKCOIN
  422, // 57 -> ERR_JADE_NOEMPTYSLOT
  410, // 58 -> ERR_ITEM_NEED_DRAGONCOIN
  95, // 59 -> ERR_BUY_LIMIT
  689, // 60 -> ERR_SWEEP_NOT_THREE_STAR
  613, // 61 -> ERR_SHOP_ITEMNOTEXIST
  614, // 62 -> ERR_SHOP_LACKMONEY
  715, // 63 -> ERR_TEAM_ALREADY_INTEAM
  744, // 64 -> ERR_TEAM_NOT_EXIST
  726, // 65 -> ERR_TEAM_FULL
  763, // 66 -> ERR_TEAM_WRONG_PASSWORD
  602, // 67 -> ERR_SCENE_TIMELIMIT
  723, // 68 -> ERR_TEAM_EXPEDITIONID_NOT_EXIST
  736, // 69 -> ERR_TEAM_LEVEL_REQUARE
  594, // 70 -> ERR_SCENE_COOLDOWN
  626, // 71 -> ERR_SKILL_MAXLEVEL
  807, // 72 -> ERR_WORLDBOSS_DEAD
  570, // 73 -> ERR_REINFORCE_LEVELLIMIT
  569, // 74 -> ERR_REINFORCE_LACKMONEY
  30, // 75 -> ERR_ARENA_REWARDTAKEN
  632, // 76 -> ERR_SKILL_PROFESSION_ERROR
  628, // 77 -> ERR_SKILL_NEED_PRESKILL
  456, // 78 -> ERR_LOGIN_TIMEOUT
  454, // 79 -> ERR_LOGIN_NOSERVER
  615, // 80 -> ERR_SHOP_LEVELLIMIT
  618, // 81 -> ERR_SHOP_PPTLIMIT
  609, // 82 -> ERR_SHOP_COUNTLIMIT
  610, // 83 -> ERR_SHOP_DAILYCOUNTLIMIT
  121, // 84 -> ERR_CHAT_LEVELLIMIT
  120, // 85 -> ERR_CHAT_LENGTHLIMIT
  123, // 86 -> ERR_CHAT_TIMELIMIT
  233, // 87 -> ERR_FASHOIN_ALREADY_EXIST
  231, // 88 -> ERR_FASHION_NOT_EXIST
  248, // 89 -> ERR_FRIEND_MAX
  251, // 90 -> ERR_FRIEND_REPEATED
  250, // 91 -> ERR_FRIEND_NOTEXIST
  90, // 92 -> ERR_BLACK_INSELF
  89, // 93 -> ERR_BLACK_INOTHER
  92, // 94 -> ERR_BLACK_NOTEXIST
  457, // 95 -> ERR_LOGIN_VERIFY_FAILED
  355, // 96 -> ERR_GUILD_NOT_EXIST
  350, // 97 -> ERR_GUILD_NAME_EXIST
  356, // 98 -> ERR_GUILD_NOT_IN_GUILD
  330, // 99 -> ERR_GUILD_ALREADY_IN_GUILD
  357, // 100 -> ERR_GUILD_NO_PERMISSION
  116, // 101 -> ERR_CHAPTERCHEST_ALREADY_FETCHED
  117, // 102 -> ERR_CHAPTERCHEST_NEEDSTAR
  607, // 103 -> ERR_SESSION_KICKOFF
  17, // 104 -> ERR_ALIVE_TIMEOUT
  298, // 105 -> ERR_GS_CLOSED
  222, // 106 -> ERR_FASHIONCOMPOSE_LEVEL_REQ
  336, // 107 -> ERR_GUILD_FULL
  360, // 108 -> ERR_GUILD_PPT_REQ
  362, // 109 -> ERR_GUILD_WAITAPPROVAL
  349, // 110 -> ERR_GUILD_MEMBER_NOT_EXIST
  240, // 111 -> ERR_FLOWER_SELF
  238, // 112 -> ERR_FLOWER_COUNTLIMIT
  239, // 113 -> ERR_FLOWER_ROLELIMIT
  237, // 114 -> ERR_FLOWER_COSTLIMIT
  317, // 115 -> ERR_GUILDCARD_ALLCOUNTLIMIT
  319, // 116 -> ERR_GUILDCARD_COUNTLIMIT
  318, // 117 -> ERR_GUILDCARD_CHANGELIMIT
  322, // 118 -> ERR_GUILDCHECKIN_LIMIT
  323, // 119 -> ERR_GUILDCHECKIN_MONEY
  324, // 120 -> ERR_GUILDCHECKIN_TAKEN
  321, // 121 -> ERR_GUILDCHECKIN_BOXLIMIT
  597, // 122 -> ERR_SCENE_NEED_PRESCENE
  309, // 123 -> ERR_GUILDBONUS_NOTEXIST
  306, // 124 -> ERR_GUILDBONUS_ALREADYGET
  307, // 125 -> ERR_GUILDBONUS_EXCEED
  359, // 126 -> ERR_GUILD_OPENLIMIT
  616, // 127 -> ERR_SHOP_OPENLIMIT
  320, // 128 -> ERR_GUILDCHECKIN_ALLCOUNT
  724, // 129 -> ERR_TEAM_EXPEDITION_DAYCOUNT
  728, // 130 -> ERR_TEAM_GUILD_DAYCOUNT
  742, // 131 -> ERR_TEAM_NEST_DAYCOUNT
  346, // 132 -> ERR_GUILD_LEVEL_REQ
  746, // 133 -> ERR_TEAM_NOT_OPENTIME
  741, // 134 -> ERR_TEAM_NEED_ATLEAST_2_MEMBER
  749, // 135 -> ERR_TEAM_ONLY_LEADER_CAN_KICK
  738, // 136 -> ERR_TEAM_MEMBER_NOT_EXIST
  623, // 137 -> ERR_SKILL_GUILD_CONTRIBUTE
  589, // 138 -> ERR_REWARD_TAKEN
  587, // 139 -> ERR_REWARD_LIMIT
  588, // 140 -> ERR_REWARD_NOTEXIST
  361, // 141 -> ERR_GUILD_VICE_FULL
  358, // 142 -> ERR_GUILD_OFFICER_FULL
  334, // 143 -> ERR_GUILD_ELITE_FULL
  739, // 144 -> ERR_TEAM_MEMBER_NOT_ONLINE
  722, // 145 -> ERR_TEAM_DISAGREE_BATTLE
  750, // 146 -> ERR_TEAM_ONLY_LEADER_CAN_STARTBATTLE
  737, // 147 -> ERR_TEAM_MATCHING
  593, // 148 -> ERR_ROLE_NOT_ONLINE
  748, // 149 -> ERR_TEAM_ONLY_LEADER_CAN_DO
  428, // 150 -> ERR_LACKCOIN
  429, // 151 -> ERR_LACKDIAMOND
  652, // 152 -> ERR_SMELTING_INVALID
  654, // 153 -> ERR_SMELTING_TRANSINVALID
  353, // 154 -> ERR_GUILD_NAME_TOO_SHORT
  352, // 155 -> ERR_GUILD_NAME_TOO_LONG
  745, // 156 -> ERR_TEAM_NOT_IN_HALL
  734, // 157 -> ERR_TEAM_IN_BATTLE
  761, // 158 -> ERR_TEAM_VOTE
  755, // 159 -> ERR_TEAM_STATE_ERROR
  730, // 160 -> ERR_TEAM_INVITE_ROLE_IS_IN_BATTLE
  407, // 161 -> ERR_ITEM_COOLDOWN
  452, // 162 -> ERR_LOGIN_FORBID
  453, // 163 -> ERR_LOGIN_MAXNUM
  598, // 164 -> ERR_SCENE_NEED_PRETASK
  490, // 165 -> ERR_NAME_HAS_INVALID_CHAR
  653, // 166 -> ERR_SMELTING_LACKMONEY
  511, // 167 -> ERR_OTHER_GAOJIGU_NOTOPEN
  235, // 168 -> ERR_FISHING_NUMNOTENOUGH
  234, // 169 -> ERR_FISHING_ALREADYSEAT
  236, // 170 -> ERR_FISHING_SEATNOTEMPTY
  650, // 171 -> ERR_SLOTATTR_NOEQUIP
  649, // 172 -> ERR_SLOTATTR_MONEYLIMIT
  648, // 173 -> ERR_SLOTATTR_LEVELLIMIT
  544, // 174 -> ERR_PK_NOMATCH
  414, // 175 -> ERR_ITEM_WRONG_PROFESSION
  629, // 176 -> ERR_SKILL_NOT_MATCH
  778, // 177 -> ERR_TSHOW_LEVEL_NOTENOUGH
  771, // 178 -> ERR_TRANSFER_LACKMONEY
  49, // 179 -> ERR_AUCT_HAVEBIDDING
  50, // 180 -> ERR_AUCT_ITEMOUTSALE
  56, // 181 -> ERR_AUCT_PRICECHAGE
  59, // 182 -> ERR_AUCT_SURPASSSELF
  55, // 183 -> ERR_AUCT_POINTLESS
  48, // 184 -> ERR_AUCT_DRAGONCOINLESS
  46, // 185 -> ERR_AUCT_BUYSELF
  20, // 186 -> ERR_ALREADY_IN_CAMP
  500, // 187 -> ERR_NOT_IN_CAMP
  54, // 188 -> ERR_AUCT_ONSALEMAX
  47, // 189 -> ERR_AUCT_COMMONERR
  51, // 190 -> ERR_AUCT_ITEMSALED
  600, // 191 -> ERR_SCENE_NOT_IN_CONFIG
  258, // 192 -> ERR_GAOJIGU_MODEL_DUPLICATE_FASHIONID
  708, // 193 -> ERR_TEAMBUY_COUNT_MAX
  709, // 194 -> ERR_TEAMBUY_DIAMOND_LESS
  16, // 195 -> ERR_ADDFRIEND_DUMMYROLE
  782, // 196 -> ERR_VERSION_FAILED
  217, // 197 -> ERR_EXPBACK_ALREADYGET
  545, // 198 -> ERR_PK_OPENTIME
  409, // 199 -> ERR_ITEM_NEED_DIAMOND
  804, // 200 -> ERR_WORD_FORBID
  759, // 201 -> ERR_TEAM_TOWER_DAYCOUNT
  43, // 202 -> ERR_AUCTGOLDLESS
  389, // 203 -> ERR_ILLEGAL_CODE
  333, // 204 -> ERR_GUILD_CHECKINBONUS_TIMEERROR
  332, // 205 -> ERR_GUILD_CHECKINBONUS_ASKTOOMUCH
  743, // 206 -> ERR_TEAM_NOJOININBATTLE
  568, // 207 -> ERR_REGISTER_NUM_LIMIT
  249, // 208 -> ERR_FRIEND_MAXOTHER
  253, // 209 -> ERR_FRIEND_SENDLIMIT
  254, // 210 -> ERR_FRIEND_TAKENLIMIT
  592, // 211 -> ERR_ROLE_NOTEXIST
  566, // 212 -> ERR_RANDOMFRIEND_CD
  211, // 213 -> ERR_ENHANCE_TRANSLEVEL
  212, // 214 -> ERR_ENHANCE_TRANSPOS
  348, // 215 -> ERR_GUILD_LVL_LIMIT
  246, // 216 -> ERR_FRIEND_HASSEND
  331, // 217 -> ERR_GUILD_APPLYFULL
  88, // 218 -> ERR_BLACK_CHAT
  553, // 219 -> ERR_PVP_ROLE_INBATTLE
  252, // 220 -> ERR_FRIEND_SELF
  91, // 221 -> ERR_BLACK_MAX
  196, // 222 -> ERR_EMBLEM_NOIDENTIFY
  197, // 223 -> ERR_EMBLEM_NOTHIRDSLOT
  193, // 224 -> ERR_EMBLEM_CANTIDENTIFY
  809, // 225 -> GUILD_SKILL_STUDY_LEVEL_LIMIT
  808, // 226 -> GUILD_SKILL_GUILD_LEVEL_LIMIT
  335, // 227 -> ERR_GUILD_EXP_LIMIT
  585, // 228 -> ERR_REVIVE_MAXNUM
  563, // 229 -> ERR_QA_OVER_NAME_TIME
  556, // 230 -> ERR_QA_IN_OTHER_TYPE
  421, // 231 -> ERR_JADE_MINEQUIPLEVEL
  690, // 232 -> ERR_SWEEP_POWERPOINT_LESS
  691, // 233 -> ERR_SWEEP_TICKET_LESS
  4, // 234 -> ERR_ACCOUNT_INVALID
  426, // 235 -> ERR_JADE_WRONGTYPE
  619, // 236 -> ERR_SHOP_TIMELIMIT
  620, // 237 -> ERR_SHOP_VIPLIMIT
  608, // 238 -> ERR_SHOP_ARENALIMIT
  617, // 239 -> ERR_SHOP_PKLIMIT
  611, // 240 -> ERR_SHOP_GUILDLIMIT
  62, // 241 -> ERR_AUDIO_NOT_EXIST
  612, // 242 -> ERR_SHOP_INVALID
  784, // 243 -> ERR_WATCH_LIVEISOVER
  783, // 244 -> ERR_WATCH_LIVEISFULL
  769, // 245 -> ERR_TOWER_INSWEEP
  768, // 246 -> ERR_TOWER_FLOOR_NOTENOUGH
  192, // 247 -> ERR_DRAGON_TICKET_NOTENOUGH
  785, // 248 -> ERR_WATCH_WAIT
  509, // 249 -> ERR_OP_EXP_NOT_OPEN
  727, // 250 -> ERR_TEAM_GODDESS_DAYCOUNT
  752, // 251 -> ERR_TEAM_SEAL_TYPE
  191, // 252 -> ERR_DRAGON_PROGRESS_INVALID
  710, // 253 -> ERR_TEAMBUY_DRAGONCOIN_LESS
  424, // 254 -> ERR_JADE_REPLACE
  554, // 255 -> ERR_PVP_TEAM_MATCH
  299, // 256 -> ERR_GS_UNREADY
  394, // 257 -> ERR_INVALID_REQUEST
  541, // 258 -> ERR_PET_NOT_EXIST
  543, // 259 -> ERR_PE_CAN_NOT_RELEASE
  538, // 260 -> ERR_PETSYS_NOT_OPEN
  542, // 261 -> ERR_PET_SEAT_NOT_ENOUGH
  6, // 262 -> ERR_ACCOUNT_QUEUING
  766, // 263 -> ERR_TITLE_MAX
  765, // 264 -> ERR_TITLE_LACKITEM
  767, // 265 -> ERR_TITLE_PPTLIMIT
  93, // 266 -> ERR_BLACK_REPEATED
  94, // 267 -> ERR_BLACK_SELF
  735, // 268 -> ERR_TEAM_LEADER_NOTHELPER
  540, // 269 -> ERR_PET_IS_FULL
  385, // 270 -> ERR_IBSHOP_LACKGOODS
  386, // 271 -> ERR_IBSHOP_LIMITCOUNT
  383, // 272 -> ERR_IBSHOP_LACKDIAMOND
  384, // 273 -> ERR_IBSHOP_LACKDRAGON
  122, // 274 -> ERR_CHAT_PUNISH
  451, // 275 -> ERR_LOCKED_ROLE
  382, // 276 -> ERR_IBSHOP_ERRPARAM
  381, // 277 -> ERR_IBSHOP_BUYLV
  678, // 278 -> ERR_SPRITE_NOTFIND
  676, // 279 -> ERR_SPRITE_LEVELMAX
  672, // 280 -> ERR_SPRITE_EVOLUTION_LEVELMAX
  671, // 281 -> ERR_SPRITE_EVOLUTION_LEVELLIMIT
  670, // 282 -> ERR_SPRITE_EVOLUTION_LACKOFCOST
  667, // 283 -> ERR_SPRITE_AWAKE_LACKOFCOST
  677, // 284 -> ERR_SPRITE_LEVELUP_LACKOFCOST
  664, // 285 -> ERR_SPRITE_ALREADY_INFIGHT
  674, // 286 -> ERR_SPRITE_INFIGHT_FULL
  666, // 287 -> ERR_SPRITE_ALREADY_OUTFIGHT
  584, // 288 -> ERR_REVIVE_ITEMLIMIT
  586, // 289 -> ERR_REVIVE_MONEYLIMIT
  209, // 290 -> ERR_ENHANCE_NO_EQUIP_CAN_TRANSFORM
  388, // 291 -> ERR_IBSHOP_VIPLEVEL
  387, // 292 -> ERR_IBSHOP_OPENGROUP
  675, // 293 -> ERR_SPRITE_INFIGHT_SAMETYPE
  656, // 294 -> ERR_SMELT_MINLEVEL
  419, // 295 -> ERR_JADE_GOLDNOTENOUGH
  0, // 296 -> ATLAS_CARD_NOT_ENOUGH
  52, // 297 -> ERR_AUCT_ITEM_LESS
  53, // 298 -> ERR_AUCT_ITEM_LOCK
  58, // 299 -> ERR_AUCT_PRICE_NOTCHANGE
  449, // 300 -> ERR_LEVELSEAL_PROP_NOT_ENGOUTH
  45, // 301 -> ERR_AUCT_AUTOREFRESH_TIME
  42, // 302 -> ERR_ATLAS_NOT_BREAK
  455, // 303 -> ERR_LOGIN_NOT_IN_WHITE_LIST
  747, // 304 -> ERR_TEAM_NOT_PASS
  25, // 305 -> ERR_ANTI_CHEAT_DETECTED
  487, // 306 -> ERR_MS_UNREADY
  555, // 500 -> ERR_QA_ALEADY_IN_ROOM
  560, // 501 -> ERR_QA_NO_DATA
  557, // 502 -> ERR_QA_LEVEL_NOT_ENOUGH
  558, // 503 -> ERR_QA_NOT_IN_TIME
  561, // 504 -> ERR_QA_NO_GUILD
  559, // 505 -> ERR_QA_NO_COUNT
  700, // 510 -> ERR_TASK_NOT_ACCEPT
  695, // 511 -> ERR_TASK_ALREADY_TAKE
  702, // 512 -> ERR_TASK_NOT_FOUND
  701, // 513 -> ERR_TASK_NOT_FINISH
  707, // 514 -> ERR_TASK_NO_TABLE
  345, // 515 -> ERR_GUILD_LADDER_NOT_OPEN
  269, // 516 -> ERR_GARDEN_NOTEXIST_FARMLAND
  267, // 517 -> ERR_GARDEN_NOHARVESTSTATE
  276, // 518 -> ERR_GARDEN_STEALEDTIMES_EXCEED
  270, // 519 -> ERR_GARDEN_NOTEXIST_SEEDID
  271, // 520 -> ERR_GARDEN_NOTEXIST_SPRITE
  635, // 521 -> ERR_SKYCITY_NOT_OPEN
  289, // 522 -> ERR_GMF_UP_INCOOL
  288, // 523 -> ERR_GMF_UP_FULL
  562, // 524 -> ERR_QA_NO_GUILD_ROOM
  714, // 525 -> ERR_TEAM_ALREADY_INOTHERTEAM
  729, // 526 -> ERR_TEAM_IDIP
  127, // 527 -> ERR_COMMENDWATCH_COUNTLIMIT
  102, // 528 -> ERR_CARDMATCH_BEGINFAILED
  105, // 529 -> ERR_CARDMATCH_NOBEGIN
  104, // 530 -> ERR_CARDMATCH_ENDSOON
  103, // 531 -> ERR_CARDMATCH_CHANGELIMIT
  631, // 532 -> ERR_SKILL_PREPOINTLIMIT
  663, // 533 -> ERR_SPACTIVITY_TASK_NOT_COMPLETE
  662, // 534 -> ERR_SPACTIVITY_TASK_GET
  657, // 535 -> ERR_SPACTIVITY_NOPRIZE
  660, // 536 -> ERR_SPACTIVITY_NOTPRIZETIME
  658, // 537 -> ERR_SPACTIVITY_NOTENOUGH_MONEY
  661, // 538 -> ERR_SPACTIVITY_PRIZE_GET
  273, // 539 -> ERR_GARDEN_PLANT_CD
  260, // 540 -> ERR_GARDEN_COOKING_EXCEED
  259, // 541 -> ERR_GARDEN_COOKINGLEVEL_LOW
  274, // 542 -> ERR_GARDEN_PLANT_CUL_ERR
  261, // 543 -> ERR_GARDEN_ERR_SEED
  268, // 544 -> ERR_GARDEN_NOSEED
  265, // 545 -> ERR_GARDEN_NOALLOW
  286, // 546 -> ERR_GMF_NOPOWER_KICK_LEADER
  665, // 547 -> ERR_SPRITE_ALREADY_ISLEADER
  669, // 548 -> ERR_SPRITE_AWAKE_ROLE_LEVELLIMIT
  673, // 549 -> ERR_SPRITE_EVOLUTION_ROLE_LEVELLIMIT
  329, // 550 -> ERR_GUILD_ALREADY_BIND
  354, // 551 -> ERR_GUILD_NOT_BIND
  21, // 552 -> ERR_ALREADY_IN_QQGROUP
  390, // 553 -> ERR_INSPIRE_COOLDOWN
  633, // 554 -> ERR_SKYCITY_IN_TEAM
  636, // 555 -> ERR_SKYCITY_TEAM_OUTTIME
  284, // 556 -> ERR_GMF_DOWN_FIGHTING
  285, // 557 -> ERR_GMF_DOWN_HAVEFAILED
  425, // 558 -> ERR_JADE_SAME_TYPE
  119, // 559 -> ERR_CHAT_BLACK_INSELF
  118, // 560 -> ERR_CHAT_BLACK_INOTHER
  275, // 561 -> ERR_GARDEN_QUESTS_NOENOUGH
  272, // 562 -> ERR_GARDEN_NOTINGARDEN
  263, // 563 -> ERR_GARDEN_FOODBOOK_ACTIVED
  591, // 564 -> ERR_ROLE_LOGOUT
  732, // 565 -> ERR_TEAM_INV_LOGOUT
  634, // 566 -> ERR_SKYCITY_LV
  582, // 567 -> ERR_RESWAR_TEAM
  574, // 568 -> ERR_RESWAR_ACTIVITY
  577, // 569 -> ERR_RESWAR_GROUP
  581, // 570 -> ERR_RESWAR_STATE
  575, // 571 -> ERR_RESWAR_CD
  75, // 572 -> ERR_BAG_FULL
  80, // 573 -> ERR_BAG_FULL_TAKEOFF_EQUIP
  81, // 574 -> ERR_BAG_FULL_TAKEOFF_FASHION
  79, // 575 -> ERR_BAG_FULL_TAKEOFF_EMBLEM
  82, // 576 -> ERR_BAG_FULL_TAKEOFF_JADE
  77, // 577 -> ERR_BAG_FULL_GIVE_MAIL_REWARD
  57, // 578 -> ERR_AUCT_PRICE_CHANGE
  287, // 579 -> ERR_GMF_UPBATTLE_REPEAT
  520, // 580 -> ERR_PANDORA_LACKOF_FIRE
  44, // 581 -> ERR_AUCT_AUCTOVER
  290, // 582 -> ERR_GOLDCLICK_LIMIT
  190, // 583 -> ERR_DRAGONCOIN_LIMIT
  497, // 584 -> ERR_NOTGUILD
  601, // 585 -> ERR_SCENE_NOT_PET
  305, // 586 -> ERR_GUILDBONUS_ALLGET
  311, // 587 -> ERR_GUILDBUFF_GUILD
  313, // 588 -> ERR_GUILDBUFF_POS
  310, // 589 -> ERR_GUILDBUFF_CD
  312, // 590 -> ERR_GUILDBUFF_ITEM
  579, // 591 -> ERR_RESWAR_LEADER
  578, // 592 -> ERR_RESWAR_LACKPLAYER
  731, // 593 -> ERR_TEAM_INV_IN_FAMILY
  705, // 594 -> ERR_TASK_NO_ASK_HELPNUM
  698, // 595 -> ERR_TASK_CANNOT_HELP
  694, // 596 -> ERR_TASK_ALREADY_FINISH
  693, // 597 -> ERR_TASK_ALREADY_ASKED
  266, // 598 -> ERR_GARDEN_NOEXIST_FOODID
  264, // 599 -> ERR_GARDEN_FOOD_NOALLOW
  704, // 600 -> ERR_TASK_NO_ASKINFO
  696, // 601 -> ERR_TASK_ASKITEM_REFRESH
  539, // 602 -> ERR_PET_EXP_EQUAL
  699, // 603 -> ERR_TASK_CANNT_HELPSELF
  1, // 604 -> CanNotDelInGuildArena
  583, // 605 -> ERR_RESWAR_TEAMFIGHTING
  697, // 606 -> ERR_TASK_CANNOT_GIVEUP
  342, // 607 -> ERR_GUILD_INHERIT_NOT_EXIT
  339, // 608 -> ERR_GUILD_INHERIT_GAP
  340, // 609 -> ERR_GUILD_INHERIT_LVL
  344, // 610 -> ERR_GUILD_INHERIT_TIMES
  341, // 611 -> ERR_GUILD_INHERIT_MAP_WRONG
  711, // 612 -> ERR_TEAMCOST_DIAMOND
  712, // 613 -> ERR_TEAMCOST_DRAGON
  751, // 614 -> ERR_TEAM_PPTLIMIT
  338, // 615 -> ERR_GUILD_INHERIT_CD_TIME
  486, // 616 -> ERR_MS_UNNORMAL
  713, // 617 -> ERR_TEAMCOST_NUMLIMIT
  686, // 618 -> ERR_STATE_CANTCHANGE
  740, // 619 -> ERR_TEAM_MEMCOUNT_OVER
  337, // 620 -> ERR_GUILD_INHERIT_CAN_NOT
  692, // 621 -> ERR_SYS_NOTOPEN
  488, // 622 -> ERR_NAME_ALLNUM
  491, // 623 -> ERR_NAME_TOO_LONG
  492, // 624 -> ERR_NAME_TOO_SHORT
  343, // 625 -> ERR_GUILD_INHERIT_OTHER_TIMES
  493, // 626 -> ERR_NEED_FIRST_PROMOTE
  241, // 627 -> ERR_FM_NOANCHOR
  101, // 628 -> ERR_CAN_NOT_USE_PET_SKILL_BOOK
  200, // 629 -> ERR_ENCHANT_MINLEVEL
  199, // 631 -> ERR_ENCHANT_LACKITEM
  204, // 632 -> ERR_ENCHANT_WRONGPOS
  534, // 650 -> ERR_PARTNER_NUM_INVALID
  526, // 651 -> ERR_PARTNER_FDEGREE_NOT_ENOUGH
  532, // 652 -> ERR_PARTNER_NOT_IN_MAIN_HALL
  531, // 653 -> ERR_PARTNER_NOT_ENOUGH_DRAGON
  524, // 654 -> ERR_PARTNER_CD_NOT_OK
  372, // 655 -> ERR_HORSE_ACTIVITY
  762, // 656 -> ERR_TEAM_WEEK_NEST_EXP
  525, // 657 -> ERR_PARTNER_CHEST_TAKED
  533, // 658 -> ERR_PARTNER_NO_PARTNER
  529, // 659 -> ERR_PARTNER_LN_NOT_ENOUGH
  523, // 660 -> ERR_PARTNER_ALREADY_HAS
  522, // 661 -> ERR_PARTNER_ALREADY_APPLY_LEAVE
  530, // 662 -> ERR_PARTNER_NOT_APPLY_LEAVE
  405, // 663 -> ERR_INVFIGHT_ROLE_LOGOUT
  401, // 664 -> ERR_INVFIGHT_ME_LEVEL
  402, // 665 -> ERR_INVFIGHT_ME_SCENE
  403, // 666 -> ERR_INVFIGHT_OTHER_LEVEL
  404, // 667 -> ERR_INVFIGHT_OTHER_SCENE
  398, // 668 -> ERR_INVFIGHT_INV_REPEAT
  396, // 669 -> ERR_INVFIGHT_INV_COUNT_MAX
  399, // 670 -> ERR_INVFIGHT_INV_TIME_OVER
  397, // 671 -> ERR_INVFIGHT_INV_DELAY
  189, // 672 -> ERR_DOODAD_FULL
  400, // 673 -> ERR_INVFIGHT_INV_TO_COUNT_MAX
  527, // 674 -> ERR_PARTNER_ITEM_NOT_FOUND
  535, // 675 -> ERR_PARTNER_OTHER_BUYING
  536, // 676 -> ERR_PARTNER_SHOP_NO_COUNT
  247, // 677 -> ERR_FRIEND_IS_PARTNER
  521, // 678 -> ERR_PANDORA_LACKOF_HEART
  605, // 679 -> ERR_SELF_HAS_ALLIANCE
  512, // 680 -> ERR_OTHER_HAS_ALLIANCE
  60, // 681 -> ERR_AUDIOTXT
  468, // 682 -> ERR_MENTOR_ASKMAXTODAY
  478, // 683 -> ERR_MENTOR_REFRESHTOOFAST
  477, // 684 -> ERR_MENTOR_OTHER_ONLINE
  528, // 685 -> ERR_PARTNER_LEVEL_NOT_ENOUGH
  279, // 686 -> ERR_GCASTLE_NOT_IN_ACT
  280, // 687 -> ERR_GCASTLE_NOT_IN_FIGHT
  281, // 688 -> ERR_GCASTLE_ROLE_FULL
  106, // 689 -> ERR_CARDMATCH_SIGNUP_LIMIT
  304, // 690 -> ERR_GUILDAUCT_PUBLIC_TIME
  225, // 691 -> ERR_FASHIONCOMPOSE_TIMELIMIT
  224, // 692 -> ERR_FASHIONCOMPOSE_QUALITY
  221, // 693 -> ERR_FASHIONCOMPOSE_FAILED
  223, // 694 -> ERR_FASHIONCOMPOSE_POS
  580, // 695 -> ERR_RESWAR_LEAVETEAM
  567, // 696 -> ERR_RECONNECT_FAIL
  97, // 697 -> ERR_CANTCHOOSEHERO
  369, // 698 -> ERR_HERO_INVALID
  754, // 699 -> ERR_TEAM_SERVER_OPEN_TIME
  61, // 700 -> ERR_AUDIO_CHAT
  370, // 701 -> ERR_HERO_LACKMONEY
  366, // 702 -> ERR_HEROBATTLE_CANTGETPRIZE
  365, // 703 -> ERR_HEROBATTLE_ALREADYGET
  100, // 704 -> ERR_CAN_NOT_DEL_IN_GUILD_TERRITOYR
  374, // 705 -> ERR_HORSE_TEAM
  282, // 706 -> ERR_GCASTLE_ROLE_LEVEL
  99, // 707 -> ERR_CAN_INGORE
  438, // 708 -> ERR_LEAGUE_NOT_IN_TEAM
  431, // 709 -> ERR_LEAGUE_ALREADY_HAS_TEAM
  448, // 710 -> ERR_LEAGUE_TEAM_ROLE_NUM_INVALID
  433, // 711 -> ERR_LEAGUE_HAS_NO_TEAM
  445, // 712 -> ERR_LEAGUE_TEAM_NOT_EXIST
  277, // 713 -> ERR_GARDEN_STEAL_LIMIT
  444, // 714 -> ERR_LEAGUE_TEAM_IN_MATCH
  447, // 715 -> ERR_LEAGUE_TEAM_NOT_IN_MATCH
  627, // 716 -> ERR_SKILL_NEED_EXPRESKILL
  213, // 717 -> ERR_EQUIP_CANTFORGE
  215, // 718 -> ERR_EQUIP_FORGE_LACK_ITEM
  216, // 719 -> ERR_EQUIP_FORGE_LACK_STONE
  440, // 720 -> ERR_LEAGUE_ROLE_ALREADY_UP
  441, // 721 -> ERR_LEAGUE_ROLE_FIGHTING
  439, // 722 -> ERR_LEAGUE_ROLE_ALREADY_BATTLE
  573, // 723 -> ERR_REQUEST_REPEAT
  214, // 724 -> ERR_EQUIP_FORGE_FAILED
  496, // 725 -> ERR_NOMAIL_GETREWARD
  480, // 726 -> ERR_MIDAS_FAILED
  443, // 727 -> ERR_LEAGUE_TEAM_IN_BATTLE
  201, // 728 -> ERR_ENCHANT_NOTHAVE
  198, // 729 -> ERR_ENCHANT_ALREADYHAVE
  203, // 730 -> ERR_ENCHANT_TRANSFER_LEVEL_LIMIT
  242, // 731 -> ERR_FM_NOINAUDIO
  243, // 732 -> ERR_FM_NOINROOM
  112, // 733 -> ERR_CHANGEPRO_LEVEL
  114, // 734 -> ERR_CHANGEPRO_TIME
  108, // 735 -> ERR_CHANGEPRO_COUNT
  109, // 736 -> ERR_CHANGEPRO_INVALID
  113, // 737 -> ERR_CHANGEPRO_SAMEPRO
  110, // 738 -> ERR_CHANGEPRO_ITEMLIMIT
  655, // 739 -> ERR_SMELT_MAXVALUE
  668, // 740 -> ERR_SPRITE_AWAKE_MAX
  111, // 741 -> ERR_CHANGEPRO_KICK
  437, // 742 -> ERR_LEAGUE_NOT_IN_MATCH_TIME
  446, // 743 -> ERR_LEAGUE_TEAM_NOT_IN_BATTLE
  684, // 744 -> ERR_SPRITE_TRAIN_MAX
  682, // 745 -> ERR_SPRITE_TRAIN_CHOOSEMAX
  683, // 746 -> ERR_SPRITE_TRAIN_LACKITEM
  680, // 747 -> ERR_SPRITE_NOTTRAIN
  681, // 748 -> ERR_SPRITE_RESETTRAIN_LACKITEM
  430, // 749 -> ERR_LEAGUE_ALREADY_FIGHTED
  436, // 750 -> ERR_LEAGUE_NOT_IN_APPLY_TIME
  373, // 751 -> ERR_HORSE_INTEAM
  435, // 752 -> ERR_LEAGUE_INV_NOT_IN_TEAM
  434, // 753 -> ERR_LEAGUE_INV_ALREADY_HAS_TEAM
  685, // 754 -> ERR_SPRITE_TRAIN_NOT_ENOUGH
  167, // 756 -> ERR_DECLAREWAR_OUT_TIME
  442, // 757 -> ERR_LEAGUE_TEAM_CANNOT_CROSS
  166, // 758 -> ERR_DECLARATION_TOO_LONG
  130, // 759 -> ERR_CROSS_ZONE_UNUSABLE
  499, // 760 -> ERR_NOT_DEL_GUILD_IN_TERR
  278, // 761 -> ERR_GCASTLE_FIGHT_END
  107, // 762 -> ERR_CAREER_PVP_NOTOPEN
  26, // 763 -> ERR_APOLLO_CDN
  432, // 764 -> ERR_LEAGUE_HAS_MEMBER_NOT_TEAM
  548, // 765 -> ERR_POK_MATCH_ENDSOON
  565, // 766 -> ERR_QUESTCAREER_NOT_ONLINE
  479, // 767 -> ERR_MIDAS_BALANCE_NOTENOUTH
  363, // 768 -> ERR_HAS_JOIN_OTHER_GUILD_BOSS
  63, // 769 -> ERR_AUTH_TOKEN_INVALID
  757, // 770 -> ERR_TEAM_TICKET_LESS
  760, // 771 -> ERR_TEAM_USE_TICKET_COUNT_LESS
  756, // 772 -> ERR_TEAM_TICKET_CONFIG
  758, // 773 -> ERR_TEAM_TICKET_SEAL
  391, // 774 -> ERR_INVALID_IBBUY
  129, // 775 -> ERR_CROSS_IBBUY
  351, // 776 -> ERR_GUILD_NAME_NULL
  347, // 777 -> ERR_GUILD_LOCK_NAME
  31, // 778 -> ERR_ARGENTA_DAILY_GET
  805, // 779 -> ERR_WORLDBOSSGUILD_COUNTLIMIT
  806, // 780 -> ERR_WORLDBOSSGUILD_UNMATCH
  368, // 781 -> ERR_HERO_EXPERIENCE_HAVE
  546, // 782 -> ERR_PLATSHARE_FAILED
  367, // 783 -> ERR_HERO_ALREADY_CHOSEN
  643, // 784 -> ERR_SKY_NOT_TEAM_MEMBER
  638, // 785 -> ERR_SKY_ALREADY_HAS_TEAM
  640, // 786 -> ERR_SKY_HAS_NO_TEAM
  642, // 787 -> ERR_SKY_INV_NOT_TEAM_MEMBER
  645, // 788 -> ERR_SKY_TEAM_IN_MATCH
  641, // 789 -> ERR_SKY_INV_ALREADY_HAS_TEAM
  647, // 790 -> ERR_SKY_TEAM_ROLE_NUM_INVALID
  644, // 791 -> ERR_SKY_TEAM_IN_BATTLE
  639, // 792 -> ERR_SKY_HAS_NOT_TEAM_MEMBER
  470, // 793 -> ERR_MENTOR_COMPLETE_OTHER_OFFLINE_NEED_DAYS
  469, // 794 -> ERR_MENTOR_COMPLETE_IN_RELATION_NEED_DAYS
  770, // 795 -> ERR_TRANSFERR_OTHER_ROLES_LEAVE
  547, // 796 -> ERR_PLAT_BANACC
  576, // 797 -> ERR_RESWAR_DIFF_GUILD
  637, // 798 -> ERR_SKY_ALREADY_FIGHTED
  646, // 799 -> ERR_SKY_TEAM_NO_DAILY_NUM
  378, // 800 -> ERR_IBGIFT_NOT_ENOUCH
  375, // 801 -> ERR_IBGIFT_DAY_MAXBUYCOUNT
  376, // 802 -> ERR_IBGIFT_FRIEND
  18, // 803 -> ERR_ALREADY_BUYAILEEN
  302, // 804 -> ERR_GUILDACMPPATY_NOTOPEN
  301, // 805 -> ERR_GUILDACMPPATY_ERRSTAGE
  300, // 806 -> ERR_GUILDACMPPATY_DISTANCE
  467, // 807 -> ERR_MENTOR_ALREADY_INRELATION
  303, // 808 -> ERR_GUILDACMPPATY_SPRITE_ONTEXIST
  76, // 809 -> ERR_BAG_FULL_CANT_COMPOSE
  78, // 810 -> ERR_BAG_FULL_TAKEOFF_ARTIFACT
  283, // 811 -> ERR_GIFTIB_NOTGOODS
  36, // 812 -> ERR_ARTIFACT_COMPOSE_LEVELNOTEQUAL
  38, // 813 -> ERR_ARTIFACT_COMPOSE_QUALITYNOTEQUAL
  37, // 814 -> ERR_ARTIFACT_COMPOSE_NUMBER
  35, // 815 -> ERR_ARTIFACT_COMPOSE_CANTCOMPOSE
  137, // 816 -> ERR_CUSTOMBATTLE_INVALIDREQUEST
  155, // 817 -> ERR_CUSTOMBATTLE_WORLDNOTOPEN
  136, // 818 -> ERR_CUSTOMBATTLE_HASJOIN
  149, // 819 -> ERR_CUSTOMBATTLE_NOTJOIN
  134, // 820 -> ERR_CUSTOMBATTLE_CREATFAILED
  143, // 821 -> ERR_CUSTOMBATTLE_LEVELLIMIT
  154, // 822 -> ERR_CUSTOMBATTLE_ROELNOTEXIST
  133, // 823 -> ERR_CUSTOMBATTLE_CREATECONFINVALID
  142, // 824 -> ERR_CUSTOMBATTLE_JOINNOTRELATED
  141, // 825 -> ERR_CUSTOMBATTLE_JOINNOTINREADYTIME
  139, // 826 -> ERR_CUSTOMBATTLE_JOINFULL
  140, // 827 -> ERR_CUSTOMBATTLE_JOININVALIDPASSWORD
  138, // 828 -> ERR_CUSTOMBATTLE_JOINFAILED
  148, // 829 -> ERR_CUSTOMBATTLE_NOTCREATER
  131, // 830 -> ERR_CUSTOMBATTLE_BATTLENOTFIND
  144, // 831 -> ERR_CUSTOMBATTLE_MATCHFAILED
  377, // 832 -> ERR_IBGIFT_MAX_COUNT
  202, // 833 -> ERR_ENCHANT_NOTHAVEATTRID
  218, // 834 -> ERR_EXTRA_EMBLEM_SLOT_FULL
  219, // 835 -> ERR_EXTRA_EMBLEM_SLOT_LEVEL
  379, // 836 -> ERR_IBGIFT_OVERMAXUNRECV
  716, // 837 -> ERR_TEAM_CANNOT_FORNOW
  22, // 838 -> ERR_ALREADY_REPORTED
  152, // 839 -> ERR_CUSTOMBATTLE_REWARDCD
  151, // 840 -> ERR_CUSTOMBATTLE_REWARDCANGET
  229, // 841 -> ERR_FASHION_ITEM_NOT_ENOUGH
  328, // 842 -> ERR_GUILDPARTY_TRADIING
  659, // 843 -> ERR_SPACTIVITY_NOTOPEN
  73, // 844 -> ERR_BAGEXPAND_LESSITEM
  74, // 845 -> ERR_BAGEXPAND_MAXCOUNT
  621, // 846 -> ERR_SHOP_WEEKCOUNTLIMIT
  308, // 847 -> ERR_GUILDBONUS_MAXNUM
  604, // 848 -> ERR_SELF_GIFT_SELF
  380, // 849 -> ERR_IBSHOP_BUSY
  2, // 850 -> ERR_ABYSS_LEVEL
  315, // 851 -> ERR_GUILDCAMP_SELF_NOTIN
  314, // 852 -> ERR_GUILDCAMP_OTHER_NOTIN
  651, // 853 -> ERR_SMELTCOUNT_ZERO
  153, // 854 -> ERR_CUSTOMBATTLE_REWARDHASGET
  150, // 855 -> ERR_CUSTOMBATTLE_PASSWORDINVALID
  135, // 856 -> ERR_CUSTOMBATTLE_CREATORLEAVE
  316, // 857 -> ERR_GUILDCAMP_SPRITE_NOTEXIST
  733, // 858 -> ERR_TEAM_INV_TIMEOUT
  244, // 859 -> ERR_FORGE_NOREPLACE
  146, // 860 -> ERR_CUSTOMBATTLE_NAMEMAX
  147, // 861 -> ERR_CUSTOMBATTLE_NAMEMIN
  145, // 862 -> ERR_CUSTOMBATTLE_NAMEINVALID
  572, // 863 -> ERR_REPORT_FORBID
  718, // 864 -> ERR_TEAM_COST_CANCEL
  719, // 865 -> ERR_TEAM_COST_WIN
  158, // 866 -> ERR_CUSTOM_NOTOPEN
  156, // 867 -> ERR_CUSTOM_GMLIMIT
  481, // 868 -> ERR_MILITARY_TRIGGER_CHECK
  474, // 869 -> ERR_MENTOR_INHERIT_ING
  485, // 870 -> ERR_MOBA_UPGRADENUM_EMPTY
  228, // 871 -> ERR_FASHION_ERROR_COLOR
  227, // 872 -> ERR_FASHION_COLOR_UNLOOK
  232, // 873 -> ERR_FASHION_NO_HAIR
  226, // 874 -> ERR_FASHION_COLOR_LOOK
  484, // 875 -> ERR_MOBA_SIGNAL_TOOFAST
  498, // 876 -> ERR_NOT_BESPEAK
  517, // 877 -> ERR_PAIRPET_OUTRANGE
  513, // 878 -> ERR_PAIRPET_INVITEINVALID
  590, // 879 -> ERR_ROLE_IN_OTHER_SERVER
  482, // 880 -> ERR_MOBA_CANTMATCH
  514, // 881 -> ERR_PAIRPET_INVITEREPEAT
  518, // 882 -> ERR_PAIRPET_SCENEINVALID
  519, // 883 -> ERR_PAIRPET_SELF
  515, // 884 -> ERR_PAIRPET_OTHER
  516, // 885 -> ERR_PAIRPET_OTHERNOTIN
  476, // 886 -> ERR_MENTOR_OTHER_APPLY_BREAK
  466, // 887 -> ERR_MENTOR_ALREADY_COMPLETE_MENTOR
  475, // 888 -> ERR_MENTOR_OTHER_ALREADY_APPLY_INHERIT
  473, // 889 -> ERR_MENTOR_CUR_STATUS_CANNOT_BREAK
  159, // 890 -> ERR_CUSTOM_SAMEMATCH
  157, // 891 -> ERR_CUSTOM_NOMATCHING
  472, // 892 -> ERR_MENTOR_CUR_STATUS_CANNOT_APPLYSTUDENT
  471, // 893 -> ERR_MENTOR_CUR_STATUS_CANNOT_APPLYMASTER
  721, // 894 -> ERR_TEAM_DIAMOND_COST_LIMIT
  15, // 895 -> ERR_ACT_NOT_OPEN
  483, // 896 -> ERR_MOBA_MOBMAXLEVEL
  10, // 897 -> ERR_ACTIVITY
  495, // 898 -> ERR_NOCONDITION
  606, // 899 -> ERR_SERVER_UNNORMAL
  132, // 900 -> ERR_CUSTOMBATTLE_BOUNTYMODE_NOTOPEN
  291, // 901 -> ERR_GROUPCHAT_FULLGROUP
  296, // 902 -> ERR_GROUPCHAT_ROLENOCOUNT
  294, // 903 -> ERR_GROUPCHAT_LEADERNOCOUNT
  293, // 904 -> ERR_GROUPCHAT_GROUPFULLMEMBERS
  781, // 905 -> ERR_UNUSE1
  364, // 906 -> ERR_HAVE_GOT_AWARD
  24, // 907 -> ERR_ANCIENTPOWER_LESSPOINT
  23, // 908 -> ERR_ANCIENTPOWER_DEAD
  418, // 909 -> ERR_JADE_DRAGONNOTENOUGH
  799, // 910 -> ERR_WEDDING_NOT_EXISTS
  790, // 911 -> ERR_WEDDING_ALREADY_INVITE
  800, // 912 -> ERR_WEDDING_NOT_INVITE
  798, // 913 -> ERR_WEDDING_NOT_APPLY
  460, // 914 -> ERR_MARRIAGE_LEVEL_NOTENOUGH
  462, // 915 -> ERR_MARRIAGE_NEED_TWO_NOTMARRY
  459, // 916 -> ERR_MARRIAGE_DISTANCE_TOOFAR
  803, // 917 -> ERR_WEDDING_OPER_CD
  793, // 918 -> ERR_WEDDING_ALREADY_VOWS
  794, // 919 -> ERR_WEDDING_HP_NOT_ENOUGH
  801, // 920 -> ERR_WEDDING_NOT_OWNER
  463, // 921 -> ERR_MARRIAGE_NOTINMARRIAGE
  458, // 922 -> ERR_MARRIAGE_ALREADY_APPLYDIVORCE
  464, // 923 -> ERR_MARRIAGE_NOT_DIVORCESTATUS
  465, // 924 -> ERR_MARRIAGE_ONLY_APPLIER_CANCLEDIVORCE
  245, // 925 -> ERR_FRIEND_DEGREE_NOTENOUGH
  789, // 926 -> ERR_WEDDING_ALREADY_HOLDED
  792, // 927 -> ERR_WEDDING_ALREADY_TAKECAR
  393, // 928 -> ERR_INVALID_PAYROLE
  796, // 929 -> ERR_WEDDING_IS_HOLDING
  802, // 930 -> ERR_WEDDING_NOT_RUNNING
  450, // 931 -> ERR_LIVENESS_NOT_ENOUGH
  126, // 932 -> ERR_CHEST_TAKED
  788, // 933 -> ERR_WEDDING_ALREADY_APPLY
  292, // 934 -> ERR_GROUPCHAT_FULLGROUP_OTHER
  297, // 935 -> ERR_GROUPCHAT_TIMEOUT
  295, // 936 -> ERR_GROUPCHAT_NO_MANAGER
  413, // 937 -> ERR_ITEM_NOT_ENOUGH_COMMON
  786, // 938 -> ERR_WEDDINGCAR_CANT_IN_PET
  787, // 939 -> ERR_WEDDINGCAR_OTHER_RUNNING
  34, // 940 -> ERR_ARTIFACT_CANTRECAST
  32, // 941 -> ERR_ARTIFACT_CANTFUSE
  39, // 942 -> ERR_ARTIFACT_FUSEFAILED
  40, // 943 -> ERR_ARTIFACT_FUSE_CONDITION
  33, // 944 -> ERR_ARTIFACT_CANTINSCRIPTION
  791, // 945 -> ERR_WEDDING_ALREADY_REFUSE
  797, // 946 -> ERR_WEDDING_NEED_TWO_MARRIAGE
  679, // 947 -> ERR_SPRITE_NOTREBIRTH
  725, // 948 -> ERR_TEAM_FASTMATCH_BUFF
  753, // 949 -> ERR_TEAM_SERVER_NOT_MATCH
  165, // 950 -> ERR_DAILY_WEDDY_CANDY_OVERMAX
  461, // 951 -> ERR_MARRIAGE_NEED_TEAM
  71, // 952 -> ERR_BACKFLOW_BUYEND
  494, // 953 -> ERR_NEED_MARRIAGE_TEAM
  188, // 954 -> ERR_DOENTERSCENE_FAILED
  795, // 955 -> ERR_WEDDING_INVITE_OVERMAX
  41, // 956 -> ERR_ARTIFACT_INSCRIPTION_LEVEL
  775, // 957 -> ERR_TRANS_PASSIVE
  773, // 958 -> ERR_TRANS_NONE
  774, // 959 -> ERR_TRANS_OTHERNOTEXIST
  772, // 960 -> ERR_TRANS_ITEMNOTENOUGH
  777, // 961 -> ERR_TRANS_STATE_FAILED
  776, // 962 -> ERR_TRANS_SCENE_INVALID
  262, // 963 -> ERR_GARDEN_EXPELSPRITE_MAX
  510, // 964 -> ERR_OP_ROLE_LEAVE
  84, // 965 -> ERR_BATTLEFIELD_NOT_OPEN
  83, // 966 -> ERR_BATTLEFIELD_LEVEL
  706, // 967 -> ERR_TASK_NO_REFRESH_COUNT
  98, // 968 -> ERR_CANT_FUSE
  257, // 969 -> ERR_FUSE_MAX
  703, // 970 -> ERR_TASK_NOT_TASK_ITEM
  128, // 971 -> ERR_COMPETEDRAGON_WRONG_DNID
  96, // 972 -> ERR_CANNOT_PICK_THIS_ITEM
  506, // 973 -> ERR_NPCFL_NEED_REFRESH
  507, // 974 -> ERR_NPCFL_NPC_LEVEL_MAX
  505, // 975 -> ERR_NPCFL_ITEM_LESS
  503, // 976 -> ERR_NPCFL_EXP_LESS
  508, // 977 -> ERR_NPCFL_UNITE_LEVEL_LESS
  504, // 978 -> ERR_NPCFL_GIVE_GIFT_COUNT_LESS
  501, // 979 -> ERR_NPCFL_BUY_GG_COUNT_LESS
  502, // 980 -> ERR_NPCFL_DRAGON_COIN_LESS
  162, // 981 -> ERR_DAILY_TASK_NO_REFRESH_COUNT
  160, // 982 -> ERR_DAILY_TASK_CANNT_REFRESH
  161, // 983 -> ERR_DAILY_TASK_NO_BUY_COUNT
  164, // 984 -> ERR_DAILY_TASK_QUALITY_MAX
  171, // 985 -> ERR_DG_ALREADY_IN_DG
  173, // 986 -> ERR_DG_DGNAME_EXIST
  174, // 987 -> ERR_DG_DGUILD_NOT_EXIST
  175, // 988 -> ERR_DG_FULL
  185, // 989 -> ERR_DG_PPT_REQ
  187, // 990 -> ERR_DG_WAITAPPROVAL
  180, // 991 -> ERR_DG_NOT_IN_GUILD
  182, // 992 -> ERR_DG_NO_PERMISSION
  178, // 993 -> ERR_DG_LOCK_NAME
  172, // 994 -> ERR_DG_APPLY_FULL
  176, // 995 -> ERR_DG_IN_CD
  177, // 996 -> ERR_DG_ITEM_NOT_FOUND
  183, // 997 -> ERR_DG_OTHER_BUYING
  186, // 998 -> ERR_DG_SHOP_NO_COUNT
  181, // 999 -> ERR_DG_NOT_IN_SAME
  184, // 1000 -> ERR_DG_POSITION_FULL
  163, // 1001 -> ERR_DAILY_TASK_OTHER_NO_HELPCOUNT
  780, // 1002 -> ERR_UNOPEN_FUNCTION
  564, // 1003 -> ERR_QUERYBOX_TIMELEFT
  325, // 1004 -> ERR_GUILDPARTY_ENDING
  326, // 1005 -> ERR_GUILDPARTY_HAVESUMMON
  427, // 1006 -> ERR_KINGBACK_REWARD_COUNT_LIMIT
  179, // 1007 -> ERR_DG_NOT_IN_APPROVAL
  327, // 1008 -> ERR_GUILDPARTY_SUMMONING
  371, // 1009 -> ERR_HG_FORBID
  230, // 1010 -> ERR_FASHION_NOEXIST_EFFECTS
  70, // 1011 -> ERR_BACKFLOW_ALREADYGET
  72, // 1012 -> ERR_BACKFLOW_LESSPOINT
  720, // 1013 -> ERR_TEAM_CROSS_TEAM_CHANGE_EXP
  717, // 1014 -> ERR_TEAM_CHANGE_EXP_TO_CROSS
  395, // 1015 -> ERR_INVALID_STATE
  115, // 1016 -> ERR_CHANGE_SAMESCENE
  67, // 1017 -> ERR_BACKFLOWSHOP_LESSFRESHCOUNT
  68, // 1018 -> ERR_BACKFLOWSHOP_NOTHAVEGOOD
  65, // 1019 -> ERR_BACKFLOWSHOP_LACKDIAMOND
  66, // 1020 -> ERR_BACKFLOWSHOP_LACKDRAGONCOIN
  64, // 1021 -> ERR_BACKFLOWSHOP_ALREADYBUY
  69, // 1022 -> ERR_BACKFLOWSHOP_SHOPCLOSE
  19, // 1023 -> ERR_ALREADY_CHARGE_BACK
  256, // 1024 -> ERR_FUSE_EXPMAX
  255, // 1025 -> ERR_FUSE_BREAKLACKEXP
};

const std::string& ErrorCode_Name(
    ErrorCode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ErrorCode_entries,
          ErrorCode_entries_by_number,
          810, ErrorCode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ErrorCode_entries,
      ErrorCode_entries_by_number,
      810, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ErrorCode_strings[idx].get();
}
bool ErrorCode_Parse(
    const std::string& name, ErrorCode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ErrorCode_entries, 810, name, &int_value);
  if (success) {
    *value = static_cast<ErrorCode>(int_value);
  }
  return success;
}
bool RoleType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 111:
    case 112:
    case 113:
    case 114:
    case 115:
    case 116:
    case 117:
    case 121:
    case 122:
    case 123:
    case 124:
    case 125:
    case 126:
    case 127:
    case 211:
    case 212:
    case 213:
    case 214:
    case 215:
    case 216:
    case 217:
    case 221:
    case 222:
    case 223:
    case 224:
    case 225:
    case 226:
    case 227:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> RoleType_strings[50] = {};

static const char RoleType_names[] =
  "Role_AbyssWalker"
  "Role_Academic"
  "Role_Acrobat"
  "Role_Adept"
  "Role_Alchemist"
  "Role_Archer"
  "Role_Artillery"
  "Role_Assassin"
  "Role_Barbarian"
  "Role_BladeDancer"
  "Role_Cleric"
  "Role_Crusader"
  "Role_Dancer"
  "Role_DarkSummoner"
  "Role_Destroyer"
  "Role_Elementalist"
  "Role_Elestra"
  "Role_Engineer"
  "Role_Gearmaster"
  "Role_Gladiator"
  "Role_Guardian"
  "Role_INVALID"
  "Role_Inquistior"
  "Role_Kali"
  "Role_LightBringer"
  "Role_Majesty"
  "Role_Mercenary"
  "Role_Moonlord"
  "Role_Mystic"
  "Role_Paladin"
  "Role_Physician"
  "Role_Priest"
  "Role_Raven"
  "Role_Reaper"
  "Role_Saint"
  "Role_Saleana"
  "Role_Screamer"
  "Role_Sharpshooter"
  "Role_Shinobi"
  "Role_Shootingstar"
  "Role_Smasher"
  "Role_Sniper"
  "Role_Sorceress"
  "Role_SoulEater"
  "Role_SpiritDancer"
  "Role_Swordsman"
  "Role_Taoist"
  "Role_Tempest"
  "Role_Warrior"
  "Role_Windwalker";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry RoleType_entries[] = {
  { {RoleType_names + 0, 16}, 226 },
  { {RoleType_names + 16, 13}, 5 },
  { {RoleType_names + 29, 12}, 22 },
  { {RoleType_names + 41, 10}, 125 },
  { {RoleType_names + 51, 14}, 25 },
  { {RoleType_names + 65, 11}, 2 },
  { {RoleType_names + 76, 14}, 212 },
  { {RoleType_names + 90, 13}, 6 },
  { {RoleType_names + 103, 14}, 221 },
  { {RoleType_names + 117, 16}, 227 },
  { {RoleType_names + 133, 11}, 4 },
  { {RoleType_names + 144, 13}, 214 },
  { {RoleType_names + 157, 11}, 27 },
  { {RoleType_names + 168, 17}, 217 },
  { {RoleType_names + 185, 14}, 121 },
  { {RoleType_names + 199, 17}, 13 },
  { {RoleType_names + 216, 12}, 213 },
  { {RoleType_names + 228, 13}, 15 },
  { {RoleType_names + 241, 15}, 215 },
  { {RoleType_names + 256, 14}, 111 },
  { {RoleType_names + 270, 13}, 114 },
  { {RoleType_names + 283, 12}, 0 },
  { {RoleType_names + 295, 15}, 224 },
  { {RoleType_names + 310, 9}, 7 },
  { {RoleType_names + 319, 17}, 126 },
  { {RoleType_names + 336, 12}, 223 },
  { {RoleType_names + 348, 14}, 21 },
  { {RoleType_names + 362, 13}, 211 },
  { {RoleType_names + 375, 11}, 23 },
  { {RoleType_names + 386, 12}, 14 },
  { {RoleType_names + 398, 14}, 225 },
  { {RoleType_names + 412, 11}, 24 },
  { {RoleType_names + 423, 10}, 216 },
  { {RoleType_names + 433, 11}, 116 },
  { {RoleType_names + 444, 10}, 124 },
  { {RoleType_names + 454, 12}, 113 },
  { {RoleType_names + 466, 13}, 17 },
  { {RoleType_names + 479, 17}, 12 },
  { {RoleType_names + 496, 12}, 16 },
  { {RoleType_names + 508, 17}, 115 },
  { {RoleType_names + 525, 12}, 123 },
  { {RoleType_names + 537, 11}, 112 },
  { {RoleType_names + 548, 14}, 3 },
  { {RoleType_names + 562, 14}, 117 },
  { {RoleType_names + 576, 17}, 127 },
  { {RoleType_names + 593, 14}, 11 },
  { {RoleType_names + 607, 11}, 26 },
  { {RoleType_names + 618, 12}, 122 },
  { {RoleType_names + 630, 12}, 1 },
  { {RoleType_names + 642, 15}, 222 },
};

static const int RoleType_entries_by_number[] = {
  21, // 0 -> Role_INVALID
  48, // 1 -> Role_Warrior
  5, // 2 -> Role_Archer
  42, // 3 -> Role_Sorceress
  10, // 4 -> Role_Cleric
  1, // 5 -> Role_Academic
  7, // 6 -> Role_Assassin
  23, // 7 -> Role_Kali
  45, // 11 -> Role_Swordsman
  37, // 12 -> Role_Sharpshooter
  15, // 13 -> Role_Elementalist
  29, // 14 -> Role_Paladin
  17, // 15 -> Role_Engineer
  38, // 16 -> Role_Shinobi
  36, // 17 -> Role_Screamer
  26, // 21 -> Role_Mercenary
  2, // 22 -> Role_Acrobat
  28, // 23 -> Role_Mystic
  31, // 24 -> Role_Priest
  4, // 25 -> Role_Alchemist
  46, // 26 -> Role_Taoist
  12, // 27 -> Role_Dancer
  19, // 111 -> Role_Gladiator
  41, // 112 -> Role_Sniper
  35, // 113 -> Role_Saleana
  20, // 114 -> Role_Guardian
  39, // 115 -> Role_Shootingstar
  33, // 116 -> Role_Reaper
  43, // 117 -> Role_SoulEater
  14, // 121 -> Role_Destroyer
  47, // 122 -> Role_Tempest
  40, // 123 -> Role_Smasher
  34, // 124 -> Role_Saint
  3, // 125 -> Role_Adept
  24, // 126 -> Role_LightBringer
  44, // 127 -> Role_SpiritDancer
  27, // 211 -> Role_Moonlord
  6, // 212 -> Role_Artillery
  16, // 213 -> Role_Elestra
  11, // 214 -> Role_Crusader
  18, // 215 -> Role_Gearmaster
  32, // 216 -> Role_Raven
  13, // 217 -> Role_DarkSummoner
  8, // 221 -> Role_Barbarian
  49, // 222 -> Role_Windwalker
  25, // 223 -> Role_Majesty
  22, // 224 -> Role_Inquistior
  30, // 225 -> Role_Physician
  0, // 226 -> Role_AbyssWalker
  9, // 227 -> Role_BladeDancer
};

const std::string& RoleType_Name(
    RoleType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          RoleType_entries,
          RoleType_entries_by_number,
          50, RoleType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      RoleType_entries,
      RoleType_entries_by_number,
      50, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     RoleType_strings[idx].get();
}
bool RoleType_Parse(
    const std::string& name, RoleType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      RoleType_entries, 50, name, &int_value);
  if (success) {
    *value = static_cast<RoleType>(int_value);
  }
  return success;
}
bool SceneType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 5:
    case 7:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 65:
    case 66:
    case 67:
    case 68:
    case 69:
    case 70:
    case 71:
    case 100:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SceneType_strings[63] = {};

static const char SceneType_names[] =
  "SCENE_ABYSSS"
  "SCENE_ABYSS_PARTY"
  "SCENE_ACTIVITY_ONE"
  "SCENE_ACTIVITY_THREE"
  "SCENE_ACTIVITY_TWO"
  "SCENE_AIRSHIP"
  "SCENE_ARENA"
  "SCENE_BATTLE"
  "SCENE_BATTLEFIELD_FIGHT"
  "SCENE_BATTLEFIELD_READY"
  "SCENE_BIGMELEE_FIGHT"
  "SCENE_BIGMELEE_READY"
  "SCENE_BIOHELL"
  "SCENE_BOSSRUSH"
  "SCENE_CALLBACK"
  "SCENE_CASTLE_FIGHT"
  "SCENE_CASTLE_WAIT"
  "SCENE_COMPETEDRAGON"
  "SCENE_COUPLE"
  "SCENE_CUSTOMPK"
  "SCENE_CUSTOMPKTWO"
  "SCENE_DRAGON"
  "SCENE_DRAGON_EXP"
  "SCENE_DUCK"
  "SCENE_ENDLESSABYSS"
  "SCENE_FAMILYGARDEN"
  "SCENE_GMF"
  "SCENE_GODDESS"
  "SCENE_GPR"
  "SCENE_GUILD_BOSS"
  "SCENE_GUILD_CAMP"
  "SCENE_GUILD_HALL"
  "SCENE_HALL"
  "SCENE_HEROBATTLE"
  "SCENE_HORSE"
  "SCENE_HORSE_RACE"
  "SCENE_INVFIGHT"
  "SCENE_LEAGUE_BATTLE"
  "SCENE_LEISURE"
  "SCENE_LOGIN"
  "SCENE_MOBA"
  "SCENE_NEST"
  "SCENE_PK"
  "SCENE_PKTWO"
  "SCENE_PROF_TRIALS"
  "SCENE_PVP"
  "SCENE_RESWAR_PVE"
  "SCENE_RESWAR_PVP"
  "SCENE_RISK"
  "SCENE_SURVIVE"
  "SCENE_TOWER"
  "SCENE_VS_CHALLENGE"
  "SCENE_WEDDING"
  "SCENE_WEEKEND4V4_CRAZYBOMB"
  "SCENE_WEEKEND4V4_DUCK"
  "SCENE_WEEKEND4V4_GHOSTACTION"
  "SCENE_WEEKEND4V4_HORSERACING"
  "SCENE_WEEKEND4V4_LIVECHALLENGE"
  "SCENE_WEEKEND4V4_MONSTERFIGHT"
  "SCENE_WEEK_NEST"
  "SCENE_WORLDBOSS"
  "SKYCITY_FIGHTING"
  "SKYCITY_WAITING";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SceneType_entries[] = {
  { {SceneType_names + 0, 12}, 13 },
  { {SceneType_names + 12, 17}, 44 },
  { {SceneType_names + 29, 18}, 41 },
  { {SceneType_names + 47, 20}, 43 },
  { {SceneType_names + 67, 18}, 42 },
  { {SceneType_names + 85, 13}, 31 },
  { {SceneType_names + 98, 11}, 5 },
  { {SceneType_names + 109, 12}, 2 },
  { {SceneType_names + 121, 23}, 68 },
  { {SceneType_names + 144, 23}, 67 },
  { {SceneType_names + 167, 20}, 61 },
  { {SceneType_names + 187, 20}, 60 },
  { {SceneType_names + 207, 13}, 64 },
  { {SceneType_names + 220, 14}, 9 },
  { {SceneType_names + 234, 14}, 62 },
  { {SceneType_names + 248, 18}, 39 },
  { {SceneType_names + 266, 17}, 38 },
  { {SceneType_names + 283, 19}, 69 },
  { {SceneType_names + 302, 12}, 66 },
  { {SceneType_names + 314, 14}, 45 },
  { {SceneType_names + 328, 17}, 53 },
  { {SceneType_names + 345, 12}, 18 },
  { {SceneType_names + 357, 16}, 21 },
  { {SceneType_names + 373, 10}, 65 },
  { {SceneType_names + 383, 18}, 23 },
  { {SceneType_names + 401, 18}, 15 },
  { {SceneType_names + 419, 9}, 19 },
  { {SceneType_names + 428, 13}, 20 },
  { {SceneType_names + 441, 9}, 27 },
  { {SceneType_names + 450, 16}, 11 },
  { {SceneType_names + 466, 16}, 30 },
  { {SceneType_names + 482, 16}, 10 },
  { {SceneType_names + 498, 10}, 1 },
  { {SceneType_names + 508, 16}, 36 },
  { {SceneType_names + 524, 11}, 34 },
  { {SceneType_names + 535, 16}, 35 },
  { {SceneType_names + 551, 14}, 37 },
  { {SceneType_names + 565, 19}, 40 },
  { {SceneType_names + 584, 13}, 71 },
  { {SceneType_names + 597, 11}, 100 },
  { {SceneType_names + 608, 10}, 47 },
  { {SceneType_names + 618, 10}, 3 },
  { {SceneType_names + 628, 8}, 12 },
  { {SceneType_names + 636, 11}, 46 },
  { {SceneType_names + 647, 17}, 26 },
  { {SceneType_names + 664, 9}, 17 },
  { {SceneType_names + 673, 16}, 29 },
  { {SceneType_names + 689, 16}, 28 },
  { {SceneType_names + 705, 10}, 22 },
  { {SceneType_names + 715, 13}, 70 },
  { {SceneType_names + 728, 11}, 16 },
  { {SceneType_names + 739, 18}, 33 },
  { {SceneType_names + 757, 13}, 63 },
  { {SceneType_names + 770, 26}, 51 },
  { {SceneType_names + 796, 21}, 54 },
  { {SceneType_names + 817, 28}, 49 },
  { {SceneType_names + 845, 28}, 52 },
  { {SceneType_names + 873, 30}, 50 },
  { {SceneType_names + 903, 29}, 48 },
  { {SceneType_names + 932, 15}, 32 },
  { {SceneType_names + 947, 15}, 7 },
  { {SceneType_names + 962, 16}, 25 },
  { {SceneType_names + 978, 15}, 24 },
};

static const int SceneType_entries_by_number[] = {
  32, // 1 -> SCENE_HALL
  7, // 2 -> SCENE_BATTLE
  41, // 3 -> SCENE_NEST
  6, // 5 -> SCENE_ARENA
  60, // 7 -> SCENE_WORLDBOSS
  13, // 9 -> SCENE_BOSSRUSH
  31, // 10 -> SCENE_GUILD_HALL
  29, // 11 -> SCENE_GUILD_BOSS
  42, // 12 -> SCENE_PK
  0, // 13 -> SCENE_ABYSSS
  25, // 15 -> SCENE_FAMILYGARDEN
  50, // 16 -> SCENE_TOWER
  45, // 17 -> SCENE_PVP
  21, // 18 -> SCENE_DRAGON
  26, // 19 -> SCENE_GMF
  27, // 20 -> SCENE_GODDESS
  22, // 21 -> SCENE_DRAGON_EXP
  48, // 22 -> SCENE_RISK
  24, // 23 -> SCENE_ENDLESSABYSS
  62, // 24 -> SKYCITY_WAITING
  61, // 25 -> SKYCITY_FIGHTING
  44, // 26 -> SCENE_PROF_TRIALS
  28, // 27 -> SCENE_GPR
  47, // 28 -> SCENE_RESWAR_PVP
  46, // 29 -> SCENE_RESWAR_PVE
  30, // 30 -> SCENE_GUILD_CAMP
  5, // 31 -> SCENE_AIRSHIP
  59, // 32 -> SCENE_WEEK_NEST
  51, // 33 -> SCENE_VS_CHALLENGE
  34, // 34 -> SCENE_HORSE
  35, // 35 -> SCENE_HORSE_RACE
  33, // 36 -> SCENE_HEROBATTLE
  36, // 37 -> SCENE_INVFIGHT
  16, // 38 -> SCENE_CASTLE_WAIT
  15, // 39 -> SCENE_CASTLE_FIGHT
  37, // 40 -> SCENE_LEAGUE_BATTLE
  2, // 41 -> SCENE_ACTIVITY_ONE
  4, // 42 -> SCENE_ACTIVITY_TWO
  3, // 43 -> SCENE_ACTIVITY_THREE
  1, // 44 -> SCENE_ABYSS_PARTY
  19, // 45 -> SCENE_CUSTOMPK
  43, // 46 -> SCENE_PKTWO
  40, // 47 -> SCENE_MOBA
  58, // 48 -> SCENE_WEEKEND4V4_MONSTERFIGHT
  55, // 49 -> SCENE_WEEKEND4V4_GHOSTACTION
  57, // 50 -> SCENE_WEEKEND4V4_LIVECHALLENGE
  53, // 51 -> SCENE_WEEKEND4V4_CRAZYBOMB
  56, // 52 -> SCENE_WEEKEND4V4_HORSERACING
  20, // 53 -> SCENE_CUSTOMPKTWO
  54, // 54 -> SCENE_WEEKEND4V4_DUCK
  11, // 60 -> SCENE_BIGMELEE_READY
  10, // 61 -> SCENE_BIGMELEE_FIGHT
  14, // 62 -> SCENE_CALLBACK
  52, // 63 -> SCENE_WEDDING
  12, // 64 -> SCENE_BIOHELL
  23, // 65 -> SCENE_DUCK
  18, // 66 -> SCENE_COUPLE
  9, // 67 -> SCENE_BATTLEFIELD_READY
  8, // 68 -> SCENE_BATTLEFIELD_FIGHT
  17, // 69 -> SCENE_COMPETEDRAGON
  49, // 70 -> SCENE_SURVIVE
  38, // 71 -> SCENE_LEISURE
  39, // 100 -> SCENE_LOGIN
};

const std::string& SceneType_Name(
    SceneType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SceneType_entries,
          SceneType_entries_by_number,
          63, SceneType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SceneType_entries,
      SceneType_entries_by_number,
      63, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SceneType_strings[idx].get();
}
bool SceneType_Parse(
    const std::string& name, SceneType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SceneType_entries, 63, name, &int_value);
  if (success) {
    *value = static_cast<SceneType>(int_value);
  }
  return success;
}
bool TableDef_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TableDef_strings[2] = {};

static const char TableDef_names[] =
  "AccountTable"
  "RoleTable";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TableDef_entries[] = {
  { {TableDef_names + 0, 12}, 1 },
  { {TableDef_names + 12, 9}, 2 },
};

static const int TableDef_entries_by_number[] = {
  0, // 1 -> AccountTable
  1, // 2 -> RoleTable
};

const std::string& TableDef_Name(
    TableDef value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TableDef_entries,
          TableDef_entries_by_number,
          2, TableDef_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TableDef_entries,
      TableDef_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TableDef_strings[idx].get();
}
bool TableDef_Parse(
    const std::string& name, TableDef* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TableDef_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<TableDef>(int_value);
  }
  return success;
}
bool EntitySpecies_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> EntitySpecies_strings[10] = {};

static const char EntitySpecies_names[] =
  "Species_Affiliate"
  "Species_Boss"
  "Species_Dummy"
  "Species_Elite"
  "Species_Empty"
  "Species_Npc"
  "Species_Opposer"
  "Species_Puppet"
  "Species_Role"
  "Species_Substance";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry EntitySpecies_entries[] = {
  { {EntitySpecies_names + 0, 17}, 11 },
  { {EntitySpecies_names + 17, 12}, 1 },
  { {EntitySpecies_names + 29, 13}, 9 },
  { {EntitySpecies_names + 42, 13}, 6 },
  { {EntitySpecies_names + 55, 13}, 8 },
  { {EntitySpecies_names + 68, 11}, 7 },
  { {EntitySpecies_names + 79, 15}, 2 },
  { {EntitySpecies_names + 94, 14}, 3 },
  { {EntitySpecies_names + 108, 12}, 10 },
  { {EntitySpecies_names + 120, 17}, 5 },
};

static const int EntitySpecies_entries_by_number[] = {
  1, // 1 -> Species_Boss
  6, // 2 -> Species_Opposer
  7, // 3 -> Species_Puppet
  9, // 5 -> Species_Substance
  3, // 6 -> Species_Elite
  5, // 7 -> Species_Npc
  4, // 8 -> Species_Empty
  2, // 9 -> Species_Dummy
  8, // 10 -> Species_Role
  0, // 11 -> Species_Affiliate
};

const std::string& EntitySpecies_Name(
    EntitySpecies value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          EntitySpecies_entries,
          EntitySpecies_entries_by_number,
          10, EntitySpecies_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      EntitySpecies_entries,
      EntitySpecies_entries_by_number,
      10, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     EntitySpecies_strings[idx].get();
}
bool EntitySpecies_Parse(
    const std::string& name, EntitySpecies* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      EntitySpecies_entries, 10, name, &int_value);
  if (success) {
    *value = static_cast<EntitySpecies>(int_value);
  }
  return success;
}
bool BattleChestRewardType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> BattleChestRewardType_strings[4] = {};

static const char BattleChestRewardType_names[] =
  "COPPER_CHEST"
  "GOLD_CHEST"
  "SILVER_CHEST"
  "WOOD_CHEST";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry BattleChestRewardType_entries[] = {
  { {BattleChestRewardType_names + 0, 12}, 3 },
  { {BattleChestRewardType_names + 12, 10}, 1 },
  { {BattleChestRewardType_names + 22, 12}, 2 },
  { {BattleChestRewardType_names + 34, 10}, 4 },
};

static const int BattleChestRewardType_entries_by_number[] = {
  1, // 1 -> GOLD_CHEST
  2, // 2 -> SILVER_CHEST
  0, // 3 -> COPPER_CHEST
  3, // 4 -> WOOD_CHEST
};

const std::string& BattleChestRewardType_Name(
    BattleChestRewardType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          BattleChestRewardType_entries,
          BattleChestRewardType_entries_by_number,
          4, BattleChestRewardType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      BattleChestRewardType_entries,
      BattleChestRewardType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     BattleChestRewardType_strings[idx].get();
}
bool BattleChestRewardType_Parse(
    const std::string& name, BattleChestRewardType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      BattleChestRewardType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<BattleChestRewardType>(int_value);
  }
  return success;
}
bool TaskOPEnum_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TaskOPEnum_strings[2] = {};

static const char TaskOPEnum_names[] =
  "FINISH_TASK"
  "TAKE_TASK";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TaskOPEnum_entries[] = {
  { {TaskOPEnum_names + 0, 11}, 2 },
  { {TaskOPEnum_names + 11, 9}, 1 },
};

static const int TaskOPEnum_entries_by_number[] = {
  1, // 1 -> TAKE_TASK
  0, // 2 -> FINISH_TASK
};

const std::string& TaskOPEnum_Name(
    TaskOPEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TaskOPEnum_entries,
          TaskOPEnum_entries_by_number,
          2, TaskOPEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TaskOPEnum_entries,
      TaskOPEnum_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TaskOPEnum_strings[idx].get();
}
bool TaskOPEnum_Parse(
    const std::string& name, TaskOPEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TaskOPEnum_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<TaskOPEnum>(int_value);
  }
  return success;
}
bool ResetType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ResetType_strings[3] = {};

static const char ResetType_names[] =
  "RESET_GUILD_SKILL"
  "RESET_PROFESSION"
  "RESET_SKILL";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ResetType_entries[] = {
  { {ResetType_names + 0, 17}, 2 },
  { {ResetType_names + 17, 16}, 1 },
  { {ResetType_names + 33, 11}, 0 },
};

static const int ResetType_entries_by_number[] = {
  2, // 0 -> RESET_SKILL
  1, // 1 -> RESET_PROFESSION
  0, // 2 -> RESET_GUILD_SKILL
};

const std::string& ResetType_Name(
    ResetType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ResetType_entries,
          ResetType_entries_by_number,
          3, ResetType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ResetType_entries,
      ResetType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ResetType_strings[idx].get();
}
bool ResetType_Parse(
    const std::string& name, ResetType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ResetType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<ResetType>(int_value);
  }
  return success;
}
bool LotteryType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LotteryType_strings[6] = {};

static const char LotteryType_names[] =
  "Sprite_Draw_One"
  "Sprite_Draw_One_Free"
  "Sprite_Draw_Ten"
  "Sprite_GoldDraw_One"
  "Sprite_GoldDraw_One_Free"
  "Sprite_GoldDraw_Ten";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LotteryType_entries[] = {
  { {LotteryType_names + 0, 15}, 1 },
  { {LotteryType_names + 15, 20}, 3 },
  { {LotteryType_names + 35, 15}, 2 },
  { {LotteryType_names + 50, 19}, 4 },
  { {LotteryType_names + 69, 24}, 6 },
  { {LotteryType_names + 93, 19}, 5 },
};

static const int LotteryType_entries_by_number[] = {
  0, // 1 -> Sprite_Draw_One
  2, // 2 -> Sprite_Draw_Ten
  1, // 3 -> Sprite_Draw_One_Free
  3, // 4 -> Sprite_GoldDraw_One
  5, // 5 -> Sprite_GoldDraw_Ten
  4, // 6 -> Sprite_GoldDraw_One_Free
};

const std::string& LotteryType_Name(
    LotteryType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          LotteryType_entries,
          LotteryType_entries_by_number,
          6, LotteryType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      LotteryType_entries,
      LotteryType_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     LotteryType_strings[idx].get();
}
bool LotteryType_Parse(
    const std::string& name, LotteryType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      LotteryType_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<LotteryType>(int_value);
  }
  return success;
}
bool EntityCategory_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> EntityCategory_strings[5] = {};

static const char EntityCategory_names[] =
  "Category_DummyRole"
  "Category_Enemy"
  "Category_Neutral"
  "Category_Others"
  "Category_Role";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry EntityCategory_entries[] = {
  { {EntityCategory_names + 0, 18}, 3 },
  { {EntityCategory_names + 18, 14}, 1 },
  { {EntityCategory_names + 32, 16}, 2 },
  { {EntityCategory_names + 48, 15}, 4 },
  { {EntityCategory_names + 63, 13}, 0 },
};

static const int EntityCategory_entries_by_number[] = {
  4, // 0 -> Category_Role
  1, // 1 -> Category_Enemy
  2, // 2 -> Category_Neutral
  0, // 3 -> Category_DummyRole
  3, // 4 -> Category_Others
};

const std::string& EntityCategory_Name(
    EntityCategory value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          EntityCategory_entries,
          EntityCategory_entries_by_number,
          5, EntityCategory_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      EntityCategory_entries,
      EntityCategory_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     EntityCategory_strings[idx].get();
}
bool EntityCategory_Parse(
    const std::string& name, EntityCategory* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      EntityCategory_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<EntityCategory>(int_value);
  }
  return success;
}
bool RankeType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> RankeType_strings[39] = {};

static const char RankeType_names[] =
  "ArenaRank"
  "BigMeleeRank"
  "BioHelllRank"
  "CompeteDragonRank"
  "CrossLeagueRank"
  "DEProgressRank"
  "FashionPowerPointRank"
  "FirstPassRank"
  "FlowerActivityRank"
  "FlowerRank"
  "FlowerThisWeekRank"
  "FlowerTotalRank"
  "FlowerYesterdayRank"
  "GuildBossRank"
  "GuildBossRoleRank"
  "HeroBattleRank"
  "LastWeek_HeroBattleRank"
  "LastWeek_LeagueTeamRank"
  "LastWeek_NestWeekRank"
  "LastWeek_PkRank"
  "LeagueTeamRank"
  "LevelRank"
  "MilitaryRank"
  "NestWeekRank"
  "PetPowerPointRank"
  "PkRank"
  "PkRank2v2"
  "PkRealTimeRank"
  "PowerPointRank"
  "RealTimeArenaRank"
  "SkyCityRank"
  "SkyCraftRank"
  "SpritePowerPointRank"
  "SurviveRank"
  "TShowVoteCountRank"
  "TowerRank"
  "WorldBossDamageRank"
  "WorldBossGuildRank"
  "WorldBossGuildRoleRank";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry RankeType_entries[] = {
  { {RankeType_names + 0, 9}, 1 },
  { {RankeType_names + 9, 12}, 33 },
  { {RankeType_names + 21, 12}, 34 },
  { {RankeType_names + 33, 17}, 35 },
  { {RankeType_names + 50, 15}, 23 },
  { {RankeType_names + 65, 14}, 17 },
  { {RankeType_names + 79, 21}, 11 },
  { {RankeType_names + 100, 13}, 16 },
  { {RankeType_names + 113, 18}, 32 },
  { {RankeType_names + 131, 10}, 6 },
  { {RankeType_names + 141, 18}, 20 },
  { {RankeType_names + 159, 15}, 15 },
  { {RankeType_names + 174, 19}, 14 },
  { {RankeType_names + 193, 13}, 7 },
  { {RankeType_names + 206, 17}, 8 },
  { {RankeType_names + 223, 14}, 24 },
  { {RankeType_names + 237, 23}, 28 },
  { {RankeType_names + 260, 23}, 29 },
  { {RankeType_names + 283, 21}, 27 },
  { {RankeType_names + 304, 15}, 26 },
  { {RankeType_names + 319, 14}, 22 },
  { {RankeType_names + 333, 9}, 5 },
  { {RankeType_names + 342, 12}, 25 },
  { {RankeType_names + 354, 12}, 21 },
  { {RankeType_names + 366, 17}, 19 },
  { {RankeType_names + 383, 6}, 10 },
  { {RankeType_names + 389, 9}, 31 },
  { {RankeType_names + 398, 14}, 9 },
  { {RankeType_names + 412, 14}, 4 },
  { {RankeType_names + 426, 17}, 0 },
  { {RankeType_names + 443, 11}, 37 },
  { {RankeType_names + 454, 12}, 30 },
  { {RankeType_names + 466, 20}, 18 },
  { {RankeType_names + 486, 11}, 36 },
  { {RankeType_names + 497, 18}, 12 },
  { {RankeType_names + 515, 9}, 13 },
  { {RankeType_names + 524, 19}, 3 },
  { {RankeType_names + 543, 18}, 2 },
  { {RankeType_names + 561, 22}, 38 },
};

static const int RankeType_entries_by_number[] = {
  29, // 0 -> RealTimeArenaRank
  0, // 1 -> ArenaRank
  37, // 2 -> WorldBossGuildRank
  36, // 3 -> WorldBossDamageRank
  28, // 4 -> PowerPointRank
  21, // 5 -> LevelRank
  9, // 6 -> FlowerRank
  13, // 7 -> GuildBossRank
  14, // 8 -> GuildBossRoleRank
  27, // 9 -> PkRealTimeRank
  25, // 10 -> PkRank
  6, // 11 -> FashionPowerPointRank
  34, // 12 -> TShowVoteCountRank
  35, // 13 -> TowerRank
  12, // 14 -> FlowerYesterdayRank
  11, // 15 -> FlowerTotalRank
  7, // 16 -> FirstPassRank
  5, // 17 -> DEProgressRank
  32, // 18 -> SpritePowerPointRank
  24, // 19 -> PetPowerPointRank
  10, // 20 -> FlowerThisWeekRank
  23, // 21 -> NestWeekRank
  20, // 22 -> LeagueTeamRank
  4, // 23 -> CrossLeagueRank
  15, // 24 -> HeroBattleRank
  22, // 25 -> MilitaryRank
  19, // 26 -> LastWeek_PkRank
  18, // 27 -> LastWeek_NestWeekRank
  16, // 28 -> LastWeek_HeroBattleRank
  17, // 29 -> LastWeek_LeagueTeamRank
  31, // 30 -> SkyCraftRank
  26, // 31 -> PkRank2v2
  8, // 32 -> FlowerActivityRank
  1, // 33 -> BigMeleeRank
  2, // 34 -> BioHelllRank
  3, // 35 -> CompeteDragonRank
  33, // 36 -> SurviveRank
  30, // 37 -> SkyCityRank
  38, // 38 -> WorldBossGuildRoleRank
};

const std::string& RankeType_Name(
    RankeType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          RankeType_entries,
          RankeType_entries_by_number,
          39, RankeType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      RankeType_entries,
      RankeType_entries_by_number,
      39, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     RankeType_strings[idx].get();
}
bool RankeType_Parse(
    const std::string& name, RankeType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      RankeType_entries, 39, name, &int_value);
  if (success) {
    *value = static_cast<RankeType>(int_value);
  }
  return success;
}
bool MythShopOP_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> MythShopOP_strings[3] = {};

static const char MythShopOP_names[] =
  "MythShopBuy"
  "MythShopQuery"
  "MythShopRefresh";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry MythShopOP_entries[] = {
  { {MythShopOP_names + 0, 11}, 2 },
  { {MythShopOP_names + 11, 13}, 1 },
  { {MythShopOP_names + 24, 15}, 3 },
};

static const int MythShopOP_entries_by_number[] = {
  1, // 1 -> MythShopQuery
  0, // 2 -> MythShopBuy
  2, // 3 -> MythShopRefresh
};

const std::string& MythShopOP_Name(
    MythShopOP value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          MythShopOP_entries,
          MythShopOP_entries_by_number,
          3, MythShopOP_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      MythShopOP_entries,
      MythShopOP_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     MythShopOP_strings[idx].get();
}
bool MythShopOP_Parse(
    const std::string& name, MythShopOP* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      MythShopOP_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<MythShopOP>(int_value);
  }
  return success;
}
bool SystemRewardType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 101:
    case 102:
    case 103:
    case 104:
    case 105:
    case 106:
    case 107:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SystemRewardType_strings[15] = {};

static const char SystemRewardType_names[] =
  "RewardArena"
  "RewardArenaUp"
  "RewardChargeFirst"
  "RewardDegree"
  "RewardDinner"
  "RewardFashionPowerRank"
  "RewardGM"
  "RewardGuildBoss"
  "RewardGuildBossRole"
  "RewardMakeUp"
  "RewardMonthCard"
  "RewardPk"
  "RewardSupper"
  "RewardVip"
  "RewardWorldBoss";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SystemRewardType_entries[] = {
  { {SystemRewardType_names + 0, 11}, 3 },
  { {SystemRewardType_names + 11, 13}, 104 },
  { {SystemRewardType_names + 24, 17}, 5 },
  { {SystemRewardType_names + 41, 12}, 106 },
  { {SystemRewardType_names + 53, 12}, 1 },
  { {SystemRewardType_names + 65, 22}, 107 },
  { {SystemRewardType_names + 87, 8}, 105 },
  { {SystemRewardType_names + 95, 15}, 6 },
  { {SystemRewardType_names + 110, 19}, 7 },
  { {SystemRewardType_names + 129, 12}, 103 },
  { {SystemRewardType_names + 141, 15}, 102 },
  { {SystemRewardType_names + 156, 8}, 8 },
  { {SystemRewardType_names + 164, 12}, 2 },
  { {SystemRewardType_names + 176, 9}, 101 },
  { {SystemRewardType_names + 185, 15}, 4 },
};

static const int SystemRewardType_entries_by_number[] = {
  4, // 1 -> RewardDinner
  12, // 2 -> RewardSupper
  0, // 3 -> RewardArena
  14, // 4 -> RewardWorldBoss
  2, // 5 -> RewardChargeFirst
  7, // 6 -> RewardGuildBoss
  8, // 7 -> RewardGuildBossRole
  11, // 8 -> RewardPk
  13, // 101 -> RewardVip
  10, // 102 -> RewardMonthCard
  9, // 103 -> RewardMakeUp
  1, // 104 -> RewardArenaUp
  6, // 105 -> RewardGM
  3, // 106 -> RewardDegree
  5, // 107 -> RewardFashionPowerRank
};

const std::string& SystemRewardType_Name(
    SystemRewardType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SystemRewardType_entries,
          SystemRewardType_entries_by_number,
          15, SystemRewardType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SystemRewardType_entries,
      SystemRewardType_entries_by_number,
      15, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SystemRewardType_strings[idx].get();
}
bool SystemRewardType_Parse(
    const std::string& name, SystemRewardType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SystemRewardType_entries, 15, name, &int_value);
  if (success) {
    *value = static_cast<SystemRewardType>(int_value);
  }
  return success;
}
bool TeamState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TeamState_strings[4] = {};

static const char TeamState_names[] =
  "TEAM_IN_BATTLE"
  "TEAM_MATCH"
  "TEAM_VOTE"
  "TEAM_WAITING";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TeamState_entries[] = {
  { {TeamState_names + 0, 14}, 1 },
  { {TeamState_names + 14, 10}, 3 },
  { {TeamState_names + 24, 9}, 2 },
  { {TeamState_names + 33, 12}, 0 },
};

static const int TeamState_entries_by_number[] = {
  3, // 0 -> TEAM_WAITING
  0, // 1 -> TEAM_IN_BATTLE
  2, // 2 -> TEAM_VOTE
  1, // 3 -> TEAM_MATCH
};

const std::string& TeamState_Name(
    TeamState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TeamState_entries,
          TeamState_entries_by_number,
          4, TeamState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TeamState_entries,
      TeamState_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TeamState_strings[idx].get();
}
bool TeamState_Parse(
    const std::string& name, TeamState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TeamState_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<TeamState>(int_value);
  }
  return success;
}
bool TeamOperate_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TeamOperate_strings[25] = {};

static const char TeamOperate_names[] =
  "TEAM_BATTLE_CONTINUE"
  "TEAM_BE_HELPER"
  "TEAM_CHANGE_EPXTEAMID"
  "TEAM_CHANGE_PASSWORD"
  "TEAM_COSTTYPE"
  "TEAM_CREATE"
  "TEAM_DOWN_MATCH"
  "TEAM_GET_FULL_DATA"
  "TEAM_INVITE"
  "TEAM_JOIN"
  "TEAM_KICK"
  "TEAM_LEAVE"
  "TEAM_MEMBER_TYPE"
  "TEAM_PPTLIMIT"
  "TEAM_QUERYCOUNT"
  "TEAM_QUIT_HELPER"
  "TEAM_START_BATTLE"
  "TEAM_START_BATTLE_AGREE"
  "TEAM_START_BATTLE_DISAGREE"
  "TEAM_START_BATTLE_REMOVE_DISAGREE_MEMBER"
  "TEAM_START_MATCH"
  "TEAM_STOP_MATCH"
  "TEAM_TOGGLE_READY"
  "TEAM_TRAHS_LEADER"
  "TEAM_USE_TICKET";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TeamOperate_entries[] = {
  { {TeamOperate_names + 0, 20}, 23 },
  { {TeamOperate_names + 20, 14}, 17 },
  { {TeamOperate_names + 34, 21}, 10 },
  { {TeamOperate_names + 55, 20}, 21 },
  { {TeamOperate_names + 75, 13}, 20 },
  { {TeamOperate_names + 88, 11}, 1 },
  { {TeamOperate_names + 99, 15}, 16 },
  { {TeamOperate_names + 114, 18}, 15 },
  { {TeamOperate_names + 132, 11}, 12 },
  { {TeamOperate_names + 143, 9}, 2 },
  { {TeamOperate_names + 152, 9}, 6 },
  { {TeamOperate_names + 161, 10}, 3 },
  { {TeamOperate_names + 171, 16}, 25 },
  { {TeamOperate_names + 187, 13}, 19 },
  { {TeamOperate_names + 200, 15}, 5 },
  { {TeamOperate_names + 215, 16}, 18 },
  { {TeamOperate_names + 231, 17}, 7 },
  { {TeamOperate_names + 248, 23}, 8 },
  { {TeamOperate_names + 271, 26}, 9 },
  { {TeamOperate_names + 297, 40}, 11 },
  { {TeamOperate_names + 337, 16}, 13 },
  { {TeamOperate_names + 353, 15}, 14 },
  { {TeamOperate_names + 368, 17}, 4 },
  { {TeamOperate_names + 385, 17}, 22 },
  { {TeamOperate_names + 402, 15}, 24 },
};

static const int TeamOperate_entries_by_number[] = {
  5, // 1 -> TEAM_CREATE
  9, // 2 -> TEAM_JOIN
  11, // 3 -> TEAM_LEAVE
  22, // 4 -> TEAM_TOGGLE_READY
  14, // 5 -> TEAM_QUERYCOUNT
  10, // 6 -> TEAM_KICK
  16, // 7 -> TEAM_START_BATTLE
  17, // 8 -> TEAM_START_BATTLE_AGREE
  18, // 9 -> TEAM_START_BATTLE_DISAGREE
  2, // 10 -> TEAM_CHANGE_EPXTEAMID
  19, // 11 -> TEAM_START_BATTLE_REMOVE_DISAGREE_MEMBER
  8, // 12 -> TEAM_INVITE
  20, // 13 -> TEAM_START_MATCH
  21, // 14 -> TEAM_STOP_MATCH
  7, // 15 -> TEAM_GET_FULL_DATA
  6, // 16 -> TEAM_DOWN_MATCH
  1, // 17 -> TEAM_BE_HELPER
  15, // 18 -> TEAM_QUIT_HELPER
  13, // 19 -> TEAM_PPTLIMIT
  4, // 20 -> TEAM_COSTTYPE
  3, // 21 -> TEAM_CHANGE_PASSWORD
  23, // 22 -> TEAM_TRAHS_LEADER
  0, // 23 -> TEAM_BATTLE_CONTINUE
  24, // 24 -> TEAM_USE_TICKET
  12, // 25 -> TEAM_MEMBER_TYPE
};

const std::string& TeamOperate_Name(
    TeamOperate value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TeamOperate_entries,
          TeamOperate_entries_by_number,
          25, TeamOperate_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TeamOperate_entries,
      TeamOperate_entries_by_number,
      25, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TeamOperate_strings[idx].get();
}
bool TeamOperate_Parse(
    const std::string& name, TeamOperate* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TeamOperate_entries, 25, name, &int_value);
  if (success) {
    *value = static_cast<TeamOperate>(int_value);
  }
  return success;
}
bool ExpTeamMemberState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ExpTeamMemberState_strings[4] = {};

static const char ExpTeamMemberState_names[] =
  "EXPTEAM_DISAGREE"
  "EXPTEAM_FINISH"
  "EXPTEAM_IDLE"
  "EXPTEAM_READY";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ExpTeamMemberState_entries[] = {
  { {ExpTeamMemberState_names + 0, 16}, 2 },
  { {ExpTeamMemberState_names + 16, 14}, 3 },
  { {ExpTeamMemberState_names + 30, 12}, 0 },
  { {ExpTeamMemberState_names + 42, 13}, 1 },
};

static const int ExpTeamMemberState_entries_by_number[] = {
  2, // 0 -> EXPTEAM_IDLE
  3, // 1 -> EXPTEAM_READY
  0, // 2 -> EXPTEAM_DISAGREE
  1, // 3 -> EXPTEAM_FINISH
};

const std::string& ExpTeamMemberState_Name(
    ExpTeamMemberState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ExpTeamMemberState_entries,
          ExpTeamMemberState_entries_by_number,
          4, ExpTeamMemberState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ExpTeamMemberState_entries,
      ExpTeamMemberState_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ExpTeamMemberState_strings[idx].get();
}
bool ExpTeamMemberState_Parse(
    const std::string& name, ExpTeamMemberState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ExpTeamMemberState_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<ExpTeamMemberState>(int_value);
  }
  return success;
}
bool UnitAppearanceField_IsValid(int value) {
  switch (value) {
    case 15:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 16384:
    case 32768:
    case 524288:
    case 8388608:
    case 16777216:
    case 33554432:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> UnitAppearanceField_strings[14] = {};

static const char UnitAppearanceField_names[] =
  "UNIT_ARTIFACT"
  "UNIT_ATTR"
  "UNIT_BASIC"
  "UNIT_EMBLEM"
  "UNIT_EQUIP"
  "UNIT_FASHION"
  "UNIT_GUILD"
  "UNIT_PETS"
  "UNIT_SKILL"
  "UNIT_SPRITE"
  "UNIT_SPRITELEADER"
  "UNIT_TIMELOGIN"
  "UNIT_TITLE"
  "UNIT_VIPLEVEL";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry UnitAppearanceField_entries[] = {
  { {UnitAppearanceField_names + 0, 13}, 32768 },
  { {UnitAppearanceField_names + 13, 9}, 32 },
  { {UnitAppearanceField_names + 22, 10}, 15 },
  { {UnitAppearanceField_names + 32, 11}, 512 },
  { {UnitAppearanceField_names + 43, 10}, 128 },
  { {UnitAppearanceField_names + 53, 12}, 64 },
  { {UnitAppearanceField_names + 65, 10}, 16384 },
  { {UnitAppearanceField_names + 75, 9}, 33554432 },
  { {UnitAppearanceField_names + 84, 10}, 256 },
  { {UnitAppearanceField_names + 94, 11}, 16777216 },
  { {UnitAppearanceField_names + 105, 17}, 8388608 },
  { {UnitAppearanceField_names + 122, 14}, 2048 },
  { {UnitAppearanceField_names + 136, 10}, 524288 },
  { {UnitAppearanceField_names + 146, 13}, 1024 },
};

static const int UnitAppearanceField_entries_by_number[] = {
  2, // 15 -> UNIT_BASIC
  1, // 32 -> UNIT_ATTR
  5, // 64 -> UNIT_FASHION
  4, // 128 -> UNIT_EQUIP
  8, // 256 -> UNIT_SKILL
  3, // 512 -> UNIT_EMBLEM
  13, // 1024 -> UNIT_VIPLEVEL
  11, // 2048 -> UNIT_TIMELOGIN
  6, // 16384 -> UNIT_GUILD
  0, // 32768 -> UNIT_ARTIFACT
  12, // 524288 -> UNIT_TITLE
  10, // 8388608 -> UNIT_SPRITELEADER
  9, // 16777216 -> UNIT_SPRITE
  7, // 33554432 -> UNIT_PETS
};

const std::string& UnitAppearanceField_Name(
    UnitAppearanceField value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          UnitAppearanceField_entries,
          UnitAppearanceField_entries_by_number,
          14, UnitAppearanceField_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      UnitAppearanceField_entries,
      UnitAppearanceField_entries_by_number,
      14, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     UnitAppearanceField_strings[idx].get();
}
bool UnitAppearanceField_Parse(
    const std::string& name, UnitAppearanceField* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      UnitAppearanceField_entries, 14, name, &int_value);
  if (success) {
    *value = static_cast<UnitAppearanceField>(int_value);
  }
  return success;
}
bool ChatChannel_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ChatChannel_strings[14] = {};

static const char ChatChannel_names[] =
  "AudioChannel"
  "BattleChannel"
  "CampChannel"
  "CurrentChannel"
  "GroupChatChannel"
  "GuildChannel"
  "LampLongChannel"
  "LampShortChannel"
  "PartnerChannel"
  "PrivateChannel"
  "SpectateChannel"
  "SystemChannel"
  "TeamChannel"
  "WorldChannel";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ChatChannel_entries[] = {
  { {ChatChannel_names + 0, 12}, 12 },
  { {ChatChannel_names + 12, 13}, 13 },
  { {ChatChannel_names + 25, 11}, 8 },
  { {ChatChannel_names + 36, 14}, 10 },
  { {ChatChannel_names + 50, 16}, 14 },
  { {ChatChannel_names + 66, 12}, 2 },
  { {ChatChannel_names + 78, 15}, 6 },
  { {ChatChannel_names + 93, 16}, 5 },
  { {ChatChannel_names + 109, 14}, 11 },
  { {ChatChannel_names + 123, 14}, 3 },
  { {ChatChannel_names + 137, 15}, 9 },
  { {ChatChannel_names + 152, 13}, 4 },
  { {ChatChannel_names + 165, 11}, 7 },
  { {ChatChannel_names + 176, 12}, 1 },
};

static const int ChatChannel_entries_by_number[] = {
  13, // 1 -> WorldChannel
  5, // 2 -> GuildChannel
  9, // 3 -> PrivateChannel
  11, // 4 -> SystemChannel
  7, // 5 -> LampShortChannel
  6, // 6 -> LampLongChannel
  12, // 7 -> TeamChannel
  2, // 8 -> CampChannel
  10, // 9 -> SpectateChannel
  3, // 10 -> CurrentChannel
  8, // 11 -> PartnerChannel
  0, // 12 -> AudioChannel
  1, // 13 -> BattleChannel
  4, // 14 -> GroupChatChannel
};

const std::string& ChatChannel_Name(
    ChatChannel value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ChatChannel_entries,
          ChatChannel_entries_by_number,
          14, ChatChannel_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ChatChannel_entries,
      ChatChannel_entries_by_number,
      14, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ChatChannel_strings[idx].get();
}
bool ChatChannel_Parse(
    const std::string& name, ChatChannel* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ChatChannel_entries, 14, name, &int_value);
  if (success) {
    *value = static_cast<ChatChannel>(int_value);
  }
  return success;
}
bool LoginType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LoginType_strings[6] = {};

static const char LoginType_names[] =
  "LGOIN_WECHAT_PF"
  "LOGIN_IOS_AUDIT"
  "LOGIN_IOS_GUEST"
  "LOGIN_PASSWORD"
  "LOGIN_QQ_PF"
  "LOGIN_SNDA_PF";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LoginType_entries[] = {
  { {LoginType_names + 0, 15}, 3 },
  { {LoginType_names + 15, 15}, 5 },
  { {LoginType_names + 30, 15}, 4 },
  { {LoginType_names + 45, 14}, 0 },
  { {LoginType_names + 59, 11}, 2 },
  { {LoginType_names + 70, 13}, 1 },
};

static const int LoginType_entries_by_number[] = {
  3, // 0 -> LOGIN_PASSWORD
  5, // 1 -> LOGIN_SNDA_PF
  4, // 2 -> LOGIN_QQ_PF
  0, // 3 -> LGOIN_WECHAT_PF
  2, // 4 -> LOGIN_IOS_GUEST
  1, // 5 -> LOGIN_IOS_AUDIT
};

const std::string& LoginType_Name(
    LoginType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          LoginType_entries,
          LoginType_entries_by_number,
          6, LoginType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      LoginType_entries,
      LoginType_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     LoginType_strings[idx].get();
}
bool LoginType_Parse(
    const std::string& name, LoginType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      LoginType_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<LoginType>(int_value);
  }
  return success;
}
bool FashionNTFType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> FashionNTFType_strings[5] = {};

static const char FashionNTFType_names[] =
  "ADD_FASHION"
  "DELBAG_FASHION"
  "DELBODY_FASHION"
  "UPGRADE_FASHION"
  "WEAR_FASHION";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry FashionNTFType_entries[] = {
  { {FashionNTFType_names + 0, 11}, 1 },
  { {FashionNTFType_names + 11, 14}, 5 },
  { {FashionNTFType_names + 25, 15}, 4 },
  { {FashionNTFType_names + 40, 15}, 2 },
  { {FashionNTFType_names + 55, 12}, 3 },
};

static const int FashionNTFType_entries_by_number[] = {
  0, // 1 -> ADD_FASHION
  3, // 2 -> UPGRADE_FASHION
  4, // 3 -> WEAR_FASHION
  2, // 4 -> DELBODY_FASHION
  1, // 5 -> DELBAG_FASHION
};

const std::string& FashionNTFType_Name(
    FashionNTFType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          FashionNTFType_entries,
          FashionNTFType_entries_by_number,
          5, FashionNTFType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      FashionNTFType_entries,
      FashionNTFType_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     FashionNTFType_strings[idx].get();
}
bool FashionNTFType_Parse(
    const std::string& name, FashionNTFType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      FashionNTFType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<FashionNTFType>(int_value);
  }
  return success;
}
bool GuildSortType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GuildSortType_strings[5] = {};

static const char GuildSortType_names[] =
  "GuildSortByExp"
  "GuildSortByLevel"
  "GuildSortByMemberCount"
  "GuildSortByName"
  "GuildSortByPrestige";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GuildSortType_entries[] = {
  { {GuildSortType_names + 0, 14}, 4 },
  { {GuildSortType_names + 14, 16}, 1 },
  { {GuildSortType_names + 30, 22}, 2 },
  { {GuildSortType_names + 52, 15}, 3 },
  { {GuildSortType_names + 67, 19}, 5 },
};

static const int GuildSortType_entries_by_number[] = {
  1, // 1 -> GuildSortByLevel
  2, // 2 -> GuildSortByMemberCount
  3, // 3 -> GuildSortByName
  0, // 4 -> GuildSortByExp
  4, // 5 -> GuildSortByPrestige
};

const std::string& GuildSortType_Name(
    GuildSortType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GuildSortType_entries,
          GuildSortType_entries_by_number,
          5, GuildSortType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GuildSortType_entries,
      GuildSortType_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GuildSortType_strings[idx].get();
}
bool GuildSortType_Parse(
    const std::string& name, GuildSortType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GuildSortType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<GuildSortType>(int_value);
  }
  return success;
}
bool GuildMemberFlag_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 4:
    case 8:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GuildMemberFlag_strings[4] = {};

static const char GuildMemberFlag_names[] =
  "ONLINE"
  "RECVED_FATIGUE"
  "RECV_FATIGUE"
  "SEND_FATIGUE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GuildMemberFlag_entries[] = {
  { {GuildMemberFlag_names + 0, 6}, 8 },
  { {GuildMemberFlag_names + 6, 14}, 4 },
  { {GuildMemberFlag_names + 20, 12}, 2 },
  { {GuildMemberFlag_names + 32, 12}, 1 },
};

static const int GuildMemberFlag_entries_by_number[] = {
  3, // 1 -> SEND_FATIGUE
  2, // 2 -> RECV_FATIGUE
  1, // 4 -> RECVED_FATIGUE
  0, // 8 -> ONLINE
};

const std::string& GuildMemberFlag_Name(
    GuildMemberFlag value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GuildMemberFlag_entries,
          GuildMemberFlag_entries_by_number,
          4, GuildMemberFlag_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GuildMemberFlag_entries,
      GuildMemberFlag_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GuildMemberFlag_strings[idx].get();
}
bool GuildMemberFlag_Parse(
    const std::string& name, GuildMemberFlag* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GuildMemberFlag_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<GuildMemberFlag>(int_value);
  }
  return success;
}
bool GuildLogType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GuildLogType_strings[3] = {};

static const char GuildLogType_names[] =
  "GLog_CheckIn"
  "GLog_Member"
  "GLog_RedBonus";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GuildLogType_entries[] = {
  { {GuildLogType_names + 0, 12}, 2 },
  { {GuildLogType_names + 12, 11}, 1 },
  { {GuildLogType_names + 23, 13}, 3 },
};

static const int GuildLogType_entries_by_number[] = {
  1, // 1 -> GLog_Member
  0, // 2 -> GLog_CheckIn
  2, // 3 -> GLog_RedBonus
};

const std::string& GuildLogType_Name(
    GuildLogType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GuildLogType_entries,
          GuildLogType_entries_by_number,
          3, GuildLogType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GuildLogType_entries,
      GuildLogType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GuildLogType_strings[idx].get();
}
bool GuildLogType_Parse(
    const std::string& name, GuildLogType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GuildLogType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<GuildLogType>(int_value);
  }
  return success;
}
bool GuildLogEnum_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GuildLogEnum_strings[10] = {};

static const char GuildLogEnum_names[] =
  "GUILDLOG_CHECKIN_END"
  "GUILDLOG_CHECKIN_START"
  "GUILDLOG_MEMBER_END"
  "GUILDLOG_MEMBER_START"
  "GUILDLOG_REDBONUS_END"
  "GUILDLOG_REDBONUS_START"
  "GuildLog_BossDps"
  "GuildLog_ChangePosition"
  "GuildLog_Join"
  "GuildLog_Leave";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GuildLogEnum_entries[] = {
  { {GuildLogEnum_names + 0, 20}, 6 },
  { {GuildLogEnum_names + 20, 22}, 5 },
  { {GuildLogEnum_names + 42, 19}, 4 },
  { {GuildLogEnum_names + 61, 21}, 0 },
  { {GuildLogEnum_names + 82, 21}, 8 },
  { {GuildLogEnum_names + 103, 23}, 7 },
  { {GuildLogEnum_names + 126, 16}, 9 },
  { {GuildLogEnum_names + 142, 23}, 3 },
  { {GuildLogEnum_names + 165, 13}, 1 },
  { {GuildLogEnum_names + 178, 14}, 2 },
};

static const int GuildLogEnum_entries_by_number[] = {
  3, // 0 -> GUILDLOG_MEMBER_START
  8, // 1 -> GuildLog_Join
  9, // 2 -> GuildLog_Leave
  7, // 3 -> GuildLog_ChangePosition
  2, // 4 -> GUILDLOG_MEMBER_END
  1, // 5 -> GUILDLOG_CHECKIN_START
  0, // 6 -> GUILDLOG_CHECKIN_END
  5, // 7 -> GUILDLOG_REDBONUS_START
  4, // 8 -> GUILDLOG_REDBONUS_END
  6, // 9 -> GuildLog_BossDps
};

const std::string& GuildLogEnum_Name(
    GuildLogEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GuildLogEnum_entries,
          GuildLogEnum_entries_by_number,
          10, GuildLogEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GuildLogEnum_entries,
      GuildLogEnum_entries_by_number,
      10, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GuildLogEnum_strings[idx].get();
}
bool GuildLogEnum_Parse(
    const std::string& name, GuildLogEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GuildLogEnum_entries, 10, name, &int_value);
  if (success) {
    *value = static_cast<GuildLogEnum>(int_value);
  }
  return success;
}
bool GuildBonusType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GuildBonusType_strings[28] = {};

static const char GuildBonusType_names[] =
  "GBONUS_BOSSRUSH"
  "GBONUS_BUYIBSHOP"
  "GBONUS_CARDREWARD"
  "GBONUS_CHARGEPRIVILEGE"
  "GBONUS_CHARGETIMES"
  "GBONUS_CHECKIN"
  "GBONUS_DRAGONJADEL_ALLLEVEL"
  "GBONUS_DRAGONNEST_SCENE"
  "GBONUS_DRAWLOTTERY_TEN"
  "GBONUS_GMF_RANK"
  "GBONUS_GUILDGOBLIN"
  "GBONUS_GUILDGOBLIN_LEVELUP"
  "GBONUS_HORSE_QUALITY"
  "GBONUS_KILLDRAGON"
  "GBONUS_KILLSTAGEDRAGON"
  "GBONUS_LEVELUP"
  "GBONUS_MAX"
  "GBONUS_MAYHEMRANK"
  "GBONUS_PURCHASEFUND"
  "GBONUS_SKYARENA_FLOOR"
  "GBONUS_STRENGTHEN"
  "GBONUS_TIANTIRANK"
  "GBONUS_TIMEBONUS"
  "GBONUS_TITLE"
  "GBONUS_TOWER"
  "GBONUS_USEITEM"
  "GBONUS_USETHREESUIT"
  "GBONUS_VIPLEVEL";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GuildBonusType_entries[] = {
  { {GuildBonusType_names + 0, 15}, 23 },
  { {GuildBonusType_names + 15, 16}, 24 },
  { {GuildBonusType_names + 31, 17}, 2 },
  { {GuildBonusType_names + 48, 22}, 16 },
  { {GuildBonusType_names + 70, 18}, 9 },
  { {GuildBonusType_names + 88, 14}, 6 },
  { {GuildBonusType_names + 102, 27}, 18 },
  { {GuildBonusType_names + 129, 23}, 21 },
  { {GuildBonusType_names + 152, 22}, 11 },
  { {GuildBonusType_names + 174, 15}, 22 },
  { {GuildBonusType_names + 189, 18}, 4 },
  { {GuildBonusType_names + 207, 26}, 5 },
  { {GuildBonusType_names + 233, 20}, 20 },
  { {GuildBonusType_names + 253, 17}, 3 },
  { {GuildBonusType_names + 270, 22}, 8 },
  { {GuildBonusType_names + 292, 14}, 1 },
  { {GuildBonusType_names + 306, 10}, 28 },
  { {GuildBonusType_names + 316, 17}, 25 },
  { {GuildBonusType_names + 333, 19}, 17 },
  { {GuildBonusType_names + 352, 21}, 19 },
  { {GuildBonusType_names + 373, 17}, 13 },
  { {GuildBonusType_names + 390, 17}, 7 },
  { {GuildBonusType_names + 407, 16}, 15 },
  { {GuildBonusType_names + 423, 12}, 12 },
  { {GuildBonusType_names + 435, 12}, 14 },
  { {GuildBonusType_names + 447, 14}, 27 },
  { {GuildBonusType_names + 461, 19}, 26 },
  { {GuildBonusType_names + 480, 15}, 10 },
};

static const int GuildBonusType_entries_by_number[] = {
  15, // 1 -> GBONUS_LEVELUP
  2, // 2 -> GBONUS_CARDREWARD
  13, // 3 -> GBONUS_KILLDRAGON
  10, // 4 -> GBONUS_GUILDGOBLIN
  11, // 5 -> GBONUS_GUILDGOBLIN_LEVELUP
  5, // 6 -> GBONUS_CHECKIN
  21, // 7 -> GBONUS_TIANTIRANK
  14, // 8 -> GBONUS_KILLSTAGEDRAGON
  4, // 9 -> GBONUS_CHARGETIMES
  27, // 10 -> GBONUS_VIPLEVEL
  8, // 11 -> GBONUS_DRAWLOTTERY_TEN
  23, // 12 -> GBONUS_TITLE
  20, // 13 -> GBONUS_STRENGTHEN
  24, // 14 -> GBONUS_TOWER
  22, // 15 -> GBONUS_TIMEBONUS
  3, // 16 -> GBONUS_CHARGEPRIVILEGE
  18, // 17 -> GBONUS_PURCHASEFUND
  6, // 18 -> GBONUS_DRAGONJADEL_ALLLEVEL
  19, // 19 -> GBONUS_SKYARENA_FLOOR
  12, // 20 -> GBONUS_HORSE_QUALITY
  7, // 21 -> GBONUS_DRAGONNEST_SCENE
  9, // 22 -> GBONUS_GMF_RANK
  0, // 23 -> GBONUS_BOSSRUSH
  1, // 24 -> GBONUS_BUYIBSHOP
  17, // 25 -> GBONUS_MAYHEMRANK
  26, // 26 -> GBONUS_USETHREESUIT
  25, // 27 -> GBONUS_USEITEM
  16, // 28 -> GBONUS_MAX
};

const std::string& GuildBonusType_Name(
    GuildBonusType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GuildBonusType_entries,
          GuildBonusType_entries_by_number,
          28, GuildBonusType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GuildBonusType_entries,
      GuildBonusType_entries_by_number,
      28, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GuildBonusType_strings[idx].get();
}
bool GuildBonusType_Parse(
    const std::string& name, GuildBonusType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GuildBonusType_entries, 28, name, &int_value);
  if (success) {
    *value = static_cast<GuildBonusType>(int_value);
  }
  return success;
}
bool BoxType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> BoxType_strings[5] = {};

static const char BoxType_names[] =
  "BOX_TYPE_COPPER"
  "BOX_TYPE_DIAMOND"
  "BOX_TYPE_GOLD"
  "BOX_TYPE_NONE"
  "BOX_TYPE_SILVER";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry BoxType_entries[] = {
  { {BoxType_names + 0, 15}, 1 },
  { {BoxType_names + 15, 16}, 4 },
  { {BoxType_names + 31, 13}, 3 },
  { {BoxType_names + 44, 13}, 0 },
  { {BoxType_names + 57, 15}, 2 },
};

static const int BoxType_entries_by_number[] = {
  3, // 0 -> BOX_TYPE_NONE
  0, // 1 -> BOX_TYPE_COPPER
  4, // 2 -> BOX_TYPE_SILVER
  2, // 3 -> BOX_TYPE_GOLD
  1, // 4 -> BOX_TYPE_DIAMOND
};

const std::string& BoxType_Name(
    BoxType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          BoxType_entries,
          BoxType_entries_by_number,
          5, BoxType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      BoxType_entries,
      BoxType_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     BoxType_strings[idx].get();
}
bool BoxType_Parse(
    const std::string& name, BoxType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      BoxType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<BoxType>(int_value);
  }
  return success;
}
bool FightGroupType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 10:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> FightGroupType_strings[5] = {};

static const char FightGroupType_names[] =
  "FightDummy"
  "FightEnemy"
  "FightHostility"
  "FightNeutral"
  "FightRole";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry FightGroupType_entries[] = {
  { {FightGroupType_names + 0, 10}, 10 },
  { {FightGroupType_names + 10, 10}, 0 },
  { {FightGroupType_names + 20, 14}, 3 },
  { {FightGroupType_names + 34, 12}, 2 },
  { {FightGroupType_names + 46, 9}, 1 },
};

static const int FightGroupType_entries_by_number[] = {
  1, // 0 -> FightEnemy
  4, // 1 -> FightRole
  3, // 2 -> FightNeutral
  2, // 3 -> FightHostility
  0, // 10 -> FightDummy
};

const std::string& FightGroupType_Name(
    FightGroupType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          FightGroupType_entries,
          FightGroupType_entries_by_number,
          5, FightGroupType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      FightGroupType_entries,
      FightGroupType_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     FightGroupType_strings[idx].get();
}
bool FightGroupType_Parse(
    const std::string& name, FightGroupType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      FightGroupType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<FightGroupType>(int_value);
  }
  return success;
}
bool XQTEState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> XQTEState_strings[13] = {};

static const char XQTEState_names[] =
  "QTE_HitBackGetUp"
  "QTE_HitBackPresent"
  "QTE_HitBackStraight"
  "QTE_HitFlyBounce"
  "QTE_HitFlyGetUp"
  "QTE_HitFlyLand"
  "QTE_HitFlyPresent"
  "QTE_HitFlyStraight"
  "QTE_HitFreeze"
  "QTE_HitRollGetUp"
  "QTE_HitRollPresent"
  "QTE_HitRollStraight"
  "QTE_None";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry XQTEState_entries[] = {
  { {XQTEState_names + 0, 16}, 3 },
  { {XQTEState_names + 16, 18}, 1 },
  { {XQTEState_names + 34, 19}, 2 },
  { {XQTEState_names + 53, 16}, 6 },
  { {XQTEState_names + 69, 15}, 8 },
  { {XQTEState_names + 84, 14}, 5 },
  { {XQTEState_names + 98, 17}, 4 },
  { {XQTEState_names + 115, 18}, 7 },
  { {XQTEState_names + 133, 13}, 12 },
  { {XQTEState_names + 146, 16}, 11 },
  { {XQTEState_names + 162, 18}, 9 },
  { {XQTEState_names + 180, 19}, 10 },
  { {XQTEState_names + 199, 8}, 0 },
};

static const int XQTEState_entries_by_number[] = {
  12, // 0 -> QTE_None
  1, // 1 -> QTE_HitBackPresent
  2, // 2 -> QTE_HitBackStraight
  0, // 3 -> QTE_HitBackGetUp
  6, // 4 -> QTE_HitFlyPresent
  5, // 5 -> QTE_HitFlyLand
  3, // 6 -> QTE_HitFlyBounce
  7, // 7 -> QTE_HitFlyStraight
  4, // 8 -> QTE_HitFlyGetUp
  10, // 9 -> QTE_HitRollPresent
  11, // 10 -> QTE_HitRollStraight
  9, // 11 -> QTE_HitRollGetUp
  8, // 12 -> QTE_HitFreeze
};

const std::string& XQTEState_Name(
    XQTEState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          XQTEState_entries,
          XQTEState_entries_by_number,
          13, XQTEState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      XQTEState_entries,
      XQTEState_entries_by_number,
      13, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     XQTEState_strings[idx].get();
}
bool XQTEState_Parse(
    const std::string& name, XQTEState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      XQTEState_entries, 13, name, &int_value);
  if (success) {
    *value = static_cast<XQTEState>(int_value);
  }
  return success;
}
bool SceneFinishState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SceneFinishState_strings[6] = {};

static const char SceneFinishState_names[] =
  "SCENE_FINISH_DRAW_BOX"
  "SCENE_FINISH_END"
  "SCENE_FINISH_NONE"
  "SCENE_FINISH_PICK_ITEM"
  "SCENE_FINISH_SHOWRESULT"
  "SCENE_FINISH_START";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SceneFinishState_entries[] = {
  { {SceneFinishState_names + 0, 21}, 4 },
  { {SceneFinishState_names + 21, 16}, 5 },
  { {SceneFinishState_names + 37, 17}, 0 },
  { {SceneFinishState_names + 54, 22}, 2 },
  { {SceneFinishState_names + 76, 23}, 3 },
  { {SceneFinishState_names + 99, 18}, 1 },
};

static const int SceneFinishState_entries_by_number[] = {
  2, // 0 -> SCENE_FINISH_NONE
  5, // 1 -> SCENE_FINISH_START
  3, // 2 -> SCENE_FINISH_PICK_ITEM
  4, // 3 -> SCENE_FINISH_SHOWRESULT
  0, // 4 -> SCENE_FINISH_DRAW_BOX
  1, // 5 -> SCENE_FINISH_END
};

const std::string& SceneFinishState_Name(
    SceneFinishState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SceneFinishState_entries,
          SceneFinishState_entries_by_number,
          6, SceneFinishState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SceneFinishState_entries,
      SceneFinishState_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SceneFinishState_strings[idx].get();
}
bool SceneFinishState_Parse(
    const std::string& name, SceneFinishState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SceneFinishState_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<SceneFinishState>(int_value);
  }
  return success;
}
bool FishingState_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> FishingState_strings[5] = {};

static const char FishingState_names[] =
  "CAST"
  "LEAVE"
  "PULL"
  "SITDOWN"
  "WAIT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry FishingState_entries[] = {
  { {FishingState_names + 0, 4}, 3 },
  { {FishingState_names + 4, 5}, 1 },
  { {FishingState_names + 9, 4}, 5 },
  { {FishingState_names + 13, 7}, 2 },
  { {FishingState_names + 20, 4}, 4 },
};

static const int FishingState_entries_by_number[] = {
  1, // 1 -> LEAVE
  3, // 2 -> SITDOWN
  0, // 3 -> CAST
  4, // 4 -> WAIT
  2, // 5 -> PULL
};

const std::string& FishingState_Name(
    FishingState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          FishingState_entries,
          FishingState_entries_by_number,
          5, FishingState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      FishingState_entries,
      FishingState_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     FishingState_strings[idx].get();
}
bool FishingState_Parse(
    const std::string& name, FishingState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      FishingState_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<FishingState>(int_value);
  }
  return success;
}
bool AuctionSortType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AuctionSortType_strings[12] = {};

static const char AuctionSortType_names[] =
  "AUCITONSORT_BIDDING_GREATER"
  "AUCTIONSORT_BIDDING_LESS"
  "AUCTIONSORT_BUYNOW_GREATER"
  "AUCTIONSORT_BUYNOW_LESS"
  "AUCTIONSORT_LEFTTIME_GREATER"
  "AUCTIONSORT_LEFTTIME_LESS"
  "AUCTIONSORT_LEVEL_GREATER"
  "AUCTIONSORT_LEVLE_LESS"
  "AUCTIONSORT_PERPRICE_GREATER"
  "AUCTIONSORT_PERPRICE_LESS"
  "AUCTIONSORT_QUALITY_GREATER"
  "AUCTIONSORT_QUALITY_LESS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AuctionSortType_entries[] = {
  { {AuctionSortType_names + 0, 27}, 10 },
  { {AuctionSortType_names + 27, 24}, 9 },
  { {AuctionSortType_names + 51, 26}, 8 },
  { {AuctionSortType_names + 77, 23}, 7 },
  { {AuctionSortType_names + 100, 28}, 6 },
  { {AuctionSortType_names + 128, 25}, 5 },
  { {AuctionSortType_names + 153, 25}, 4 },
  { {AuctionSortType_names + 178, 22}, 3 },
  { {AuctionSortType_names + 200, 28}, 12 },
  { {AuctionSortType_names + 228, 25}, 11 },
  { {AuctionSortType_names + 253, 27}, 2 },
  { {AuctionSortType_names + 280, 24}, 1 },
};

static const int AuctionSortType_entries_by_number[] = {
  11, // 1 -> AUCTIONSORT_QUALITY_LESS
  10, // 2 -> AUCTIONSORT_QUALITY_GREATER
  7, // 3 -> AUCTIONSORT_LEVLE_LESS
  6, // 4 -> AUCTIONSORT_LEVEL_GREATER
  5, // 5 -> AUCTIONSORT_LEFTTIME_LESS
  4, // 6 -> AUCTIONSORT_LEFTTIME_GREATER
  3, // 7 -> AUCTIONSORT_BUYNOW_LESS
  2, // 8 -> AUCTIONSORT_BUYNOW_GREATER
  1, // 9 -> AUCTIONSORT_BIDDING_LESS
  0, // 10 -> AUCITONSORT_BIDDING_GREATER
  9, // 11 -> AUCTIONSORT_PERPRICE_LESS
  8, // 12 -> AUCTIONSORT_PERPRICE_GREATER
};

const std::string& AuctionSortType_Name(
    AuctionSortType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          AuctionSortType_entries,
          AuctionSortType_entries_by_number,
          12, AuctionSortType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      AuctionSortType_entries,
      AuctionSortType_entries_by_number,
      12, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     AuctionSortType_strings[idx].get();
}
bool AuctionSortType_Parse(
    const std::string& name, AuctionSortType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      AuctionSortType_entries, 12, name, &int_value);
  if (success) {
    *value = static_cast<AuctionSortType>(int_value);
  }
  return success;
}
bool AuctionAccountType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AuctionAccountType_strings[4] = {};

static const char AuctionAccountType_names[] =
  "AUCTACCOUNT_BUY_FAIL"
  "AUCTACCOUNT_BUY_SUCCESS"
  "AUCTACCOUNT_SALE_FAIL"
  "AUCTACCOUNT_SALE_SUCCESS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AuctionAccountType_entries[] = {
  { {AuctionAccountType_names + 0, 20}, 3 },
  { {AuctionAccountType_names + 20, 23}, 4 },
  { {AuctionAccountType_names + 43, 21}, 1 },
  { {AuctionAccountType_names + 64, 24}, 2 },
};

static const int AuctionAccountType_entries_by_number[] = {
  2, // 1 -> AUCTACCOUNT_SALE_FAIL
  3, // 2 -> AUCTACCOUNT_SALE_SUCCESS
  0, // 3 -> AUCTACCOUNT_BUY_FAIL
  1, // 4 -> AUCTACCOUNT_BUY_SUCCESS
};

const std::string& AuctionAccountType_Name(
    AuctionAccountType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          AuctionAccountType_entries,
          AuctionAccountType_entries_by_number,
          4, AuctionAccountType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      AuctionAccountType_entries,
      AuctionAccountType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     AuctionAccountType_strings[idx].get();
}
bool AuctionAccountType_Parse(
    const std::string& name, AuctionAccountType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      AuctionAccountType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<AuctionAccountType>(int_value);
  }
  return success;
}
bool PetOP_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PetOP_strings[14] = {};

static const char PetOP_names[] =
  "ExpandSeat"
  "IgnorePetPairRideInvite"
  "OffPetPairRide"
  "PetBorn"
  "PetExpTransfer"
  "PetFeed"
  "PetFellow"
  "PetFight"
  "PetRelease"
  "PetTouch"
  "PetUpdate"
  "QueryPetPairRideInvite"
  "SetPetPairRide"
  "useskillbook";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PetOP_entries[] = {
  { {PetOP_names + 0, 10}, 8 },
  { {PetOP_names + 10, 23}, 14 },
  { {PetOP_names + 33, 14}, 13 },
  { {PetOP_names + 47, 7}, 5 },
  { {PetOP_names + 54, 14}, 9 },
  { {PetOP_names + 68, 7}, 3 },
  { {PetOP_names + 75, 9}, 1 },
  { {PetOP_names + 84, 8}, 2 },
  { {PetOP_names + 92, 10}, 7 },
  { {PetOP_names + 102, 8}, 4 },
  { {PetOP_names + 110, 9}, 6 },
  { {PetOP_names + 119, 22}, 12 },
  { {PetOP_names + 141, 14}, 11 },
  { {PetOP_names + 155, 12}, 10 },
};

static const int PetOP_entries_by_number[] = {
  6, // 1 -> PetFellow
  7, // 2 -> PetFight
  5, // 3 -> PetFeed
  9, // 4 -> PetTouch
  3, // 5 -> PetBorn
  10, // 6 -> PetUpdate
  8, // 7 -> PetRelease
  0, // 8 -> ExpandSeat
  4, // 9 -> PetExpTransfer
  13, // 10 -> useskillbook
  12, // 11 -> SetPetPairRide
  11, // 12 -> QueryPetPairRideInvite
  2, // 13 -> OffPetPairRide
  1, // 14 -> IgnorePetPairRideInvite
};

const std::string& PetOP_Name(
    PetOP value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PetOP_entries,
          PetOP_entries_by_number,
          14, PetOP_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PetOP_entries,
      PetOP_entries_by_number,
      14, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PetOP_strings[idx].get();
}
bool PetOP_Parse(
    const std::string& name, PetOP* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PetOP_entries, 14, name, &int_value);
  if (success) {
    *value = static_cast<PetOP>(int_value);
  }
  return success;
}
bool CampID_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CampID_strings[3] = {};

static const char CampID_names[] =
  "CAMP_ADVENTURER"
  "CAMP_DRAGON"
  "CAMP_KNIGHT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CampID_entries[] = {
  { {CampID_names + 0, 15}, 3 },
  { {CampID_names + 15, 11}, 1 },
  { {CampID_names + 26, 11}, 2 },
};

static const int CampID_entries_by_number[] = {
  1, // 1 -> CAMP_DRAGON
  2, // 2 -> CAMP_KNIGHT
  0, // 3 -> CAMP_ADVENTURER
};

const std::string& CampID_Name(
    CampID value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CampID_entries,
          CampID_entries_by_number,
          3, CampID_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CampID_entries,
      CampID_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CampID_strings[idx].get();
}
bool CampID_Parse(
    const std::string& name, CampID* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CampID_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<CampID>(int_value);
  }
  return success;
}
bool FortType_IsValid(int value) {
  switch (value) {
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> FortType_strings[1] = {};

static const char FortType_names[] =
  "FORTTYPE_MAX";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry FortType_entries[] = {
  { {FortType_names + 0, 12}, 1 },
};

static const int FortType_entries_by_number[] = {
  0, // 1 -> FORTTYPE_MAX
};

const std::string& FortType_Name(
    FortType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          FortType_entries,
          FortType_entries_by_number,
          1, FortType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      FortType_entries,
      FortType_entries_by_number,
      1, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     FortType_strings[idx].get();
}
bool FortType_Parse(
    const std::string& name, FortType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      FortType_entries, 1, name, &int_value);
  if (success) {
    *value = static_cast<FortType>(int_value);
  }
  return success;
}
bool FortStatus_IsValid(int value) {
  switch (value) {
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> FortStatus_strings[1] = {};

static const char FortStatus_names[] =
  "FORTSTATUS_MAX";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry FortStatus_entries[] = {
  { {FortStatus_names + 0, 14}, 1 },
};

static const int FortStatus_entries_by_number[] = {
  0, // 1 -> FORTSTATUS_MAX
};

const std::string& FortStatus_Name(
    FortStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          FortStatus_entries,
          FortStatus_entries_by_number,
          1, FortStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      FortStatus_entries,
      FortStatus_entries_by_number,
      1, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     FortStatus_strings[idx].get();
}
bool FortStatus_Parse(
    const std::string& name, FortStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      FortStatus_entries, 1, name, &int_value);
  if (success) {
    *value = static_cast<FortStatus>(int_value);
  }
  return success;
}
bool AuctDBDataOperate_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AuctDBDataOperate_strings[3] = {};

static const char AuctDBDataOperate_names[] =
  "AUCTDBDATA_DELETE"
  "AUCTDBDATA_INSERT"
  "AUCTDBDATA_UPDATE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AuctDBDataOperate_entries[] = {
  { {AuctDBDataOperate_names + 0, 17}, 3 },
  { {AuctDBDataOperate_names + 17, 17}, 1 },
  { {AuctDBDataOperate_names + 34, 17}, 2 },
};

static const int AuctDBDataOperate_entries_by_number[] = {
  1, // 1 -> AUCTDBDATA_INSERT
  2, // 2 -> AUCTDBDATA_UPDATE
  0, // 3 -> AUCTDBDATA_DELETE
};

const std::string& AuctDBDataOperate_Name(
    AuctDBDataOperate value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          AuctDBDataOperate_entries,
          AuctDBDataOperate_entries_by_number,
          3, AuctDBDataOperate_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      AuctDBDataOperate_entries,
      AuctDBDataOperate_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     AuctDBDataOperate_strings[idx].get();
}
bool AuctDBDataOperate_Parse(
    const std::string& name, AuctDBDataOperate* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      AuctDBDataOperate_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<AuctDBDataOperate>(int_value);
  }
  return success;
}
bool CampTaskType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CampTaskType_strings[4] = {};

static const char CampTaskType_names[] =
  "CAMPTASK_ITEM"
  "CAMPTASK_PATROL"
  "CAMPTASK_SCENE"
  "CAMPTASK_SPY";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CampTaskType_entries[] = {
  { {CampTaskType_names + 0, 13}, 1 },
  { {CampTaskType_names + 13, 15}, 3 },
  { {CampTaskType_names + 28, 14}, 2 },
  { {CampTaskType_names + 42, 12}, 4 },
};

static const int CampTaskType_entries_by_number[] = {
  0, // 1 -> CAMPTASK_ITEM
  2, // 2 -> CAMPTASK_SCENE
  1, // 3 -> CAMPTASK_PATROL
  3, // 4 -> CAMPTASK_SPY
};

const std::string& CampTaskType_Name(
    CampTaskType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CampTaskType_entries,
          CampTaskType_entries_by_number,
          4, CampTaskType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CampTaskType_entries,
      CampTaskType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CampTaskType_strings[idx].get();
}
bool CampTaskType_Parse(
    const std::string& name, CampTaskType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CampTaskType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<CampTaskType>(int_value);
  }
  return success;
}
bool CampTaskStatus_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CampTaskStatus_strings[4] = {};

static const char CampTaskStatus_names[] =
  "CAMPTASK_FINISH"
  "CAMPTASK_GET"
  "CAMPTASK_REWARD"
  "CAMPTASK_VIEW";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CampTaskStatus_entries[] = {
  { {CampTaskStatus_names + 0, 15}, 3 },
  { {CampTaskStatus_names + 15, 12}, 1 },
  { {CampTaskStatus_names + 27, 15}, 4 },
  { {CampTaskStatus_names + 42, 13}, 2 },
};

static const int CampTaskStatus_entries_by_number[] = {
  1, // 1 -> CAMPTASK_GET
  3, // 2 -> CAMPTASK_VIEW
  0, // 3 -> CAMPTASK_FINISH
  2, // 4 -> CAMPTASK_REWARD
};

const std::string& CampTaskStatus_Name(
    CampTaskStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CampTaskStatus_entries,
          CampTaskStatus_entries_by_number,
          4, CampTaskStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CampTaskStatus_entries,
      CampTaskStatus_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CampTaskStatus_strings[idx].get();
}
bool CampTaskStatus_Parse(
    const std::string& name, CampTaskStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CampTaskStatus_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<CampTaskStatus>(int_value);
  }
  return success;
}
bool AbyssFlameStage_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AbyssFlameStage_strings[3] = {};

static const char AbyssFlameStage_names[] =
  "ABYSS_NONE_FLAME"
  "ABYSS_ON_FLAME"
  "ABYSS_WIN_FLAME";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AbyssFlameStage_entries[] = {
  { {AbyssFlameStage_names + 0, 16}, 1 },
  { {AbyssFlameStage_names + 16, 14}, 2 },
  { {AbyssFlameStage_names + 30, 15}, 3 },
};

static const int AbyssFlameStage_entries_by_number[] = {
  0, // 1 -> ABYSS_NONE_FLAME
  1, // 2 -> ABYSS_ON_FLAME
  2, // 3 -> ABYSS_WIN_FLAME
};

const std::string& AbyssFlameStage_Name(
    AbyssFlameStage value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          AbyssFlameStage_entries,
          AbyssFlameStage_entries_by_number,
          3, AbyssFlameStage_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      AbyssFlameStage_entries,
      AbyssFlameStage_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     AbyssFlameStage_strings[idx].get();
}
bool AbyssFlameStage_Parse(
    const std::string& name, AbyssFlameStage* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      AbyssFlameStage_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<AbyssFlameStage>(int_value);
  }
  return success;
}
bool ExpBackType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ExpBackType_strings[3] = {};

static const char ExpBackType_names[] =
  "EXPBACK_ABYSSS"
  "EXPBACK_CAMPTASK"
  "EXPBACK_NEST";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ExpBackType_entries[] = {
  { {ExpBackType_names + 0, 14}, 1 },
  { {ExpBackType_names + 14, 16}, 3 },
  { {ExpBackType_names + 30, 12}, 2 },
};

static const int ExpBackType_entries_by_number[] = {
  0, // 1 -> EXPBACK_ABYSSS
  2, // 2 -> EXPBACK_NEST
  1, // 3 -> EXPBACK_CAMPTASK
};

const std::string& ExpBackType_Name(
    ExpBackType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ExpBackType_entries,
          ExpBackType_entries_by_number,
          3, ExpBackType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ExpBackType_entries,
      ExpBackType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ExpBackType_strings[idx].get();
}
bool ExpBackType_Parse(
    const std::string& name, ExpBackType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ExpBackType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<ExpBackType>(int_value);
  }
  return success;
}
bool LogDBType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LogDBType_strings[2] = {};

static const char LogDBType_names[] =
  "LOG_DB_NORMAL"
  "LOG_DB_TENCENT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LogDBType_entries[] = {
  { {LogDBType_names + 0, 13}, 0 },
  { {LogDBType_names + 13, 14}, 1 },
};

static const int LogDBType_entries_by_number[] = {
  0, // 0 -> LOG_DB_NORMAL
  1, // 1 -> LOG_DB_TENCENT
};

const std::string& LogDBType_Name(
    LogDBType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          LogDBType_entries,
          LogDBType_entries_by_number,
          2, LogDBType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      LogDBType_entries,
      LogDBType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     LogDBType_strings[idx].get();
}
bool LogDBType_Parse(
    const std::string& name, LogDBType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      LogDBType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<LogDBType>(int_value);
  }
  return success;
}
bool buyextype_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> buyextype_strings[7] = {};

static const char buyextype_names[] =
  "DIAMOND_BUY_FATIGUE"
  "DIAMOND_EXCHANGE_DRAGONCOIN"
  "DIAMONE_BUY_DRAGONCOIN"
  "DIAMONE_BUY_GOLD"
  "DRAGONCOIN_BUY_BLUEBIRD"
  "DRAGONCOIN_BUY_GOLD"
  "DRAGON_BUY_FATIGUE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry buyextype_entries[] = {
  { {buyextype_names + 0, 19}, 5 },
  { {buyextype_names + 19, 27}, 7 },
  { {buyextype_names + 46, 22}, 1 },
  { {buyextype_names + 68, 16}, 2 },
  { {buyextype_names + 84, 23}, 6 },
  { {buyextype_names + 107, 19}, 3 },
  { {buyextype_names + 126, 18}, 4 },
};

static const int buyextype_entries_by_number[] = {
  2, // 1 -> DIAMONE_BUY_DRAGONCOIN
  3, // 2 -> DIAMONE_BUY_GOLD
  5, // 3 -> DRAGONCOIN_BUY_GOLD
  6, // 4 -> DRAGON_BUY_FATIGUE
  0, // 5 -> DIAMOND_BUY_FATIGUE
  4, // 6 -> DRAGONCOIN_BUY_BLUEBIRD
  1, // 7 -> DIAMOND_EXCHANGE_DRAGONCOIN
};

const std::string& buyextype_Name(
    buyextype value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          buyextype_entries,
          buyextype_entries_by_number,
          7, buyextype_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      buyextype_entries,
      buyextype_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     buyextype_strings[idx].get();
}
bool buyextype_Parse(
    const std::string& name, buyextype* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      buyextype_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<buyextype>(int_value);
  }
  return success;
}
bool DesignationType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DesignationType_strings[5] = {};

static const char DesignationType_names[] =
  "DESIGNATION_TYPE_ACTIVITY"
  "DESIGNATION_TYPE_BATTLE"
  "DESIGNATION_TYPE_COMMON"
  "DESIGNATION_TYPE_NEST"
  "DESIGNATION_TYPE_RAID";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DesignationType_entries[] = {
  { {DesignationType_names + 0, 25}, 5 },
  { {DesignationType_names + 25, 23}, 4 },
  { {DesignationType_names + 48, 23}, 1 },
  { {DesignationType_names + 71, 21}, 3 },
  { {DesignationType_names + 92, 21}, 2 },
};

static const int DesignationType_entries_by_number[] = {
  2, // 1 -> DESIGNATION_TYPE_COMMON
  4, // 2 -> DESIGNATION_TYPE_RAID
  3, // 3 -> DESIGNATION_TYPE_NEST
  1, // 4 -> DESIGNATION_TYPE_BATTLE
  0, // 5 -> DESIGNATION_TYPE_ACTIVITY
};

const std::string& DesignationType_Name(
    DesignationType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DesignationType_entries,
          DesignationType_entries_by_number,
          5, DesignationType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DesignationType_entries,
      DesignationType_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DesignationType_strings[idx].get();
}
bool DesignationType_Parse(
    const std::string& name, DesignationType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DesignationType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<DesignationType>(int_value);
  }
  return success;
}
bool AchieveType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AchieveType_strings[5] = {};

static const char AchieveType_names[] =
  "ACHIEVE_TYPE_ACTIVITY"
  "ACHIEVE_TYPE_BATTLE"
  "ACHIEVE_TYPE_COMMON"
  "ACHIEVE_TYPE_NEST"
  "ACHIEVE_TYPE_RAID";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AchieveType_entries[] = {
  { {AchieveType_names + 0, 21}, 5 },
  { {AchieveType_names + 21, 19}, 4 },
  { {AchieveType_names + 40, 19}, 1 },
  { {AchieveType_names + 59, 17}, 3 },
  { {AchieveType_names + 76, 17}, 2 },
};

static const int AchieveType_entries_by_number[] = {
  2, // 1 -> ACHIEVE_TYPE_COMMON
  4, // 2 -> ACHIEVE_TYPE_RAID
  3, // 3 -> ACHIEVE_TYPE_NEST
  1, // 4 -> ACHIEVE_TYPE_BATTLE
  0, // 5 -> ACHIEVE_TYPE_ACTIVITY
};

const std::string& AchieveType_Name(
    AchieveType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          AchieveType_entries,
          AchieveType_entries_by_number,
          5, AchieveType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      AchieveType_entries,
      AchieveType_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     AchieveType_strings[idx].get();
}
bool AchieveType_Parse(
    const std::string& name, AchieveType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      AchieveType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<AchieveType>(int_value);
  }
  return success;
}
bool RewardStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> RewardStatus_strings[3] = {};

static const char RewardStatus_names[] =
  "REWARD_STATUS_CAN"
  "REWARD_STATUS_CANNOT"
  "REWARD_STATUS_GOT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry RewardStatus_entries[] = {
  { {RewardStatus_names + 0, 17}, 1 },
  { {RewardStatus_names + 17, 20}, 0 },
  { {RewardStatus_names + 37, 17}, 2 },
};

static const int RewardStatus_entries_by_number[] = {
  1, // 0 -> REWARD_STATUS_CANNOT
  0, // 1 -> REWARD_STATUS_CAN
  2, // 2 -> REWARD_STATUS_GOT
};

const std::string& RewardStatus_Name(
    RewardStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          RewardStatus_entries,
          RewardStatus_entries_by_number,
          3, RewardStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      RewardStatus_entries,
      RewardStatus_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     RewardStatus_strings[idx].get();
}
bool RewardStatus_Parse(
    const std::string& name, RewardStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      RewardStatus_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<RewardStatus>(int_value);
  }
  return success;
}
bool LevelSealButtonType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LevelSealButtonType_strings[3] = {};

static const char LevelSealButtonType_names[] =
  "BUTTON_STATUS_LOCKED"
  "BUTTON_STATUS_NONE"
  "BUTTON_STATUS_UNLOCKED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LevelSealButtonType_entries[] = {
  { {LevelSealButtonType_names + 0, 20}, 1 },
  { {LevelSealButtonType_names + 20, 18}, 0 },
  { {LevelSealButtonType_names + 38, 22}, 2 },
};

static const int LevelSealButtonType_entries_by_number[] = {
  1, // 0 -> BUTTON_STATUS_NONE
  0, // 1 -> BUTTON_STATUS_LOCKED
  2, // 2 -> BUTTON_STATUS_UNLOCKED
};

const std::string& LevelSealButtonType_Name(
    LevelSealButtonType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          LevelSealButtonType_entries,
          LevelSealButtonType_entries_by_number,
          3, LevelSealButtonType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      LevelSealButtonType_entries,
      LevelSealButtonType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     LevelSealButtonType_strings[idx].get();
}
bool LevelSealButtonType_Parse(
    const std::string& name, LevelSealButtonType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      LevelSealButtonType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<LevelSealButtonType>(int_value);
  }
  return success;
}
bool PlatType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PlatType_strings[2] = {};

static const char PlatType_names[] =
  "PLAT_ANDROID"
  "PLAT_IOS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PlatType_entries[] = {
  { {PlatType_names + 0, 12}, 1 },
  { {PlatType_names + 12, 8}, 0 },
};

static const int PlatType_entries_by_number[] = {
  1, // 0 -> PLAT_IOS
  0, // 1 -> PLAT_ANDROID
};

const std::string& PlatType_Name(
    PlatType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PlatType_entries,
          PlatType_entries_by_number,
          2, PlatType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PlatType_entries,
      PlatType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PlatType_strings[idx].get();
}
bool PlatType_Parse(
    const std::string& name, PlatType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PlatType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<PlatType>(int_value);
  }
  return success;
}
bool GameAppType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GameAppType_strings[2] = {};

static const char GameAppType_names[] =
  "GAME_APP_QQ"
  "GAME_APP_WECHAT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GameAppType_entries[] = {
  { {GameAppType_names + 0, 11}, 2 },
  { {GameAppType_names + 11, 15}, 1 },
};

static const int GameAppType_entries_by_number[] = {
  1, // 1 -> GAME_APP_WECHAT
  0, // 2 -> GAME_APP_QQ
};

const std::string& GameAppType_Name(
    GameAppType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GameAppType_entries,
          GameAppType_entries_by_number,
          2, GameAppType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GameAppType_entries,
      GameAppType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GameAppType_strings[idx].get();
}
bool GameAppType_Parse(
    const std::string& name, GameAppType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GameAppType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<GameAppType>(int_value);
  }
  return success;
}
bool LoginRewardState_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LoginRewardState_strings[3] = {};

static const char LoginRewardState_names[] =
  "LOGINRS_CANNOT"
  "LOGINRS_HAVE"
  "LOGINRS_HAVEHOT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LoginRewardState_entries[] = {
  { {LoginRewardState_names + 0, 14}, 1 },
  { {LoginRewardState_names + 14, 12}, 3 },
  { {LoginRewardState_names + 26, 15}, 2 },
};

static const int LoginRewardState_entries_by_number[] = {
  0, // 1 -> LOGINRS_CANNOT
  2, // 2 -> LOGINRS_HAVEHOT
  1, // 3 -> LOGINRS_HAVE
};

const std::string& LoginRewardState_Name(
    LoginRewardState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          LoginRewardState_entries,
          LoginRewardState_entries_by_number,
          3, LoginRewardState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      LoginRewardState_entries,
      LoginRewardState_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     LoginRewardState_strings[idx].get();
}
bool LoginRewardState_Parse(
    const std::string& name, LoginRewardState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      LoginRewardState_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<LoginRewardState>(int_value);
  }
  return success;
}
bool PvpReqType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PvpReqType_strings[5] = {};

static const char PvpReqType_names[] =
  "PVP_REQ_BASE_DATA"
  "PVP_REQ_GET_WEEKREWARD"
  "PVP_REQ_HISTORY_REC"
  "PVP_REQ_IN_MATCH"
  "PVP_REQ_OUT_MATCH";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PvpReqType_entries[] = {
  { {PvpReqType_names + 0, 17}, 3 },
  { {PvpReqType_names + 17, 22}, 5 },
  { {PvpReqType_names + 39, 19}, 4 },
  { {PvpReqType_names + 58, 16}, 1 },
  { {PvpReqType_names + 74, 17}, 2 },
};

static const int PvpReqType_entries_by_number[] = {
  3, // 1 -> PVP_REQ_IN_MATCH
  4, // 2 -> PVP_REQ_OUT_MATCH
  0, // 3 -> PVP_REQ_BASE_DATA
  2, // 4 -> PVP_REQ_HISTORY_REC
  1, // 5 -> PVP_REQ_GET_WEEKREWARD
};

const std::string& PvpReqType_Name(
    PvpReqType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PvpReqType_entries,
          PvpReqType_entries_by_number,
          5, PvpReqType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PvpReqType_entries,
      PvpReqType_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PvpReqType_strings[idx].get();
}
bool PvpReqType_Parse(
    const std::string& name, PvpReqType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PvpReqType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<PvpReqType>(int_value);
  }
  return success;
}
bool FriendOpType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> FriendOpType_strings[12] = {};

static const char FriendOpType_names[] =
  "Friend_AgreeApply"
  "Friend_ApplyAdd"
  "Friend_ApplyAll"
  "Friend_ApplyDelete"
  "Friend_FriendAdd"
  "Friend_FriendAll"
  "Friend_FriendDelete"
  "Friend_GiftInfo"
  "Friend_IgnoreApply"
  "Friend_ReveiveGift"
  "Friend_SendGift"
  "Friend_TakeGift";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry FriendOpType_entries[] = {
  { {FriendOpType_names + 0, 17}, 1 },
  { {FriendOpType_names + 17, 15}, 7 },
  { {FriendOpType_names + 32, 15}, 4 },
  { {FriendOpType_names + 47, 18}, 8 },
  { {FriendOpType_names + 65, 16}, 5 },
  { {FriendOpType_names + 81, 16}, 3 },
  { {FriendOpType_names + 97, 19}, 6 },
  { {FriendOpType_names + 116, 15}, 12 },
  { {FriendOpType_names + 131, 18}, 2 },
  { {FriendOpType_names + 149, 18}, 9 },
  { {FriendOpType_names + 167, 15}, 10 },
  { {FriendOpType_names + 182, 15}, 11 },
};

static const int FriendOpType_entries_by_number[] = {
  0, // 1 -> Friend_AgreeApply
  8, // 2 -> Friend_IgnoreApply
  5, // 3 -> Friend_FriendAll
  2, // 4 -> Friend_ApplyAll
  4, // 5 -> Friend_FriendAdd
  6, // 6 -> Friend_FriendDelete
  1, // 7 -> Friend_ApplyAdd
  3, // 8 -> Friend_ApplyDelete
  9, // 9 -> Friend_ReveiveGift
  10, // 10 -> Friend_SendGift
  11, // 11 -> Friend_TakeGift
  7, // 12 -> Friend_GiftInfo
};

const std::string& FriendOpType_Name(
    FriendOpType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          FriendOpType_entries,
          FriendOpType_entries_by_number,
          12, FriendOpType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      FriendOpType_entries,
      FriendOpType_entries_by_number,
      12, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     FriendOpType_strings[idx].get();
}
bool FriendOpType_Parse(
    const std::string& name, FriendOpType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      FriendOpType_entries, 12, name, &int_value);
  if (success) {
    *value = static_cast<FriendOpType>(int_value);
  }
  return success;
}
bool FriendGiftSend_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> FriendGiftSend_strings[2] = {};

static const char FriendGiftSend_names[] =
  "FriendGift_SendNone"
  "FriendGift_Sended";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry FriendGiftSend_entries[] = {
  { {FriendGiftSend_names + 0, 19}, 0 },
  { {FriendGiftSend_names + 19, 17}, 1 },
};

static const int FriendGiftSend_entries_by_number[] = {
  0, // 0 -> FriendGift_SendNone
  1, // 1 -> FriendGift_Sended
};

const std::string& FriendGiftSend_Name(
    FriendGiftSend value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          FriendGiftSend_entries,
          FriendGiftSend_entries_by_number,
          2, FriendGiftSend_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      FriendGiftSend_entries,
      FriendGiftSend_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     FriendGiftSend_strings[idx].get();
}
bool FriendGiftSend_Parse(
    const std::string& name, FriendGiftSend* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      FriendGiftSend_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<FriendGiftSend>(int_value);
  }
  return success;
}
bool FriendGiftReceive_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> FriendGiftReceive_strings[3] = {};

static const char FriendGiftReceive_names[] =
  "FriendGift_ReceiveNone"
  "FriendGift_ReceiveTaken"
  "FriendGift_Received";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry FriendGiftReceive_entries[] = {
  { {FriendGiftReceive_names + 0, 22}, 0 },
  { {FriendGiftReceive_names + 22, 23}, 2 },
  { {FriendGiftReceive_names + 45, 19}, 1 },
};

static const int FriendGiftReceive_entries_by_number[] = {
  0, // 0 -> FriendGift_ReceiveNone
  2, // 1 -> FriendGift_Received
  1, // 2 -> FriendGift_ReceiveTaken
};

const std::string& FriendGiftReceive_Name(
    FriendGiftReceive value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          FriendGiftReceive_entries,
          FriendGiftReceive_entries_by_number,
          3, FriendGiftReceive_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      FriendGiftReceive_entries,
      FriendGiftReceive_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     FriendGiftReceive_strings[idx].get();
}
bool FriendGiftReceive_Parse(
    const std::string& name, FriendGiftReceive* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      FriendGiftReceive_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<FriendGiftReceive>(int_value);
  }
  return success;
}
bool EnterSceneType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> EnterSceneType_strings[2] = {};

static const char EnterSceneType_names[] =
  "ENTER_SCENE_SELECT_ROLE"
  "ENTER_SCENE_SWITCH";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry EnterSceneType_entries[] = {
  { {EnterSceneType_names + 0, 23}, 1 },
  { {EnterSceneType_names + 23, 18}, 2 },
};

static const int EnterSceneType_entries_by_number[] = {
  0, // 1 -> ENTER_SCENE_SELECT_ROLE
  1, // 2 -> ENTER_SCENE_SWITCH
};

const std::string& EnterSceneType_Name(
    EnterSceneType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          EnterSceneType_entries,
          EnterSceneType_entries_by_number,
          2, EnterSceneType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      EnterSceneType_entries,
      EnterSceneType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     EnterSceneType_strings[idx].get();
}
bool EnterSceneType_Parse(
    const std::string& name, EnterSceneType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      EnterSceneType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<EnterSceneType>(int_value);
  }
  return success;
}
bool RoleDataReadType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> RoleDataReadType_strings[2] = {};

static const char RoleDataReadType_names[] =
  "ROLE_DATA_READ_IDIP"
  "ROLE_DATA_READ_SELECT_ROLE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry RoleDataReadType_entries[] = {
  { {RoleDataReadType_names + 0, 19}, 2 },
  { {RoleDataReadType_names + 19, 26}, 1 },
};

static const int RoleDataReadType_entries_by_number[] = {
  1, // 1 -> ROLE_DATA_READ_SELECT_ROLE
  0, // 2 -> ROLE_DATA_READ_IDIP
};

const std::string& RoleDataReadType_Name(
    RoleDataReadType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          RoleDataReadType_entries,
          RoleDataReadType_entries_by_number,
          2, RoleDataReadType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      RoleDataReadType_entries,
      RoleDataReadType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     RoleDataReadType_strings[idx].get();
}
bool RoleDataReadType_Parse(
    const std::string& name, RoleDataReadType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      RoleDataReadType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<RoleDataReadType>(int_value);
  }
  return success;
}
bool LeaveSceneType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LeaveSceneType_strings[2] = {};

static const char LeaveSceneType_names[] =
  "LEAVE_SCENE_LOGOUT"
  "LEAVE_SCENE_SWITCH";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LeaveSceneType_entries[] = {
  { {LeaveSceneType_names + 0, 18}, 1 },
  { {LeaveSceneType_names + 18, 18}, 2 },
};

static const int LeaveSceneType_entries_by_number[] = {
  0, // 1 -> LEAVE_SCENE_LOGOUT
  1, // 2 -> LEAVE_SCENE_SWITCH
};

const std::string& LeaveSceneType_Name(
    LeaveSceneType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          LeaveSceneType_entries,
          LeaveSceneType_entries_by_number,
          2, LeaveSceneType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      LeaveSceneType_entries,
      LeaveSceneType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     LeaveSceneType_strings[idx].get();
}
bool LeaveSceneType_Parse(
    const std::string& name, LeaveSceneType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      LeaveSceneType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<LeaveSceneType>(int_value);
  }
  return success;
}
bool InvHReqType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> InvHReqType_strings[3] = {};

static const char InvHReqType_names[] =
  "INVH_REFUSE_FORNOW"
  "INVH_REQ_UNF_LIST"
  "INVH_UNF_IGNORE_ALL";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry InvHReqType_entries[] = {
  { {InvHReqType_names + 0, 18}, 3 },
  { {InvHReqType_names + 18, 17}, 1 },
  { {InvHReqType_names + 35, 19}, 2 },
};

static const int InvHReqType_entries_by_number[] = {
  1, // 1 -> INVH_REQ_UNF_LIST
  2, // 2 -> INVH_UNF_IGNORE_ALL
  0, // 3 -> INVH_REFUSE_FORNOW
};

const std::string& InvHReqType_Name(
    InvHReqType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          InvHReqType_entries,
          InvHReqType_entries_by_number,
          3, InvHReqType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      InvHReqType_entries,
      InvHReqType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     InvHReqType_strings[idx].get();
}
bool InvHReqType_Parse(
    const std::string& name, InvHReqType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      InvHReqType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<InvHReqType>(int_value);
  }
  return success;
}
bool MulActivityTimeState_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> MulActivityTimeState_strings[4] = {};

static const char MulActivityTimeState_names[] =
  "MULACTIVITY_BEfOREOPEN"
  "MULACTIVITY_END"
  "MULACTIVITY_RUNNING"
  "MULACTIVITY_UNOPEN_TODAY";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry MulActivityTimeState_entries[] = {
  { {MulActivityTimeState_names + 0, 22}, 1 },
  { {MulActivityTimeState_names + 22, 15}, 3 },
  { {MulActivityTimeState_names + 37, 19}, 2 },
  { {MulActivityTimeState_names + 56, 24}, 4 },
};

static const int MulActivityTimeState_entries_by_number[] = {
  0, // 1 -> MULACTIVITY_BEfOREOPEN
  2, // 2 -> MULACTIVITY_RUNNING
  1, // 3 -> MULACTIVITY_END
  3, // 4 -> MULACTIVITY_UNOPEN_TODAY
};

const std::string& MulActivityTimeState_Name(
    MulActivityTimeState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          MulActivityTimeState_entries,
          MulActivityTimeState_entries_by_number,
          4, MulActivityTimeState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      MulActivityTimeState_entries,
      MulActivityTimeState_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     MulActivityTimeState_strings[idx].get();
}
bool MulActivityTimeState_Parse(
    const std::string& name, MulActivityTimeState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      MulActivityTimeState_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<MulActivityTimeState>(int_value);
  }
  return success;
}
bool XSkillSlot_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> XSkillSlot_strings[11] = {};

static const char XSkillSlot_names[] =
  "Attack_Max"
  "Dash_Attack"
  "Normal_Attack"
  "Skill_1_Attack"
  "Skill_1_Buff"
  "Skill_2_Attack"
  "Skill_2_Buff"
  "Skill_3_Attack"
  "Skill_4_Attack"
  "Skill_5_Attack"
  "Ultra_Attack";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry XSkillSlot_entries[] = {
  { {XSkillSlot_names + 0, 10}, 10 },
  { {XSkillSlot_names + 10, 11}, 1 },
  { {XSkillSlot_names + 21, 13}, 0 },
  { {XSkillSlot_names + 34, 14}, 2 },
  { {XSkillSlot_names + 48, 12}, 7 },
  { {XSkillSlot_names + 60, 14}, 3 },
  { {XSkillSlot_names + 74, 12}, 8 },
  { {XSkillSlot_names + 86, 14}, 4 },
  { {XSkillSlot_names + 100, 14}, 5 },
  { {XSkillSlot_names + 114, 14}, 6 },
  { {XSkillSlot_names + 128, 12}, 9 },
};

static const int XSkillSlot_entries_by_number[] = {
  2, // 0 -> Normal_Attack
  1, // 1 -> Dash_Attack
  3, // 2 -> Skill_1_Attack
  5, // 3 -> Skill_2_Attack
  7, // 4 -> Skill_3_Attack
  8, // 5 -> Skill_4_Attack
  9, // 6 -> Skill_5_Attack
  4, // 7 -> Skill_1_Buff
  6, // 8 -> Skill_2_Buff
  10, // 9 -> Ultra_Attack
  0, // 10 -> Attack_Max
};

const std::string& XSkillSlot_Name(
    XSkillSlot value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          XSkillSlot_entries,
          XSkillSlot_entries_by_number,
          11, XSkillSlot_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      XSkillSlot_entries,
      XSkillSlot_entries_by_number,
      11, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     XSkillSlot_strings[idx].get();
}
bool XSkillSlot_Parse(
    const std::string& name, XSkillSlot* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      XSkillSlot_entries, 11, name, &int_value);
  if (success) {
    *value = static_cast<XSkillSlot>(int_value);
  }
  return success;
}
bool LiveType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LiveType_strings[14] = {};

static const char LiveType_names[] =
  "LIVE_CUSTOMPK"
  "LIVE_DRAGON"
  "LIVE_FRIEND"
  "LIVE_FRIENDANDGUILD"
  "LIVE_GUILD"
  "LIVE_GUILDBATTLE"
  "LIVE_HEROBATTLE"
  "LIVE_LEAGUEBATTLE"
  "LIVE_MAX"
  "LIVE_NEST"
  "LIVE_PROTECTCAPTAIN"
  "LIVE_PVP"
  "LIVE_PVP2"
  "LIVE_RECOMMEND";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LiveType_entries[] = {
  { {LiveType_names + 0, 13}, 13 },
  { {LiveType_names + 13, 11}, 6 },
  { {LiveType_names + 24, 11}, 7 },
  { {LiveType_names + 35, 19}, 9 },
  { {LiveType_names + 54, 10}, 8 },
  { {LiveType_names + 64, 16}, 5 },
  { {LiveType_names + 80, 15}, 10 },
  { {LiveType_names + 95, 17}, 11 },
  { {LiveType_names + 112, 8}, 14 },
  { {LiveType_names + 120, 9}, 3 },
  { {LiveType_names + 129, 19}, 4 },
  { {LiveType_names + 148, 8}, 2 },
  { {LiveType_names + 156, 9}, 12 },
  { {LiveType_names + 165, 14}, 1 },
};

static const int LiveType_entries_by_number[] = {
  13, // 1 -> LIVE_RECOMMEND
  11, // 2 -> LIVE_PVP
  9, // 3 -> LIVE_NEST
  10, // 4 -> LIVE_PROTECTCAPTAIN
  5, // 5 -> LIVE_GUILDBATTLE
  1, // 6 -> LIVE_DRAGON
  2, // 7 -> LIVE_FRIEND
  4, // 8 -> LIVE_GUILD
  3, // 9 -> LIVE_FRIENDANDGUILD
  6, // 10 -> LIVE_HEROBATTLE
  7, // 11 -> LIVE_LEAGUEBATTLE
  12, // 12 -> LIVE_PVP2
  0, // 13 -> LIVE_CUSTOMPK
  8, // 14 -> LIVE_MAX
};

const std::string& LiveType_Name(
    LiveType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          LiveType_entries,
          LiveType_entries_by_number,
          14, LiveType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      LiveType_entries,
      LiveType_entries_by_number,
      14, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     LiveType_strings[idx].get();
}
bool LiveType_Parse(
    const std::string& name, LiveType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      LiveType_entries, 14, name, &int_value);
  if (success) {
    *value = static_cast<LiveType>(int_value);
  }
  return success;
}
bool BossRushReqStatus_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> BossRushReqStatus_strings[7] = {};

static const char BossRushReqStatus_names[] =
  "BOSSRUSH_REQ_APPEARANCE"
  "BOSSRUSH_REQ_BASEDATA"
  "BOSSRUSH_REQ_CONTINUE"
  "BOSSRUSH_REQ_LEFTCOUNT"
  "BOSSRUSH_REQ_REFRESH"
  "BOSSRUSH_RESULT_FAILED"
  "BOSSRUSH_RESULT_WIN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry BossRushReqStatus_entries[] = {
  { {BossRushReqStatus_names + 0, 23}, 5 },
  { {BossRushReqStatus_names + 23, 21}, 3 },
  { {BossRushReqStatus_names + 44, 21}, 7 },
  { {BossRushReqStatus_names + 65, 22}, 6 },
  { {BossRushReqStatus_names + 87, 20}, 4 },
  { {BossRushReqStatus_names + 107, 22}, 2 },
  { {BossRushReqStatus_names + 129, 19}, 1 },
};

static const int BossRushReqStatus_entries_by_number[] = {
  6, // 1 -> BOSSRUSH_RESULT_WIN
  5, // 2 -> BOSSRUSH_RESULT_FAILED
  1, // 3 -> BOSSRUSH_REQ_BASEDATA
  4, // 4 -> BOSSRUSH_REQ_REFRESH
  0, // 5 -> BOSSRUSH_REQ_APPEARANCE
  3, // 6 -> BOSSRUSH_REQ_LEFTCOUNT
  2, // 7 -> BOSSRUSH_REQ_CONTINUE
};

const std::string& BossRushReqStatus_Name(
    BossRushReqStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          BossRushReqStatus_entries,
          BossRushReqStatus_entries_by_number,
          7, BossRushReqStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      BossRushReqStatus_entries,
      BossRushReqStatus_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     BossRushReqStatus_strings[idx].get();
}
bool BossRushReqStatus_Parse(
    const std::string& name, BossRushReqStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      BossRushReqStatus_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<BossRushReqStatus>(int_value);
  }
  return success;
}
bool StopMatchReason_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> StopMatchReason_strings[4] = {};

static const char StopMatchReason_names[] =
  "STOPMATCH_ENTER_BOWEIDUIZ"
  "STOPMATCH_ENTER_TIANTI"
  "STOPMATCH_LEAVESCENE"
  "STOPMATCH_NONE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry StopMatchReason_entries[] = {
  { {StopMatchReason_names + 0, 25}, 4 },
  { {StopMatchReason_names + 25, 22}, 3 },
  { {StopMatchReason_names + 47, 20}, 2 },
  { {StopMatchReason_names + 67, 14}, 1 },
};

static const int StopMatchReason_entries_by_number[] = {
  3, // 1 -> STOPMATCH_NONE
  2, // 2 -> STOPMATCH_LEAVESCENE
  1, // 3 -> STOPMATCH_ENTER_TIANTI
  0, // 4 -> STOPMATCH_ENTER_BOWEIDUIZ
};

const std::string& StopMatchReason_Name(
    StopMatchReason value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          StopMatchReason_entries,
          StopMatchReason_entries_by_number,
          4, StopMatchReason_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      StopMatchReason_entries,
      StopMatchReason_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     StopMatchReason_strings[idx].get();
}
bool StopMatchReason_Parse(
    const std::string& name, StopMatchReason* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      StopMatchReason_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<StopMatchReason>(int_value);
  }
  return success;
}
bool GuildMatchFightState_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 100:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GuildMatchFightState_strings[8] = {};

static const char GuildMatchFightState_names[] =
  "GUILD_MF_ERR"
  "GUILD_MF_FAILED"
  "GUILD_MF_FIGHTING"
  "GUILD_MF_LEAVE"
  "GUILD_MF_NONE"
  "GUILD_MF_REFUSE"
  "GUILD_MF_WAITING"
  "GUILD_MF_WIN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GuildMatchFightState_entries[] = {
  { {GuildMatchFightState_names + 0, 12}, 100 },
  { {GuildMatchFightState_names + 12, 15}, 6 },
  { {GuildMatchFightState_names + 27, 17}, 5 },
  { {GuildMatchFightState_names + 44, 14}, 4 },
  { {GuildMatchFightState_names + 58, 13}, 1 },
  { {GuildMatchFightState_names + 71, 15}, 3 },
  { {GuildMatchFightState_names + 86, 16}, 2 },
  { {GuildMatchFightState_names + 102, 12}, 7 },
};

static const int GuildMatchFightState_entries_by_number[] = {
  4, // 1 -> GUILD_MF_NONE
  6, // 2 -> GUILD_MF_WAITING
  5, // 3 -> GUILD_MF_REFUSE
  3, // 4 -> GUILD_MF_LEAVE
  2, // 5 -> GUILD_MF_FIGHTING
  1, // 6 -> GUILD_MF_FAILED
  7, // 7 -> GUILD_MF_WIN
  0, // 100 -> GUILD_MF_ERR
};

const std::string& GuildMatchFightState_Name(
    GuildMatchFightState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GuildMatchFightState_entries,
          GuildMatchFightState_entries_by_number,
          8, GuildMatchFightState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GuildMatchFightState_entries,
      GuildMatchFightState_entries_by_number,
      8, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GuildMatchFightState_strings[idx].get();
}
bool GuildMatchFightState_Parse(
    const std::string& name, GuildMatchFightState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GuildMatchFightState_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<GuildMatchFightState>(int_value);
  }
  return success;
}
bool TeamInvRoleState_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TeamInvRoleState_strings[7] = {};

static const char TeamInvRoleState_names[] =
  "TIRS_COUNT_LESS"
  "TIRS_FATIGUE_LESS"
  "TIRS_IN_BATTLE"
  "TIRS_IN_MY_TEAM"
  "TIRS_IN_OTHER_TEAM"
  "TIRS_NORMAL"
  "TIRS_NOT_OPEN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TeamInvRoleState_entries[] = {
  { {TeamInvRoleState_names + 0, 15}, 6 },
  { {TeamInvRoleState_names + 15, 17}, 7 },
  { {TeamInvRoleState_names + 32, 14}, 3 },
  { {TeamInvRoleState_names + 46, 15}, 2 },
  { {TeamInvRoleState_names + 61, 18}, 1 },
  { {TeamInvRoleState_names + 79, 11}, 4 },
  { {TeamInvRoleState_names + 90, 13}, 5 },
};

static const int TeamInvRoleState_entries_by_number[] = {
  4, // 1 -> TIRS_IN_OTHER_TEAM
  3, // 2 -> TIRS_IN_MY_TEAM
  2, // 3 -> TIRS_IN_BATTLE
  5, // 4 -> TIRS_NORMAL
  6, // 5 -> TIRS_NOT_OPEN
  0, // 6 -> TIRS_COUNT_LESS
  1, // 7 -> TIRS_FATIGUE_LESS
};

const std::string& TeamInvRoleState_Name(
    TeamInvRoleState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TeamInvRoleState_entries,
          TeamInvRoleState_entries_by_number,
          7, TeamInvRoleState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TeamInvRoleState_entries,
      TeamInvRoleState_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TeamInvRoleState_strings[idx].get();
}
bool TeamInvRoleState_Parse(
    const std::string& name, TeamInvRoleState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TeamInvRoleState_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<TeamInvRoleState>(int_value);
  }
  return success;
}
bool ReadAccountDataType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ReadAccountDataType_strings[3] = {};

static const char ReadAccountDataType_names[] =
  "READ_ACCOUNT_DATA_IDIP"
  "READ_ACCOUNT_DATA_LOGIN"
  "READ_ACCOUNT_DATA_RETURN_SELECT_ROLE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ReadAccountDataType_entries[] = {
  { {ReadAccountDataType_names + 0, 22}, 3 },
  { {ReadAccountDataType_names + 22, 23}, 1 },
  { {ReadAccountDataType_names + 45, 36}, 2 },
};

static const int ReadAccountDataType_entries_by_number[] = {
  1, // 1 -> READ_ACCOUNT_DATA_LOGIN
  2, // 2 -> READ_ACCOUNT_DATA_RETURN_SELECT_ROLE
  0, // 3 -> READ_ACCOUNT_DATA_IDIP
};

const std::string& ReadAccountDataType_Name(
    ReadAccountDataType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ReadAccountDataType_entries,
          ReadAccountDataType_entries_by_number,
          3, ReadAccountDataType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ReadAccountDataType_entries,
      ReadAccountDataType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ReadAccountDataType_strings[idx].get();
}
bool ReadAccountDataType_Parse(
    const std::string& name, ReadAccountDataType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ReadAccountDataType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<ReadAccountDataType>(int_value);
  }
  return success;
}
bool LogoutType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LogoutType_strings[5] = {};

static const char LogoutType_names[] =
  "LOGOUT_ACCOUNT_NORMAL"
  "LOGOUT_CHANGEPROFESSION"
  "LOGOUT_IDIP_KICK_ACCOUNT"
  "LOGOUT_RELOGIN_KICK_ACCOUNT"
  "LOGOUT_RETURN_SELECT_ROLE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LogoutType_entries[] = {
  { {LogoutType_names + 0, 21}, 1 },
  { {LogoutType_names + 21, 23}, 5 },
  { {LogoutType_names + 44, 24}, 3 },
  { {LogoutType_names + 68, 27}, 2 },
  { {LogoutType_names + 95, 25}, 4 },
};

static const int LogoutType_entries_by_number[] = {
  0, // 1 -> LOGOUT_ACCOUNT_NORMAL
  3, // 2 -> LOGOUT_RELOGIN_KICK_ACCOUNT
  2, // 3 -> LOGOUT_IDIP_KICK_ACCOUNT
  4, // 4 -> LOGOUT_RETURN_SELECT_ROLE
  1, // 5 -> LOGOUT_CHANGEPROFESSION
};

const std::string& LogoutType_Name(
    LogoutType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          LogoutType_entries,
          LogoutType_entries_by_number,
          5, LogoutType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      LogoutType_entries,
      LogoutType_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     LogoutType_strings[idx].get();
}
bool LogoutType_Parse(
    const std::string& name, LogoutType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      LogoutType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<LogoutType>(int_value);
  }
  return success;
}
bool MailOpType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> MailOpType_strings[4] = {};

static const char MailOpType_names[] =
  "MAIL_OP_ADD"
  "MAIL_OP_DELETE"
  "MAIL_OP_DELETE_ALL"
  "MAIL_OP_UPDATE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry MailOpType_entries[] = {
  { {MailOpType_names + 0, 11}, 1 },
  { {MailOpType_names + 11, 14}, 3 },
  { {MailOpType_names + 25, 18}, 4 },
  { {MailOpType_names + 43, 14}, 2 },
};

static const int MailOpType_entries_by_number[] = {
  0, // 1 -> MAIL_OP_ADD
  3, // 2 -> MAIL_OP_UPDATE
  1, // 3 -> MAIL_OP_DELETE
  2, // 4 -> MAIL_OP_DELETE_ALL
};

const std::string& MailOpType_Name(
    MailOpType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          MailOpType_entries,
          MailOpType_entries_by_number,
          4, MailOpType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      MailOpType_entries,
      MailOpType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     MailOpType_strings[idx].get();
}
bool MailOpType_Parse(
    const std::string& name, MailOpType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      MailOpType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<MailOpType>(int_value);
  }
  return success;
}
bool WorldBossState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> WorldBossState_strings[5] = {};

static const char WorldBossState_names[] =
  "WorldBoss_Begin"
  "WorldBoss_BeginPre"
  "WorldBoss_End"
  "WorldBoss_Going"
  "WorldBoss_WaitEnd";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry WorldBossState_entries[] = {
  { {WorldBossState_names + 0, 15}, 1 },
  { {WorldBossState_names + 15, 18}, 0 },
  { {WorldBossState_names + 33, 13}, 4 },
  { {WorldBossState_names + 46, 15}, 2 },
  { {WorldBossState_names + 61, 17}, 3 },
};

static const int WorldBossState_entries_by_number[] = {
  1, // 0 -> WorldBoss_BeginPre
  0, // 1 -> WorldBoss_Begin
  3, // 2 -> WorldBoss_Going
  4, // 3 -> WorldBoss_WaitEnd
  2, // 4 -> WorldBoss_End
};

const std::string& WorldBossState_Name(
    WorldBossState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          WorldBossState_entries,
          WorldBossState_entries_by_number,
          5, WorldBossState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      WorldBossState_entries,
      WorldBossState_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     WorldBossState_strings[idx].get();
}
bool WorldBossState_Parse(
    const std::string& name, WorldBossState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      WorldBossState_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<WorldBossState>(int_value);
  }
  return success;
}
bool GuildArenaState_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GuildArenaState_strings[6] = {};

static const char GuildArenaState_names[] =
  "GUILD_ARENA_BATTLE_FINAL"
  "GUILD_ARENA_BATTLE_ONE"
  "GUILD_ARENA_BATTLE_TWO"
  "GUILD_ARENA_BEGIN"
  "GUILD_ARENA_END"
  "GUILD_ARENA_NOT_BEGIN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GuildArenaState_entries[] = {
  { {GuildArenaState_names + 0, 24}, 5 },
  { {GuildArenaState_names + 24, 22}, 3 },
  { {GuildArenaState_names + 46, 22}, 4 },
  { {GuildArenaState_names + 68, 17}, 2 },
  { {GuildArenaState_names + 85, 15}, 6 },
  { {GuildArenaState_names + 100, 21}, 1 },
};

static const int GuildArenaState_entries_by_number[] = {
  5, // 1 -> GUILD_ARENA_NOT_BEGIN
  3, // 2 -> GUILD_ARENA_BEGIN
  1, // 3 -> GUILD_ARENA_BATTLE_ONE
  2, // 4 -> GUILD_ARENA_BATTLE_TWO
  0, // 5 -> GUILD_ARENA_BATTLE_FINAL
  4, // 6 -> GUILD_ARENA_END
};

const std::string& GuildArenaState_Name(
    GuildArenaState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GuildArenaState_entries,
          GuildArenaState_entries_by_number,
          6, GuildArenaState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GuildArenaState_entries,
      GuildArenaState_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GuildArenaState_strings[idx].get();
}
bool GuildArenaState_Parse(
    const std::string& name, GuildArenaState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GuildArenaState_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<GuildArenaState>(int_value);
  }
  return success;
}
bool GMFFailReason_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GMFFailReason_strings[5] = {};

static const char GMFFailReason_names[] =
  "GMF_FAIL_DIE"
  "GMF_FAIL_NONE"
  "GMF_FAIL_QUIT"
  "GMF_FAIL_REFRESE"
  "GMF_FAIL_TIMEOVER";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GMFFailReason_entries[] = {
  { {GMFFailReason_names + 0, 12}, 1 },
  { {GMFFailReason_names + 12, 13}, 0 },
  { {GMFFailReason_names + 25, 13}, 3 },
  { {GMFFailReason_names + 38, 16}, 4 },
  { {GMFFailReason_names + 54, 17}, 2 },
};

static const int GMFFailReason_entries_by_number[] = {
  1, // 0 -> GMF_FAIL_NONE
  0, // 1 -> GMF_FAIL_DIE
  4, // 2 -> GMF_FAIL_TIMEOVER
  2, // 3 -> GMF_FAIL_QUIT
  3, // 4 -> GMF_FAIL_REFRESE
};

const std::string& GMFFailReason_Name(
    GMFFailReason value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GMFFailReason_entries,
          GMFFailReason_entries_by_number,
          5, GMFFailReason_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GMFFailReason_entries,
      GMFFailReason_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GMFFailReason_strings[idx].get();
}
bool GMFFailReason_Parse(
    const std::string& name, GMFFailReason* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GMFFailReason_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<GMFFailReason>(int_value);
  }
  return success;
}
bool PVP_ONEGAMEEND_REASON_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PVP_ONEGAMEEND_REASON_strings[4] = {};

static const char PVP_ONEGAMEEND_REASON_names[] =
  "PVP_OGE_LEADER_DIE"
  "PVP_OGE_LEADER_QUIT"
  "PVP_OGE_ROLE_QUIT"
  "PVP_OGE_TIMELIMIT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PVP_ONEGAMEEND_REASON_entries[] = {
  { {PVP_ONEGAMEEND_REASON_names + 0, 18}, 1 },
  { {PVP_ONEGAMEEND_REASON_names + 18, 19}, 2 },
  { {PVP_ONEGAMEEND_REASON_names + 37, 17}, 4 },
  { {PVP_ONEGAMEEND_REASON_names + 54, 17}, 3 },
};

static const int PVP_ONEGAMEEND_REASON_entries_by_number[] = {
  0, // 1 -> PVP_OGE_LEADER_DIE
  1, // 2 -> PVP_OGE_LEADER_QUIT
  3, // 3 -> PVP_OGE_TIMELIMIT
  2, // 4 -> PVP_OGE_ROLE_QUIT
};

const std::string& PVP_ONEGAMEEND_REASON_Name(
    PVP_ONEGAMEEND_REASON value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PVP_ONEGAMEEND_REASON_entries,
          PVP_ONEGAMEEND_REASON_entries_by_number,
          4, PVP_ONEGAMEEND_REASON_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PVP_ONEGAMEEND_REASON_entries,
      PVP_ONEGAMEEND_REASON_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PVP_ONEGAMEEND_REASON_strings[idx].get();
}
bool PVP_ONEGAMEEND_REASON_Parse(
    const std::string& name, PVP_ONEGAMEEND_REASON* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PVP_ONEGAMEEND_REASON_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<PVP_ONEGAMEEND_REASON>(int_value);
  }
  return success;
}
bool SynsMsType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SynsMsType_strings[2] = {};

static const char SynsMsType_names[] =
  "SynsGuild"
  "SynsTeam";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SynsMsType_entries[] = {
  { {SynsMsType_names + 0, 9}, 1 },
  { {SynsMsType_names + 9, 8}, 2 },
};

static const int SynsMsType_entries_by_number[] = {
  0, // 1 -> SynsGuild
  1, // 2 -> SynsTeam
};

const std::string& SynsMsType_Name(
    SynsMsType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SynsMsType_entries,
          SynsMsType_entries_by_number,
          2, SynsMsType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SynsMsType_entries,
      SynsMsType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SynsMsType_strings[idx].get();
}
bool SynsMsType_Parse(
    const std::string& name, SynsMsType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SynsMsType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<SynsMsType>(int_value);
  }
  return success;
}
bool SynsMsSubType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SynsMsSubType_strings[9] = {};

static const char SynsMsSubType_names[] =
  "SynAddExp"
  "SynSetTime"
  "SynsAdd"
  "SynsCreate"
  "SynsDel"
  "SynsDestory"
  "SynsIcon"
  "SynsLead"
  "SynsLevel";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SynsMsSubType_entries[] = {
  { {SynsMsSubType_names + 0, 9}, 8 },
  { {SynsMsSubType_names + 9, 10}, 9 },
  { {SynsMsSubType_names + 19, 7}, 3 },
  { {SynsMsSubType_names + 26, 10}, 1 },
  { {SynsMsSubType_names + 36, 7}, 4 },
  { {SynsMsSubType_names + 43, 11}, 2 },
  { {SynsMsSubType_names + 54, 8}, 7 },
  { {SynsMsSubType_names + 62, 8}, 5 },
  { {SynsMsSubType_names + 70, 9}, 6 },
};

static const int SynsMsSubType_entries_by_number[] = {
  3, // 1 -> SynsCreate
  5, // 2 -> SynsDestory
  2, // 3 -> SynsAdd
  4, // 4 -> SynsDel
  7, // 5 -> SynsLead
  8, // 6 -> SynsLevel
  6, // 7 -> SynsIcon
  0, // 8 -> SynAddExp
  1, // 9 -> SynSetTime
};

const std::string& SynsMsSubType_Name(
    SynsMsSubType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SynsMsSubType_entries,
          SynsMsSubType_entries_by_number,
          9, SynsMsSubType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SynsMsSubType_entries,
      SynsMsSubType_entries_by_number,
      9, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SynsMsSubType_strings[idx].get();
}
bool SynsMsSubType_Parse(
    const std::string& name, SynsMsSubType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SynsMsSubType_entries, 9, name, &int_value);
  if (success) {
    *value = static_cast<SynsMsSubType>(int_value);
  }
  return success;
}
bool NoticeType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> NoticeType_strings[6] = {};

static const char NoticeType_names[] =
  "Notice_Guild"
  "Notice_Partner"
  "Notice_Role"
  "Notice_Server"
  "Notice_Team"
  "Notice_World";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry NoticeType_entries[] = {
  { {NoticeType_names + 0, 12}, 3 },
  { {NoticeType_names + 12, 14}, 5 },
  { {NoticeType_names + 26, 11}, 1 },
  { {NoticeType_names + 37, 13}, 6 },
  { {NoticeType_names + 50, 11}, 2 },
  { {NoticeType_names + 61, 12}, 4 },
};

static const int NoticeType_entries_by_number[] = {
  2, // 1 -> Notice_Role
  4, // 2 -> Notice_Team
  0, // 3 -> Notice_Guild
  5, // 4 -> Notice_World
  1, // 5 -> Notice_Partner
  3, // 6 -> Notice_Server
};

const std::string& NoticeType_Name(
    NoticeType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          NoticeType_entries,
          NoticeType_entries_by_number,
          6, NoticeType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      NoticeType_entries,
      NoticeType_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     NoticeType_strings[idx].get();
}
bool NoticeType_Parse(
    const std::string& name, NoticeType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      NoticeType_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<NoticeType>(int_value);
  }
  return success;
}
bool MSGiveItemType_IsValid(int value) {
  switch (value) {
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> MSGiveItemType_strings[1] = {};

static const char MSGiveItemType_names[] =
  "MSItem_FriendGift";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry MSGiveItemType_entries[] = {
  { {MSGiveItemType_names + 0, 17}, 1 },
};

static const int MSGiveItemType_entries_by_number[] = {
  0, // 1 -> MSItem_FriendGift
};

const std::string& MSGiveItemType_Name(
    MSGiveItemType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          MSGiveItemType_entries,
          MSGiveItemType_entries_by_number,
          1, MSGiveItemType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      MSGiveItemType_entries,
      MSGiveItemType_entries_by_number,
      1, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     MSGiveItemType_strings[idx].get();
}
bool MSGiveItemType_Parse(
    const std::string& name, MSGiveItemType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      MSGiveItemType_entries, 1, name, &int_value);
  if (success) {
    *value = static_cast<MSGiveItemType>(int_value);
  }
  return success;
}
bool RoleState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> RoleState_strings[4] = {};

static const char RoleState_names[] =
  "InBattle"
  "InHall"
  "LoadScene"
  "Logoff";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry RoleState_entries[] = {
  { {RoleState_names + 0, 8}, 3 },
  { {RoleState_names + 8, 6}, 2 },
  { {RoleState_names + 14, 9}, 1 },
  { {RoleState_names + 23, 6}, 0 },
};

static const int RoleState_entries_by_number[] = {
  3, // 0 -> Logoff
  2, // 1 -> LoadScene
  1, // 2 -> InHall
  0, // 3 -> InBattle
};

const std::string& RoleState_Name(
    RoleState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          RoleState_entries,
          RoleState_entries_by_number,
          4, RoleState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      RoleState_entries,
      RoleState_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     RoleState_strings[idx].get();
}
bool RoleState_Parse(
    const std::string& name, RoleState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      RoleState_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<RoleState>(int_value);
  }
  return success;
}
bool SyncTeamM2C_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SyncTeamM2C_strings[9] = {};

static const char SyncTeamM2C_names[] =
  "STM2C_ADD_MEMBER"
  "STM2C_ALL_DATA"
  "STM2C_CREATE_TEAM"
  "STM2C_DEL_MEMBER"
  "STM2C_DESTROY"
  "STM2C_GETEXTRADATA"
  "STM2C_RESETCOST"
  "STM2C_TEAM_LIST"
  "STM2C_TS_DISCONNECTED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SyncTeamM2C_entries[] = {
  { {SyncTeamM2C_names + 0, 16}, 2 },
  { {SyncTeamM2C_names + 16, 14}, 4 },
  { {SyncTeamM2C_names + 30, 17}, 1 },
  { {SyncTeamM2C_names + 47, 16}, 3 },
  { {SyncTeamM2C_names + 63, 13}, 6 },
  { {SyncTeamM2C_names + 76, 18}, 7 },
  { {SyncTeamM2C_names + 94, 15}, 8 },
  { {SyncTeamM2C_names + 109, 15}, 5 },
  { {SyncTeamM2C_names + 124, 21}, 9 },
};

static const int SyncTeamM2C_entries_by_number[] = {
  2, // 1 -> STM2C_CREATE_TEAM
  0, // 2 -> STM2C_ADD_MEMBER
  3, // 3 -> STM2C_DEL_MEMBER
  1, // 4 -> STM2C_ALL_DATA
  7, // 5 -> STM2C_TEAM_LIST
  4, // 6 -> STM2C_DESTROY
  5, // 7 -> STM2C_GETEXTRADATA
  6, // 8 -> STM2C_RESETCOST
  8, // 9 -> STM2C_TS_DISCONNECTED
};

const std::string& SyncTeamM2C_Name(
    SyncTeamM2C value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SyncTeamM2C_entries,
          SyncTeamM2C_entries_by_number,
          9, SyncTeamM2C_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SyncTeamM2C_entries,
      SyncTeamM2C_entries_by_number,
      9, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SyncTeamM2C_strings[idx].get();
}
bool SyncTeamM2C_Parse(
    const std::string& name, SyncTeamM2C* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SyncTeamM2C_entries, 9, name, &int_value);
  if (success) {
    *value = static_cast<SyncTeamM2C>(int_value);
  }
  return success;
}
bool PayCardType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PayCardType_strings[2] = {};

static const char PayCardType_names[] =
  "MONTH_CARD"
  "WEEK_CARD";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PayCardType_entries[] = {
  { {PayCardType_names + 0, 10}, 2 },
  { {PayCardType_names + 10, 9}, 1 },
};

static const int PayCardType_entries_by_number[] = {
  1, // 1 -> WEEK_CARD
  0, // 2 -> MONTH_CARD
};

const std::string& PayCardType_Name(
    PayCardType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PayCardType_entries,
          PayCardType_entries_by_number,
          2, PayCardType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PayCardType_entries,
      PayCardType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PayCardType_strings[idx].get();
}
bool PayCardType_Parse(
    const std::string& name, PayCardType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PayCardType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<PayCardType>(int_value);
  }
  return success;
}
bool PayParamType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PayParamType_strings[7] = {};

static const char PayParamType_names[] =
  "PAY_PARAM_AILEEN"
  "PAY_PARAM_CARD"
  "PAY_PARAM_FIRSTAWARD"
  "PAY_PARAM_GROWTH_FUND"
  "PAY_PARAM_LIST"
  "PAY_PARAM_MEMBER"
  "PAY_PARAM_NONE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PayParamType_entries[] = {
  { {PayParamType_names + 0, 16}, 2 },
  { {PayParamType_names + 16, 14}, 3 },
  { {PayParamType_names + 30, 20}, 4 },
  { {PayParamType_names + 50, 21}, 5 },
  { {PayParamType_names + 71, 14}, 1 },
  { {PayParamType_names + 85, 16}, 6 },
  { {PayParamType_names + 101, 14}, 0 },
};

static const int PayParamType_entries_by_number[] = {
  6, // 0 -> PAY_PARAM_NONE
  4, // 1 -> PAY_PARAM_LIST
  0, // 2 -> PAY_PARAM_AILEEN
  1, // 3 -> PAY_PARAM_CARD
  2, // 4 -> PAY_PARAM_FIRSTAWARD
  3, // 5 -> PAY_PARAM_GROWTH_FUND
  5, // 6 -> PAY_PARAM_MEMBER
};

const std::string& PayParamType_Name(
    PayParamType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PayParamType_entries,
          PayParamType_entries_by_number,
          7, PayParamType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PayParamType_entries,
      PayParamType_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PayParamType_strings[idx].get();
}
bool PayParamType_Parse(
    const std::string& name, PayParamType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PayParamType_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<PayParamType>(int_value);
  }
  return success;
}
bool PayButtonStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PayButtonStatus_strings[3] = {};

static const char PayButtonStatus_names[] =
  "PAY_BUTTON_CLICK"
  "PAY_BUTTON_NONE"
  "PAY_BUTTON_OPEN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PayButtonStatus_entries[] = {
  { {PayButtonStatus_names + 0, 16}, 2 },
  { {PayButtonStatus_names + 16, 15}, 0 },
  { {PayButtonStatus_names + 31, 15}, 1 },
};

static const int PayButtonStatus_entries_by_number[] = {
  1, // 0 -> PAY_BUTTON_NONE
  2, // 1 -> PAY_BUTTON_OPEN
  0, // 2 -> PAY_BUTTON_CLICK
};

const std::string& PayButtonStatus_Name(
    PayButtonStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PayButtonStatus_entries,
          PayButtonStatus_entries_by_number,
          3, PayButtonStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PayButtonStatus_entries,
      PayButtonStatus_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PayButtonStatus_strings[idx].get();
}
bool PayButtonStatus_Parse(
    const std::string& name, PayButtonStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PayButtonStatus_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<PayButtonStatus>(int_value);
  }
  return success;
}
bool MSUseSumamryType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> MSUseSumamryType_strings[2] = {};

static const char MSUseSumamryType_names[] =
  "MSUS_FREE"
  "MSUS_GET";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry MSUseSumamryType_entries[] = {
  { {MSUseSumamryType_names + 0, 9}, 2 },
  { {MSUseSumamryType_names + 9, 8}, 1 },
};

static const int MSUseSumamryType_entries_by_number[] = {
  1, // 1 -> MSUS_GET
  0, // 2 -> MSUS_FREE
};

const std::string& MSUseSumamryType_Name(
    MSUseSumamryType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          MSUseSumamryType_entries,
          MSUseSumamryType_entries_by_number,
          2, MSUseSumamryType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      MSUseSumamryType_entries,
      MSUseSumamryType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     MSUseSumamryType_strings[idx].get();
}
bool MSUseSumamryType_Parse(
    const std::string& name, MSUseSumamryType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      MSUseSumamryType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<MSUseSumamryType>(int_value);
  }
  return success;
}
bool TeamEventG2M_IsValid(int value) {
  switch (value) {
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TeamEventG2M_strings[1] = {};

static const char TeamEventG2M_names[] =
  "TEAM_EVENT_BUYCOUNT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TeamEventG2M_entries[] = {
  { {TeamEventG2M_names + 0, 19}, 1 },
};

static const int TeamEventG2M_entries_by_number[] = {
  0, // 1 -> TEAM_EVENT_BUYCOUNT
};

const std::string& TeamEventG2M_Name(
    TeamEventG2M value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TeamEventG2M_entries,
          TeamEventG2M_entries_by_number,
          1, TeamEventG2M_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TeamEventG2M_entries,
      TeamEventG2M_entries_by_number,
      1, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TeamEventG2M_strings[idx].get();
}
bool TeamEventG2M_Parse(
    const std::string& name, TeamEventG2M* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TeamEventG2M_entries, 1, name, &int_value);
  if (success) {
    *value = static_cast<TeamEventG2M>(int_value);
  }
  return success;
}
bool PkReqType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PkReqType_strings[4] = {};

static const char PkReqType_names[] =
  "PKREQ_ADDPK"
  "PKREQ_ALLINFO"
  "PKREQ_FETCHPOINTREWARD"
  "PKREQ_REMOVEPK";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PkReqType_entries[] = {
  { {PkReqType_names + 0, 11}, 1 },
  { {PkReqType_names + 11, 13}, 3 },
  { {PkReqType_names + 24, 22}, 4 },
  { {PkReqType_names + 46, 14}, 2 },
};

static const int PkReqType_entries_by_number[] = {
  0, // 1 -> PKREQ_ADDPK
  3, // 2 -> PKREQ_REMOVEPK
  1, // 3 -> PKREQ_ALLINFO
  2, // 4 -> PKREQ_FETCHPOINTREWARD
};

const std::string& PkReqType_Name(
    PkReqType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PkReqType_entries,
          PkReqType_entries_by_number,
          4, PkReqType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PkReqType_entries,
      PkReqType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PkReqType_strings[idx].get();
}
bool PkReqType_Parse(
    const std::string& name, PkReqType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PkReqType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<PkReqType>(int_value);
  }
  return success;
}
bool AuctionReqType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AuctionReqType_strings[3] = {};

static const char AuctionReqType_names[] =
  "AUCTION_BUYNOW"
  "AUCTION_ONSALE"
  "AUCTION_OUTSALE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AuctionReqType_entries[] = {
  { {AuctionReqType_names + 0, 14}, 3 },
  { {AuctionReqType_names + 14, 14}, 1 },
  { {AuctionReqType_names + 28, 15}, 2 },
};

static const int AuctionReqType_entries_by_number[] = {
  1, // 1 -> AUCTION_ONSALE
  2, // 2 -> AUCTION_OUTSALE
  0, // 3 -> AUCTION_BUYNOW
};

const std::string& AuctionReqType_Name(
    AuctionReqType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          AuctionReqType_entries,
          AuctionReqType_entries_by_number,
          3, AuctionReqType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      AuctionReqType_entries,
      AuctionReqType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     AuctionReqType_strings[idx].get();
}
bool AuctionReqType_Parse(
    const std::string& name, AuctionReqType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      AuctionReqType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<AuctionReqType>(int_value);
  }
  return success;
}
bool PunishType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PunishType_strings[16] = {};

static const char PunishType_names[] =
  "PUNISH_NONE"
  "PUNISH_USER_ARENA_RANK"
  "PUNISH_USER_CHAT"
  "PUNISH_USER_DAILY_PLAY"
  "PUNISH_USER_FLOWER_RANK"
  "PUNISH_USER_GUILDBOSS_RANK"
  "PUNISH_USER_GUILD_RANK"
  "PUNISH_USER_HG"
  "PUNISH_USER_LOGIN"
  "PUNISH_USER_MULTI_ACTIVITY"
  "PUNISH_USER_PK_RANK"
  "PUNISH_USER_ROLE_GUILDBOSS"
  "PUNISH_USER_TEMP"
  "PUNISH_USER_TOWER"
  "PUNISH_USER_WORLDBOSS_RANK"
  "PUNISH_USER_ZERO_PROFIT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PunishType_entries[] = {
  { {PunishType_names + 0, 11}, 0 },
  { {PunishType_names + 11, 22}, 7 },
  { {PunishType_names + 33, 16}, 2 },
  { {PunishType_names + 49, 22}, 13 },
  { {PunishType_names + 71, 23}, 9 },
  { {PunishType_names + 94, 26}, 11 },
  { {PunishType_names + 120, 22}, 10 },
  { {PunishType_names + 142, 14}, 15 },
  { {PunishType_names + 156, 17}, 1 },
  { {PunishType_names + 173, 26}, 14 },
  { {PunishType_names + 199, 19}, 6 },
  { {PunishType_names + 218, 26}, 5 },
  { {PunishType_names + 244, 16}, 3 },
  { {PunishType_names + 260, 17}, 8 },
  { {PunishType_names + 277, 26}, 4 },
  { {PunishType_names + 303, 23}, 12 },
};

static const int PunishType_entries_by_number[] = {
  0, // 0 -> PUNISH_NONE
  8, // 1 -> PUNISH_USER_LOGIN
  2, // 2 -> PUNISH_USER_CHAT
  12, // 3 -> PUNISH_USER_TEMP
  14, // 4 -> PUNISH_USER_WORLDBOSS_RANK
  11, // 5 -> PUNISH_USER_ROLE_GUILDBOSS
  10, // 6 -> PUNISH_USER_PK_RANK
  1, // 7 -> PUNISH_USER_ARENA_RANK
  13, // 8 -> PUNISH_USER_TOWER
  4, // 9 -> PUNISH_USER_FLOWER_RANK
  6, // 10 -> PUNISH_USER_GUILD_RANK
  5, // 11 -> PUNISH_USER_GUILDBOSS_RANK
  15, // 12 -> PUNISH_USER_ZERO_PROFIT
  3, // 13 -> PUNISH_USER_DAILY_PLAY
  9, // 14 -> PUNISH_USER_MULTI_ACTIVITY
  7, // 15 -> PUNISH_USER_HG
};

const std::string& PunishType_Name(
    PunishType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PunishType_entries,
          PunishType_entries_by_number,
          16, PunishType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PunishType_entries,
      PunishType_entries_by_number,
      16, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PunishType_strings[idx].get();
}
bool PunishType_Parse(
    const std::string& name, PunishType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PunishType_entries, 16, name, &int_value);
  if (success) {
    *value = static_cast<PunishType>(int_value);
  }
  return success;
}
bool PunishDataType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PunishDataType_strings[2] = {};

static const char PunishDataType_names[] =
  "PUNISH_DATA_DELETE"
  "PUNISH_DATA_UPATE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PunishDataType_entries[] = {
  { {PunishDataType_names + 0, 18}, 2 },
  { {PunishDataType_names + 18, 17}, 1 },
};

static const int PunishDataType_entries_by_number[] = {
  1, // 1 -> PUNISH_DATA_UPATE
  0, // 2 -> PUNISH_DATA_DELETE
};

const std::string& PunishDataType_Name(
    PunishDataType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PunishDataType_entries,
          PunishDataType_entries_by_number,
          2, PunishDataType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PunishDataType_entries,
      PunishDataType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PunishDataType_strings[idx].get();
}
bool PunishDataType_Parse(
    const std::string& name, PunishDataType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PunishDataType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<PunishDataType>(int_value);
  }
  return success;
}
bool ServerTag_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ServerTag_strings[2] = {};

static const char ServerTag_names[] =
  "SERVER_TAG_IOS_AUDIT"
  "SERVER_TAG_NORMAL";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ServerTag_entries[] = {
  { {ServerTag_names + 0, 20}, 2 },
  { {ServerTag_names + 20, 17}, 1 },
};

static const int ServerTag_entries_by_number[] = {
  1, // 1 -> SERVER_TAG_NORMAL
  0, // 2 -> SERVER_TAG_IOS_AUDIT
};

const std::string& ServerTag_Name(
    ServerTag value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ServerTag_entries,
          ServerTag_entries_by_number,
          2, ServerTag_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ServerTag_entries,
      ServerTag_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ServerTag_strings[idx].get();
}
bool ServerTag_Parse(
    const std::string& name, ServerTag* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ServerTag_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<ServerTag>(int_value);
  }
  return success;
}
bool ItemFindBackType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ItemFindBackType_strings[16] = {};

static const char ItemFindBackType_names[] =
  "COMMERCETASK_BACK"
  "DICE_BACK"
  "DRAGONEXP_BACK"
  "DayActiveBack"
  "FATIGUE_BUY"
  "FATIGUE_GET"
  "FATIGUE_RECOVER"
  "FINDBACK_MAX"
  "GUILDACTIVITY"
  "GUILDCHECKIN_BACK"
  "GUILD_VOICE"
  "NVSHENSHILIAN"
  "NestBack"
  "QAMULTI_BACK"
  "TOWER"
  "WUJINSHENYUAN_BACK";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ItemFindBackType_entries[] = {
  { {ItemFindBackType_names + 0, 17}, 13 },
  { {ItemFindBackType_names + 17, 9}, 7 },
  { {ItemFindBackType_names + 26, 14}, 9 },
  { {ItemFindBackType_names + 40, 13}, 14 },
  { {ItemFindBackType_names + 53, 11}, 6 },
  { {ItemFindBackType_names + 64, 11}, 5 },
  { {ItemFindBackType_names + 75, 15}, 4 },
  { {ItemFindBackType_names + 90, 12}, 16 },
  { {ItemFindBackType_names + 102, 13}, 3 },
  { {ItemFindBackType_names + 115, 17}, 11 },
  { {ItemFindBackType_names + 132, 11}, 12 },
  { {ItemFindBackType_names + 143, 13}, 2 },
  { {ItemFindBackType_names + 156, 8}, 15 },
  { {ItemFindBackType_names + 164, 12}, 10 },
  { {ItemFindBackType_names + 176, 5}, 1 },
  { {ItemFindBackType_names + 181, 18}, 8 },
};

static const int ItemFindBackType_entries_by_number[] = {
  14, // 1 -> TOWER
  11, // 2 -> NVSHENSHILIAN
  8, // 3 -> GUILDACTIVITY
  6, // 4 -> FATIGUE_RECOVER
  5, // 5 -> FATIGUE_GET
  4, // 6 -> FATIGUE_BUY
  1, // 7 -> DICE_BACK
  15, // 8 -> WUJINSHENYUAN_BACK
  2, // 9 -> DRAGONEXP_BACK
  13, // 10 -> QAMULTI_BACK
  9, // 11 -> GUILDCHECKIN_BACK
  10, // 12 -> GUILD_VOICE
  0, // 13 -> COMMERCETASK_BACK
  3, // 14 -> DayActiveBack
  12, // 15 -> NestBack
  7, // 16 -> FINDBACK_MAX
};

const std::string& ItemFindBackType_Name(
    ItemFindBackType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ItemFindBackType_entries,
          ItemFindBackType_entries_by_number,
          16, ItemFindBackType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ItemFindBackType_entries,
      ItemFindBackType_entries_by_number,
      16, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ItemFindBackType_strings[idx].get();
}
bool ItemFindBackType_Parse(
    const std::string& name, ItemFindBackType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ItemFindBackType_entries, 16, name, &int_value);
  if (success) {
    *value = static_cast<ItemFindBackType>(int_value);
  }
  return success;
}
bool OutLookType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> OutLookType_strings[2] = {};

static const char OutLookType_names[] =
  "OutLook_Equip"
  "OutLook_Fashion";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry OutLookType_entries[] = {
  { {OutLookType_names + 0, 13}, 1 },
  { {OutLookType_names + 13, 15}, 0 },
};

static const int OutLookType_entries_by_number[] = {
  1, // 0 -> OutLook_Fashion
  0, // 1 -> OutLook_Equip
};

const std::string& OutLookType_Name(
    OutLookType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          OutLookType_entries,
          OutLookType_entries_by_number,
          2, OutLookType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      OutLookType_entries,
      OutLookType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     OutLookType_strings[idx].get();
}
bool OutLookType_Parse(
    const std::string& name, OutLookType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      OutLookType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<OutLookType>(int_value);
  }
  return success;
}
bool SpriteType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SpriteType_strings[13] = {};

static const char SpriteType_names[] =
  "Sprite_Awake"
  "Sprite_Awake_Replace"
  "Sprite_Awake_Retain"
  "Sprite_Decompose"
  "Sprite_Evolution"
  "Sprite_Feed"
  "Sprite_InFight"
  "Sprite_OutFight"
  "Sprite_QueryEvolutionPPT"
  "Sprite_Rebirth"
  "Sprite_ResetTrain"
  "Sprite_SwapLeader"
  "Sprite_Train";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SpriteType_entries[] = {
  { {SpriteType_names + 0, 12}, 3 },
  { {SpriteType_names + 12, 20}, 5 },
  { {SpriteType_names + 32, 19}, 4 },
  { {SpriteType_names + 51, 16}, 8 },
  { {SpriteType_names + 67, 16}, 2 },
  { {SpriteType_names + 83, 11}, 1 },
  { {SpriteType_names + 94, 14}, 6 },
  { {SpriteType_names + 108, 15}, 7 },
  { {SpriteType_names + 123, 24}, 10 },
  { {SpriteType_names + 147, 14}, 13 },
  { {SpriteType_names + 161, 17}, 12 },
  { {SpriteType_names + 178, 17}, 9 },
  { {SpriteType_names + 195, 12}, 11 },
};

static const int SpriteType_entries_by_number[] = {
  5, // 1 -> Sprite_Feed
  4, // 2 -> Sprite_Evolution
  0, // 3 -> Sprite_Awake
  2, // 4 -> Sprite_Awake_Retain
  1, // 5 -> Sprite_Awake_Replace
  6, // 6 -> Sprite_InFight
  7, // 7 -> Sprite_OutFight
  3, // 8 -> Sprite_Decompose
  11, // 9 -> Sprite_SwapLeader
  8, // 10 -> Sprite_QueryEvolutionPPT
  12, // 11 -> Sprite_Train
  10, // 12 -> Sprite_ResetTrain
  9, // 13 -> Sprite_Rebirth
};

const std::string& SpriteType_Name(
    SpriteType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SpriteType_entries,
          SpriteType_entries_by_number,
          13, SpriteType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SpriteType_entries,
      SpriteType_entries_by_number,
      13, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SpriteType_strings[idx].get();
}
bool SpriteType_Parse(
    const std::string& name, SpriteType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SpriteType_entries, 13, name, &int_value);
  if (success) {
    *value = static_cast<SpriteType>(int_value);
  }
  return success;
}
bool RiskGridType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> RiskGridType_strings[6] = {};

static const char RiskGridType_names[] =
  "RISK_GRID_ADVENTURE"
  "RISK_GRID_DICE"
  "RISK_GRID_EMPTY"
  "RISK_GRID_MAX"
  "RISK_GRID_NORMALREWARD"
  "RISK_GRID_REWARDBOX";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry RiskGridType_entries[] = {
  { {RiskGridType_names + 0, 19}, 4 },
  { {RiskGridType_names + 19, 14}, 5 },
  { {RiskGridType_names + 33, 15}, 1 },
  { {RiskGridType_names + 48, 13}, 6 },
  { {RiskGridType_names + 61, 22}, 2 },
  { {RiskGridType_names + 83, 19}, 3 },
};

static const int RiskGridType_entries_by_number[] = {
  2, // 1 -> RISK_GRID_EMPTY
  4, // 2 -> RISK_GRID_NORMALREWARD
  5, // 3 -> RISK_GRID_REWARDBOX
  0, // 4 -> RISK_GRID_ADVENTURE
  1, // 5 -> RISK_GRID_DICE
  3, // 6 -> RISK_GRID_MAX
};

const std::string& RiskGridType_Name(
    RiskGridType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          RiskGridType_entries,
          RiskGridType_entries_by_number,
          6, RiskGridType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      RiskGridType_entries,
      RiskGridType_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     RiskGridType_strings[idx].get();
}
bool RiskGridType_Parse(
    const std::string& name, RiskGridType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      RiskGridType_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<RiskGridType>(int_value);
  }
  return success;
}
bool RiskBoxState_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> RiskBoxState_strings[5] = {};

static const char RiskBoxState_names[] =
  "RISK_BOX_CANGETREWARD"
  "RISK_BOX_DELETE"
  "RISK_BOX_GETREWARD"
  "RISK_BOX_LOCKED"
  "RISK_BOX_UNLOCKED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry RiskBoxState_entries[] = {
  { {RiskBoxState_names + 0, 21}, 3 },
  { {RiskBoxState_names + 21, 15}, 5 },
  { {RiskBoxState_names + 36, 18}, 4 },
  { {RiskBoxState_names + 54, 15}, 1 },
  { {RiskBoxState_names + 69, 17}, 2 },
};

static const int RiskBoxState_entries_by_number[] = {
  3, // 1 -> RISK_BOX_LOCKED
  4, // 2 -> RISK_BOX_UNLOCKED
  0, // 3 -> RISK_BOX_CANGETREWARD
  2, // 4 -> RISK_BOX_GETREWARD
  1, // 5 -> RISK_BOX_DELETE
};

const std::string& RiskBoxState_Name(
    RiskBoxState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          RiskBoxState_entries,
          RiskBoxState_entries_by_number,
          5, RiskBoxState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      RiskBoxState_entries,
      RiskBoxState_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     RiskBoxState_strings[idx].get();
}
bool RiskBoxState_Parse(
    const std::string& name, RiskBoxState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      RiskBoxState_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<RiskBoxState>(int_value);
  }
  return success;
}
bool DEProgressState_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DEProgressState_strings[3] = {};

static const char DEProgressState_names[] =
  "DEPS_FIGHT"
  "DEPS_FINISH"
  "DEPS_NOTOPEN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DEProgressState_entries[] = {
  { {DEProgressState_names + 0, 10}, 2 },
  { {DEProgressState_names + 10, 11}, 1 },
  { {DEProgressState_names + 21, 12}, 3 },
};

static const int DEProgressState_entries_by_number[] = {
  1, // 1 -> DEPS_FINISH
  0, // 2 -> DEPS_FIGHT
  2, // 3 -> DEPS_NOTOPEN
};

const std::string& DEProgressState_Name(
    DEProgressState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DEProgressState_entries,
          DEProgressState_entries_by_number,
          3, DEProgressState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DEProgressState_entries,
      DEProgressState_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DEProgressState_strings[idx].get();
}
bool DEProgressState_Parse(
    const std::string& name, DEProgressState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DEProgressState_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<DEProgressState>(int_value);
  }
  return success;
}
bool ReviveType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ReviveType_strings[7] = {};

static const char ReviveType_names[] =
  "ReviveFree"
  "ReviveItem"
  "ReviveMax"
  "ReviveMoney"
  "ReviveNone"
  "ReviveSprite"
  "ReviveVIP";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ReviveType_entries[] = {
  { {ReviveType_names + 0, 10}, 1 },
  { {ReviveType_names + 10, 10}, 2 },
  { {ReviveType_names + 20, 9}, 6 },
  { {ReviveType_names + 29, 11}, 3 },
  { {ReviveType_names + 40, 10}, 0 },
  { {ReviveType_names + 50, 12}, 4 },
  { {ReviveType_names + 62, 9}, 5 },
};

static const int ReviveType_entries_by_number[] = {
  4, // 0 -> ReviveNone
  0, // 1 -> ReviveFree
  1, // 2 -> ReviveItem
  3, // 3 -> ReviveMoney
  5, // 4 -> ReviveSprite
  6, // 5 -> ReviveVIP
  2, // 6 -> ReviveMax
};

const std::string& ReviveType_Name(
    ReviveType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ReviveType_entries,
          ReviveType_entries_by_number,
          7, ReviveType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ReviveType_entries,
      ReviveType_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ReviveType_strings[idx].get();
}
bool ReviveType_Parse(
    const std::string& name, ReviveType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ReviveType_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<ReviveType>(int_value);
  }
  return success;
}
bool GuildOpType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GuildOpType_strings[2] = {};

static const char GuildOpType_names[] =
  "GUILD_DARE_INFO"
  "STUDY_SKILL";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GuildOpType_entries[] = {
  { {GuildOpType_names + 0, 15}, 2 },
  { {GuildOpType_names + 15, 11}, 1 },
};

static const int GuildOpType_entries_by_number[] = {
  1, // 1 -> STUDY_SKILL
  0, // 2 -> GUILD_DARE_INFO
};

const std::string& GuildOpType_Name(
    GuildOpType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GuildOpType_entries,
          GuildOpType_entries_by_number,
          2, GuildOpType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GuildOpType_entries,
      GuildOpType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GuildOpType_strings[idx].get();
}
bool GuildOpType_Parse(
    const std::string& name, GuildOpType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GuildOpType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<GuildOpType>(int_value);
  }
  return success;
}
bool AuctionAllReqType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AuctionAllReqType_strings[11] = {};

static const char AuctionAllReqType_names[] =
  "ART_ALLITEMBRIEF"
  "ART_BUY"
  "ART_ITEMDATA"
  "ART_MYSALE"
  "ART_QUITSALE"
  "ART_REFRESH_AUTO"
  "ART_REFRESH_FREE"
  "ART_REFRESH_PAY"
  "ART_REQSALE"
  "ART_RESALE"
  "ART_TRADE_PRICE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AuctionAllReqType_entries[] = {
  { {AuctionAllReqType_names + 0, 16}, 4 },
  { {AuctionAllReqType_names + 16, 7}, 7 },
  { {AuctionAllReqType_names + 23, 12}, 5 },
  { {AuctionAllReqType_names + 35, 10}, 6 },
  { {AuctionAllReqType_names + 45, 12}, 2 },
  { {AuctionAllReqType_names + 57, 16}, 11 },
  { {AuctionAllReqType_names + 73, 16}, 8 },
  { {AuctionAllReqType_names + 89, 15}, 9 },
  { {AuctionAllReqType_names + 104, 11}, 1 },
  { {AuctionAllReqType_names + 115, 10}, 3 },
  { {AuctionAllReqType_names + 125, 15}, 10 },
};

static const int AuctionAllReqType_entries_by_number[] = {
  8, // 1 -> ART_REQSALE
  4, // 2 -> ART_QUITSALE
  9, // 3 -> ART_RESALE
  0, // 4 -> ART_ALLITEMBRIEF
  2, // 5 -> ART_ITEMDATA
  3, // 6 -> ART_MYSALE
  1, // 7 -> ART_BUY
  6, // 8 -> ART_REFRESH_FREE
  7, // 9 -> ART_REFRESH_PAY
  10, // 10 -> ART_TRADE_PRICE
  5, // 11 -> ART_REFRESH_AUTO
};

const std::string& AuctionAllReqType_Name(
    AuctionAllReqType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          AuctionAllReqType_entries,
          AuctionAllReqType_entries_by_number,
          11, AuctionAllReqType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      AuctionAllReqType_entries,
      AuctionAllReqType_entries_by_number,
      11, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     AuctionAllReqType_strings[idx].get();
}
bool AuctionAllReqType_Parse(
    const std::string& name, AuctionAllReqType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      AuctionAllReqType_entries, 11, name, &int_value);
  if (success) {
    *value = static_cast<AuctionAllReqType>(int_value);
  }
  return success;
}
bool ItemEnum_IsValid(int value) {
  switch (value) {
    case 50:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ItemEnum_strings[1] = {};

static const char ItemEnum_names[] =
  "Virtual_Max";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ItemEnum_entries[] = {
  { {ItemEnum_names + 0, 11}, 50 },
};

static const int ItemEnum_entries_by_number[] = {
  0, // 50 -> Virtual_Max
};

const std::string& ItemEnum_Name(
    ItemEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ItemEnum_entries,
          ItemEnum_entries_by_number,
          1, ItemEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ItemEnum_entries,
      ItemEnum_entries_by_number,
      1, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ItemEnum_strings[idx].get();
}
bool ItemEnum_Parse(
    const std::string& name, ItemEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ItemEnum_entries, 1, name, &int_value);
  if (success) {
    *value = static_cast<ItemEnum>(int_value);
  }
  return success;
}
bool GuildCardOp_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GuildCardOp_strings[4] = {};

static const char GuildCardOp_names[] =
  "GuildCard_Change"
  "GuildCard_End"
  "GuildCard_Query"
  "GuildCard_Start";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GuildCardOp_entries[] = {
  { {GuildCardOp_names + 0, 16}, 3 },
  { {GuildCardOp_names + 16, 13}, 4 },
  { {GuildCardOp_names + 29, 15}, 1 },
  { {GuildCardOp_names + 44, 15}, 2 },
};

static const int GuildCardOp_entries_by_number[] = {
  2, // 1 -> GuildCard_Query
  3, // 2 -> GuildCard_Start
  0, // 3 -> GuildCard_Change
  1, // 4 -> GuildCard_End
};

const std::string& GuildCardOp_Name(
    GuildCardOp value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GuildCardOp_entries,
          GuildCardOp_entries_by_number,
          4, GuildCardOp_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GuildCardOp_entries,
      GuildCardOp_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GuildCardOp_strings[idx].get();
}
bool GuildCardOp_Parse(
    const std::string& name, GuildCardOp* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GuildCardOp_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<GuildCardOp>(int_value);
  }
  return success;
}
bool PkResultType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PkResultType_strings[3] = {};

static const char PkResultType_names[] =
  "PkResult_Draw"
  "PkResult_Lose"
  "PkResult_Win";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PkResultType_entries[] = {
  { {PkResultType_names + 0, 13}, 3 },
  { {PkResultType_names + 13, 13}, 2 },
  { {PkResultType_names + 26, 12}, 1 },
};

static const int PkResultType_entries_by_number[] = {
  2, // 1 -> PkResult_Win
  1, // 2 -> PkResult_Lose
  0, // 3 -> PkResult_Draw
};

const std::string& PkResultType_Name(
    PkResultType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PkResultType_entries,
          PkResultType_entries_by_number,
          3, PkResultType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PkResultType_entries,
      PkResultType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PkResultType_strings[idx].get();
}
bool PkResultType_Parse(
    const std::string& name, PkResultType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PkResultType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<PkResultType>(int_value);
  }
  return success;
}
bool HallIconState_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> HallIconState_strings[2] = {};

static const char HallIconState_names[] =
  "HICONS_BEGIN"
  "HICONS_END";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry HallIconState_entries[] = {
  { {HallIconState_names + 0, 12}, 1 },
  { {HallIconState_names + 12, 10}, 2 },
};

static const int HallIconState_entries_by_number[] = {
  0, // 1 -> HICONS_BEGIN
  1, // 2 -> HICONS_END
};

const std::string& HallIconState_Name(
    HallIconState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          HallIconState_entries,
          HallIconState_entries_by_number,
          2, HallIconState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      HallIconState_entries,
      HallIconState_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     HallIconState_strings[idx].get();
}
bool HallIconState_Parse(
    const std::string& name, HallIconState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      HallIconState_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<HallIconState>(int_value);
  }
  return success;
}
bool TaskStatus_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TaskStatus_strings[4] = {};

static const char TaskStatus_names[] =
  "TaskStatus_CanTake"
  "TaskStatus_Finish"
  "TaskStatus_Over"
  "TaskStatus_Taked";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TaskStatus_entries[] = {
  { {TaskStatus_names + 0, 18}, 1 },
  { {TaskStatus_names + 18, 17}, 3 },
  { {TaskStatus_names + 35, 15}, 4 },
  { {TaskStatus_names + 50, 16}, 2 },
};

static const int TaskStatus_entries_by_number[] = {
  0, // 1 -> TaskStatus_CanTake
  3, // 2 -> TaskStatus_Taked
  1, // 3 -> TaskStatus_Finish
  2, // 4 -> TaskStatus_Over
};

const std::string& TaskStatus_Name(
    TaskStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TaskStatus_entries,
          TaskStatus_entries_by_number,
          4, TaskStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TaskStatus_entries,
      TaskStatus_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TaskStatus_strings[idx].get();
}
bool TaskStatus_Parse(
    const std::string& name, TaskStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TaskStatus_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<TaskStatus>(int_value);
  }
  return success;
}
bool SkyCityTimeType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SkyCityTimeType_strings[6] = {};

static const char SkyCityTimeType_names[] =
  "FirstWaiting"
  "MidleEndInRest"
  "Race"
  "SC_NONE"
  "SecondWaiting"
  "Waiting";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SkyCityTimeType_entries[] = {
  { {SkyCityTimeType_names + 0, 12}, 4 },
  { {SkyCityTimeType_names + 12, 14}, 3 },
  { {SkyCityTimeType_names + 26, 4}, 2 },
  { {SkyCityTimeType_names + 30, 7}, 6 },
  { {SkyCityTimeType_names + 37, 13}, 5 },
  { {SkyCityTimeType_names + 50, 7}, 1 },
};

static const int SkyCityTimeType_entries_by_number[] = {
  5, // 1 -> Waiting
  2, // 2 -> Race
  1, // 3 -> MidleEndInRest
  0, // 4 -> FirstWaiting
  4, // 5 -> SecondWaiting
  3, // 6 -> SC_NONE
};

const std::string& SkyCityTimeType_Name(
    SkyCityTimeType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SkyCityTimeType_entries,
          SkyCityTimeType_entries_by_number,
          6, SkyCityTimeType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SkyCityTimeType_entries,
      SkyCityTimeType_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SkyCityTimeType_strings[idx].get();
}
bool SkyCityTimeType_Parse(
    const std::string& name, SkyCityTimeType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SkyCityTimeType_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<SkyCityTimeType>(int_value);
  }
  return success;
}
bool GMFReadyType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GMFReadyType_strings[3] = {};

static const char GMFReadyType_names[] =
  "GMF_READY_DOWN"
  "GMF_READY_KICK"
  "GMF_READY_UP";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GMFReadyType_entries[] = {
  { {GMFReadyType_names + 0, 14}, 2 },
  { {GMFReadyType_names + 14, 14}, 3 },
  { {GMFReadyType_names + 28, 12}, 1 },
};

static const int GMFReadyType_entries_by_number[] = {
  2, // 1 -> GMF_READY_UP
  0, // 2 -> GMF_READY_DOWN
  1, // 3 -> GMF_READY_KICK
};

const std::string& GMFReadyType_Name(
    GMFReadyType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GMFReadyType_entries,
          GMFReadyType_entries_by_number,
          3, GMFReadyType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GMFReadyType_entries,
      GMFReadyType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GMFReadyType_strings[idx].get();
}
bool GMFReadyType_Parse(
    const std::string& name, GMFReadyType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GMFReadyType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<GMFReadyType>(int_value);
  }
  return success;
}
bool CardMatchOp_IsValid(int value) {
  switch (value) {
    case 0:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CardMatchOp_strings[10] = {};

static const char CardMatchOp_names[] =
  "CardMatch_Add"
  "CardMatch_Begin"
  "CardMatch_Del"
  "CardMatch_End"
  "CardMatch_Query"
  "CardMatch_RoundBegin"
  "CardMatch_RoundChange"
  "CardMatch_RoundEnd"
  "CardMatch_RoundWaiting"
  "CardMatch_SignUp";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CardMatchOp_entries[] = {
  { {CardMatchOp_names + 0, 13}, 2 },
  { {CardMatchOp_names + 13, 15}, 0 },
  { {CardMatchOp_names + 28, 13}, 3 },
  { {CardMatchOp_names + 41, 13}, 7 },
  { {CardMatchOp_names + 54, 15}, 8 },
  { {CardMatchOp_names + 69, 20}, 4 },
  { {CardMatchOp_names + 89, 21}, 5 },
  { {CardMatchOp_names + 110, 18}, 6 },
  { {CardMatchOp_names + 128, 22}, 9 },
  { {CardMatchOp_names + 150, 16}, 10 },
};

static const int CardMatchOp_entries_by_number[] = {
  1, // 0 -> CardMatch_Begin
  0, // 2 -> CardMatch_Add
  2, // 3 -> CardMatch_Del
  5, // 4 -> CardMatch_RoundBegin
  6, // 5 -> CardMatch_RoundChange
  7, // 6 -> CardMatch_RoundEnd
  3, // 7 -> CardMatch_End
  4, // 8 -> CardMatch_Query
  8, // 9 -> CardMatch_RoundWaiting
  9, // 10 -> CardMatch_SignUp
};

const std::string& CardMatchOp_Name(
    CardMatchOp value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CardMatchOp_entries,
          CardMatchOp_entries_by_number,
          10, CardMatchOp_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CardMatchOp_entries,
      CardMatchOp_entries_by_number,
      10, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CardMatchOp_strings[idx].get();
}
bool CardMatchOp_Parse(
    const std::string& name, CardMatchOp* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CardMatchOp_entries, 10, name, &int_value);
  if (success) {
    *value = static_cast<CardMatchOp>(int_value);
  }
  return success;
}
bool CardMatchState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CardMatchState_strings[8] = {};

static const char CardMatchState_names[] =
  "CardMatch_StateBegin"
  "CardMatch_StateDummy"
  "CardMatch_StateEnd"
  "CardMatch_StateRoundBegin"
  "CardMatch_StateRoundEnd"
  "CardMatch_StateRoundWaiting"
  "CardMatch_StateRounding"
  "CardMatch_StateWaiting";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CardMatchState_entries[] = {
  { {CardMatchState_names + 0, 20}, 0 },
  { {CardMatchState_names + 20, 20}, 7 },
  { {CardMatchState_names + 40, 18}, 6 },
  { {CardMatchState_names + 58, 25}, 3 },
  { {CardMatchState_names + 83, 23}, 5 },
  { {CardMatchState_names + 106, 27}, 2 },
  { {CardMatchState_names + 133, 23}, 4 },
  { {CardMatchState_names + 156, 22}, 1 },
};

static const int CardMatchState_entries_by_number[] = {
  0, // 0 -> CardMatch_StateBegin
  7, // 1 -> CardMatch_StateWaiting
  5, // 2 -> CardMatch_StateRoundWaiting
  3, // 3 -> CardMatch_StateRoundBegin
  6, // 4 -> CardMatch_StateRounding
  4, // 5 -> CardMatch_StateRoundEnd
  2, // 6 -> CardMatch_StateEnd
  1, // 7 -> CardMatch_StateDummy
};

const std::string& CardMatchState_Name(
    CardMatchState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CardMatchState_entries,
          CardMatchState_entries_by_number,
          8, CardMatchState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CardMatchState_entries,
      CardMatchState_entries_by_number,
      8, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CardMatchState_strings[idx].get();
}
bool CardMatchState_Parse(
    const std::string& name, CardMatchState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CardMatchState_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<CardMatchState>(int_value);
  }
  return success;
}
bool GuildBindStatus_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GuildBindStatus_strings[5] = {};

static const char GuildBindStatus_names[] =
  "GBS_Admin"
  "GBS_Member"
  "GBS_NotBind"
  "GBS_NotMember"
  "GBS_Owner";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GuildBindStatus_entries[] = {
  { {GuildBindStatus_names + 0, 9}, 3 },
  { {GuildBindStatus_names + 9, 10}, 4 },
  { {GuildBindStatus_names + 19, 11}, 1 },
  { {GuildBindStatus_names + 30, 13}, 5 },
  { {GuildBindStatus_names + 43, 9}, 2 },
};

static const int GuildBindStatus_entries_by_number[] = {
  2, // 1 -> GBS_NotBind
  4, // 2 -> GBS_Owner
  0, // 3 -> GBS_Admin
  1, // 4 -> GBS_Member
  3, // 5 -> GBS_NotMember
};

const std::string& GuildBindStatus_Name(
    GuildBindStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GuildBindStatus_entries,
          GuildBindStatus_entries_by_number,
          5, GuildBindStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GuildBindStatus_entries,
      GuildBindStatus_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GuildBindStatus_strings[idx].get();
}
bool GuildBindStatus_Parse(
    const std::string& name, GuildBindStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GuildBindStatus_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<GuildBindStatus>(int_value);
  }
  return success;
}
bool GmfBattleState_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GmfBattleState_strings[4] = {};

static const char GmfBattleState_names[] =
  "GMF_BS_FIGHT"
  "GMF_BS_NONE"
  "GMF_BS_RESULT"
  "GMF_BS_WAIT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GmfBattleState_entries[] = {
  { {GmfBattleState_names + 0, 12}, 2 },
  { {GmfBattleState_names + 12, 11}, 4 },
  { {GmfBattleState_names + 23, 13}, 3 },
  { {GmfBattleState_names + 36, 11}, 1 },
};

static const int GmfBattleState_entries_by_number[] = {
  3, // 1 -> GMF_BS_WAIT
  0, // 2 -> GMF_BS_FIGHT
  2, // 3 -> GMF_BS_RESULT
  1, // 4 -> GMF_BS_NONE
};

const std::string& GmfBattleState_Name(
    GmfBattleState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GmfBattleState_entries,
          GmfBattleState_entries_by_number,
          4, GmfBattleState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GmfBattleState_entries,
      GmfBattleState_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GmfBattleState_strings[idx].get();
}
bool GmfBattleState_Parse(
    const std::string& name, GmfBattleState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GmfBattleState_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<GmfBattleState>(int_value);
  }
  return success;
}
bool BroadCastType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> BroadCastType_strings[2] = {};

static const char BroadCastType_names[] =
  "BroadCastMax"
  "BroadCastToAll";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry BroadCastType_entries[] = {
  { {BroadCastType_names + 0, 12}, 2 },
  { {BroadCastType_names + 12, 14}, 1 },
};

static const int BroadCastType_entries_by_number[] = {
  1, // 1 -> BroadCastToAll
  0, // 2 -> BroadCastMax
};

const std::string& BroadCastType_Name(
    BroadCastType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          BroadCastType_entries,
          BroadCastType_entries_by_number,
          2, BroadCastType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      BroadCastType_entries,
      BroadCastType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     BroadCastType_strings[idx].get();
}
bool BroadCastType_Parse(
    const std::string& name, BroadCastType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      BroadCastType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<BroadCastType>(int_value);
  }
  return success;
}
bool ActOpenState_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ActOpenState_strings[4] = {};

static const char ActOpenState_names[] =
  "ActOpenState_NotOpen"
  "ActOpenState_Over"
  "ActOpenState_Prepare"
  "ActOpenState_Running";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ActOpenState_entries[] = {
  { {ActOpenState_names + 0, 20}, 1 },
  { {ActOpenState_names + 20, 17}, 4 },
  { {ActOpenState_names + 37, 20}, 2 },
  { {ActOpenState_names + 57, 20}, 3 },
};

static const int ActOpenState_entries_by_number[] = {
  0, // 1 -> ActOpenState_NotOpen
  2, // 2 -> ActOpenState_Prepare
  3, // 3 -> ActOpenState_Running
  1, // 4 -> ActOpenState_Over
};

const std::string& ActOpenState_Name(
    ActOpenState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ActOpenState_entries,
          ActOpenState_entries_by_number,
          4, ActOpenState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ActOpenState_entries,
      ActOpenState_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ActOpenState_strings[idx].get();
}
bool ActOpenState_Parse(
    const std::string& name, ActOpenState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ActOpenState_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<ActOpenState>(int_value);
  }
  return success;
}
bool PlantGrowState_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PlantGrowState_strings[6] = {};

static const char PlantGrowState_names[] =
  "growCD"
  "growCorrect"
  "growDrought"
  "growMature"
  "growPest"
  "growSluggish";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PlantGrowState_entries[] = {
  { {PlantGrowState_names + 0, 6}, 4 },
  { {PlantGrowState_names + 6, 11}, 6 },
  { {PlantGrowState_names + 17, 11}, 1 },
  { {PlantGrowState_names + 28, 10}, 5 },
  { {PlantGrowState_names + 38, 8}, 2 },
  { {PlantGrowState_names + 46, 12}, 3 },
};

static const int PlantGrowState_entries_by_number[] = {
  2, // 1 -> growDrought
  4, // 2 -> growPest
  5, // 3 -> growSluggish
  0, // 4 -> growCD
  3, // 5 -> growMature
  1, // 6 -> growCorrect
};

const std::string& PlantGrowState_Name(
    PlantGrowState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PlantGrowState_entries,
          PlantGrowState_entries_by_number,
          6, PlantGrowState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PlantGrowState_entries,
      PlantGrowState_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PlantGrowState_strings[idx].get();
}
bool PlantGrowState_Parse(
    const std::string& name, PlantGrowState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PlantGrowState_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<PlantGrowState>(int_value);
  }
  return success;
}
bool GardenPlayEventType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GardenPlayEventType_strings[11] = {};

static const char GardenPlayEventType_names[] =
  "BANQUET"
  "BANQUET_STAGE"
  "FISH_FACE"
  "FISH_RESULT"
  "FISH_STOP"
  "PLANT"
  "PLANT_DELETE"
  "PLANT_MATURE"
  "PLANT_SPRITE"
  "PLANT_STAGE"
  "PLANT_STATE_CHANGE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GardenPlayEventType_entries[] = {
  { {GardenPlayEventType_names + 0, 7}, 4 },
  { {GardenPlayEventType_names + 7, 13}, 5 },
  { {GardenPlayEventType_names + 20, 9}, 9 },
  { {GardenPlayEventType_names + 29, 11}, 10 },
  { {GardenPlayEventType_names + 40, 9}, 11 },
  { {GardenPlayEventType_names + 49, 5}, 1 },
  { {GardenPlayEventType_names + 54, 12}, 6 },
  { {GardenPlayEventType_names + 66, 12}, 8 },
  { {GardenPlayEventType_names + 78, 12}, 7 },
  { {GardenPlayEventType_names + 90, 11}, 2 },
  { {GardenPlayEventType_names + 101, 18}, 3 },
};

static const int GardenPlayEventType_entries_by_number[] = {
  5, // 1 -> PLANT
  9, // 2 -> PLANT_STAGE
  10, // 3 -> PLANT_STATE_CHANGE
  0, // 4 -> BANQUET
  1, // 5 -> BANQUET_STAGE
  6, // 6 -> PLANT_DELETE
  8, // 7 -> PLANT_SPRITE
  7, // 8 -> PLANT_MATURE
  2, // 9 -> FISH_FACE
  3, // 10 -> FISH_RESULT
  4, // 11 -> FISH_STOP
};

const std::string& GardenPlayEventType_Name(
    GardenPlayEventType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GardenPlayEventType_entries,
          GardenPlayEventType_entries_by_number,
          11, GardenPlayEventType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GardenPlayEventType_entries,
      GardenPlayEventType_entries_by_number,
      11, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GardenPlayEventType_strings[idx].get();
}
bool GardenPlayEventType_Parse(
    const std::string& name, GardenPlayEventType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GardenPlayEventType_entries, 11, name, &int_value);
  if (success) {
    *value = static_cast<GardenPlayEventType>(int_value);
  }
  return success;
}
bool GMF_FINAL_WIN_TYPE_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GMF_FINAL_WIN_TYPE_strings[3] = {};

static const char GMF_FINAL_WIN_TYPE_names[] =
  "GMF_FWY_NORMAL"
  "GMF_FWY_OPNONE"
  "GMF_FWY_RANK";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GMF_FINAL_WIN_TYPE_entries[] = {
  { {GMF_FINAL_WIN_TYPE_names + 0, 14}, 1 },
  { {GMF_FINAL_WIN_TYPE_names + 14, 14}, 2 },
  { {GMF_FINAL_WIN_TYPE_names + 28, 12}, 3 },
};

static const int GMF_FINAL_WIN_TYPE_entries_by_number[] = {
  0, // 1 -> GMF_FWY_NORMAL
  1, // 2 -> GMF_FWY_OPNONE
  2, // 3 -> GMF_FWY_RANK
};

const std::string& GMF_FINAL_WIN_TYPE_Name(
    GMF_FINAL_WIN_TYPE value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GMF_FINAL_WIN_TYPE_entries,
          GMF_FINAL_WIN_TYPE_entries_by_number,
          3, GMF_FINAL_WIN_TYPE_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GMF_FINAL_WIN_TYPE_entries,
      GMF_FINAL_WIN_TYPE_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GMF_FINAL_WIN_TYPE_strings[idx].get();
}
bool GMF_FINAL_WIN_TYPE_Parse(
    const std::string& name, GMF_FINAL_WIN_TYPE* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GMF_FINAL_WIN_TYPE_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<GMF_FINAL_WIN_TYPE>(int_value);
  }
  return success;
}
bool RoleEventType_IsValid(int value) {
  switch (value) {
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> RoleEventType_strings[1] = {};

static const char RoleEventType_names[] =
  "OnSendFriendGift";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry RoleEventType_entries[] = {
  { {RoleEventType_names + 0, 16}, 1 },
};

static const int RoleEventType_entries_by_number[] = {
  0, // 1 -> OnSendFriendGift
};

const std::string& RoleEventType_Name(
    RoleEventType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          RoleEventType_entries,
          RoleEventType_entries_by_number,
          1, RoleEventType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      RoleEventType_entries,
      RoleEventType_entries_by_number,
      1, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     RoleEventType_strings[idx].get();
}
bool RoleEventType_Parse(
    const std::string& name, RoleEventType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      RoleEventType_entries, 1, name, &int_value);
  if (success) {
    *value = static_cast<RoleEventType>(int_value);
  }
  return success;
}
bool WageRewardState_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> WageRewardState_strings[3] = {};

static const char WageRewardState_names[] =
  "cannot"
  "notreward"
  "rewarded";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry WageRewardState_entries[] = {
  { {WageRewardState_names + 0, 6}, 1 },
  { {WageRewardState_names + 6, 9}, 3 },
  { {WageRewardState_names + 15, 8}, 2 },
};

static const int WageRewardState_entries_by_number[] = {
  0, // 1 -> cannot
  2, // 2 -> rewarded
  1, // 3 -> notreward
};

const std::string& WageRewardState_Name(
    WageRewardState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          WageRewardState_entries,
          WageRewardState_entries_by_number,
          3, WageRewardState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      WageRewardState_entries,
      WageRewardState_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     WageRewardState_strings[idx].get();
}
bool WageRewardState_Parse(
    const std::string& name, WageRewardState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      WageRewardState_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<WageRewardState>(int_value);
  }
  return success;
}
bool ItemUseOp_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ItemUseOp_strings[15] = {};

static const char ItemUseOp_names[] =
  "ActivationFashion"
  "ActivationHairColor"
  "BagFind"
  "BodyFind"
  "Composite"
  "FashionDisplayOff"
  "FashionDisplayWear"
  "FashionOff"
  "FashionSuitDisplayOff"
  "FashionSuitDisplayWear"
  "FashionSuitOff"
  "FashionSuitWear"
  "FashionWear"
  "ItemBuffAdd"
  "UseHairColor";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ItemUseOp_entries[] = {
  { {ItemUseOp_names + 0, 17}, 12 },
  { {ItemUseOp_names + 17, 19}, 13 },
  { {ItemUseOp_names + 36, 7}, 0 },
  { {ItemUseOp_names + 43, 8}, 1 },
  { {ItemUseOp_names + 51, 9}, 4 },
  { {ItemUseOp_names + 60, 17}, 9 },
  { {ItemUseOp_names + 77, 18}, 8 },
  { {ItemUseOp_names + 95, 10}, 3 },
  { {ItemUseOp_names + 105, 21}, 11 },
  { {ItemUseOp_names + 126, 22}, 10 },
  { {ItemUseOp_names + 148, 14}, 6 },
  { {ItemUseOp_names + 162, 15}, 5 },
  { {ItemUseOp_names + 177, 11}, 2 },
  { {ItemUseOp_names + 188, 11}, 7 },
  { {ItemUseOp_names + 199, 12}, 14 },
};

static const int ItemUseOp_entries_by_number[] = {
  2, // 0 -> BagFind
  3, // 1 -> BodyFind
  12, // 2 -> FashionWear
  7, // 3 -> FashionOff
  4, // 4 -> Composite
  11, // 5 -> FashionSuitWear
  10, // 6 -> FashionSuitOff
  13, // 7 -> ItemBuffAdd
  6, // 8 -> FashionDisplayWear
  5, // 9 -> FashionDisplayOff
  9, // 10 -> FashionSuitDisplayWear
  8, // 11 -> FashionSuitDisplayOff
  0, // 12 -> ActivationFashion
  1, // 13 -> ActivationHairColor
  14, // 14 -> UseHairColor
};

const std::string& ItemUseOp_Name(
    ItemUseOp value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ItemUseOp_entries,
          ItemUseOp_entries_by_number,
          15, ItemUseOp_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ItemUseOp_entries,
      ItemUseOp_entries_by_number,
      15, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ItemUseOp_strings[idx].get();
}
bool ItemUseOp_Parse(
    const std::string& name, ItemUseOp* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ItemUseOp_entries, 15, name, &int_value);
  if (success) {
    *value = static_cast<ItemUseOp>(int_value);
  }
  return success;
}
bool ResWarTimeType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ResWarTimeType_strings[4] = {};

static const char ResWarTimeType_names[] =
  "EndTime"
  "RaceTime"
  "RealyTime"
  "ResWarNone";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ResWarTimeType_entries[] = {
  { {ResWarTimeType_names + 0, 7}, 3 },
  { {ResWarTimeType_names + 7, 8}, 2 },
  { {ResWarTimeType_names + 15, 9}, 1 },
  { {ResWarTimeType_names + 24, 10}, 4 },
};

static const int ResWarTimeType_entries_by_number[] = {
  2, // 1 -> RealyTime
  1, // 2 -> RaceTime
  0, // 3 -> EndTime
  3, // 4 -> ResWarNone
};

const std::string& ResWarTimeType_Name(
    ResWarTimeType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ResWarTimeType_entries,
          ResWarTimeType_entries_by_number,
          4, ResWarTimeType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ResWarTimeType_entries,
      ResWarTimeType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ResWarTimeType_strings[idx].get();
}
bool ResWarTimeType_Parse(
    const std::string& name, ResWarTimeType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ResWarTimeType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<ResWarTimeType>(int_value);
  }
  return success;
}
bool ResWarResult_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ResWarResult_strings[3] = {};

static const char ResWarResult_names[] =
  "RESWAR_FAIL"
  "RESWAR_FLAT"
  "RESWAR_SUCESS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ResWarResult_entries[] = {
  { {ResWarResult_names + 0, 11}, 2 },
  { {ResWarResult_names + 11, 11}, 3 },
  { {ResWarResult_names + 22, 13}, 1 },
};

static const int ResWarResult_entries_by_number[] = {
  2, // 1 -> RESWAR_SUCESS
  0, // 2 -> RESWAR_FAIL
  1, // 3 -> RESWAR_FLAT
};

const std::string& ResWarResult_Name(
    ResWarResult value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ResWarResult_entries,
          ResWarResult_entries_by_number,
          3, ResWarResult_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ResWarResult_entries,
      ResWarResult_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ResWarResult_strings[idx].get();
}
bool ResWarResult_Parse(
    const std::string& name, ResWarResult* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ResWarResult_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<ResWarResult>(int_value);
  }
  return success;
}
bool GuildAuctReqType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GuildAuctReqType_strings[6] = {};

static const char GuildAuctReqType_names[] =
  "GART_ACT_TYPE"
  "GART_AUCT_GUILD_HISTORY"
  "GART_AUCT_WORLD_HISTORY"
  "GART_BUY_AUCT"
  "GART_BUY_NOW"
  "GART_ITEM_TYPE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GuildAuctReqType_entries[] = {
  { {GuildAuctReqType_names + 0, 13}, 1 },
  { {GuildAuctReqType_names + 13, 23}, 7 },
  { {GuildAuctReqType_names + 36, 23}, 8 },
  { {GuildAuctReqType_names + 59, 13}, 5 },
  { {GuildAuctReqType_names + 72, 12}, 6 },
  { {GuildAuctReqType_names + 84, 14}, 2 },
};

static const int GuildAuctReqType_entries_by_number[] = {
  0, // 1 -> GART_ACT_TYPE
  5, // 2 -> GART_ITEM_TYPE
  3, // 5 -> GART_BUY_AUCT
  4, // 6 -> GART_BUY_NOW
  1, // 7 -> GART_AUCT_GUILD_HISTORY
  2, // 8 -> GART_AUCT_WORLD_HISTORY
};

const std::string& GuildAuctReqType_Name(
    GuildAuctReqType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GuildAuctReqType_entries,
          GuildAuctReqType_entries_by_number,
          6, GuildAuctReqType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GuildAuctReqType_entries,
      GuildAuctReqType_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GuildAuctReqType_strings[idx].get();
}
bool GuildAuctReqType_Parse(
    const std::string& name, GuildAuctReqType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GuildAuctReqType_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<GuildAuctReqType>(int_value);
  }
  return success;
}
bool GardenQuestType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GardenQuestType_strings[3] = {};

static const char GardenQuestType_names[] =
  "FRIEND"
  "GUILD"
  "MYSELF";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GardenQuestType_entries[] = {
  { {GardenQuestType_names + 0, 6}, 2 },
  { {GardenQuestType_names + 6, 5}, 3 },
  { {GardenQuestType_names + 11, 6}, 1 },
};

static const int GardenQuestType_entries_by_number[] = {
  2, // 1 -> MYSELF
  0, // 2 -> FRIEND
  1, // 3 -> GUILD
};

const std::string& GardenQuestType_Name(
    GardenQuestType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GardenQuestType_entries,
          GardenQuestType_entries_by_number,
          3, GardenQuestType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GardenQuestType_entries,
      GardenQuestType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GardenQuestType_strings[idx].get();
}
bool GardenQuestType_Parse(
    const std::string& name, GardenQuestType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GardenQuestType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<GardenQuestType>(int_value);
  }
  return success;
}
bool GuildArenaType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GuildArenaType_strings[8] = {};

static const char GuildArenaType_names[] =
  "apply"
  "battlefinal"
  "battlefour"
  "battleone"
  "battlethree"
  "battletwo"
  "notopen"
  "resttime";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GuildArenaType_entries[] = {
  { {GuildArenaType_names + 0, 5}, 6 },
  { {GuildArenaType_names + 5, 11}, 5 },
  { {GuildArenaType_names + 16, 10}, 4 },
  { {GuildArenaType_names + 26, 9}, 1 },
  { {GuildArenaType_names + 35, 11}, 3 },
  { {GuildArenaType_names + 46, 9}, 2 },
  { {GuildArenaType_names + 55, 7}, 7 },
  { {GuildArenaType_names + 62, 8}, 0 },
};

static const int GuildArenaType_entries_by_number[] = {
  7, // 0 -> resttime
  3, // 1 -> battleone
  5, // 2 -> battletwo
  4, // 3 -> battlethree
  2, // 4 -> battlefour
  1, // 5 -> battlefinal
  0, // 6 -> apply
  6, // 7 -> notopen
};

const std::string& GuildArenaType_Name(
    GuildArenaType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GuildArenaType_entries,
          GuildArenaType_entries_by_number,
          8, GuildArenaType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GuildArenaType_entries,
      GuildArenaType_entries_by_number,
      8, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GuildArenaType_strings[idx].get();
}
bool GuildArenaType_Parse(
    const std::string& name, GuildArenaType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GuildArenaType_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<GuildArenaType>(int_value);
  }
  return success;
}
bool StageRankCond_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> StageRankCond_strings[9] = {};

static const char StageRankCond_names[] =
  "StageRankCond_AliveTime"
  "StageRankCond_Behit"
  "StageRankCond_Combo"
  "StageRankCond_Found"
  "StageRankCond_Hppercent"
  "StageRankCond_KillEnemyScore"
  "StageRankCond_NpcHp"
  "StageRankCond_Time"
  "StageRankCond_TotalKillEnemyScore";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry StageRankCond_entries[] = {
  { {StageRankCond_names + 0, 23}, 8 },
  { {StageRankCond_names + 23, 19}, 4 },
  { {StageRankCond_names + 42, 19}, 6 },
  { {StageRankCond_names + 61, 19}, 3 },
  { {StageRankCond_names + 80, 23}, 2 },
  { {StageRankCond_names + 103, 28}, 7 },
  { {StageRankCond_names + 131, 19}, 5 },
  { {StageRankCond_names + 150, 18}, 1 },
  { {StageRankCond_names + 168, 33}, 9 },
};

static const int StageRankCond_entries_by_number[] = {
  7, // 1 -> StageRankCond_Time
  4, // 2 -> StageRankCond_Hppercent
  3, // 3 -> StageRankCond_Found
  1, // 4 -> StageRankCond_Behit
  6, // 5 -> StageRankCond_NpcHp
  2, // 6 -> StageRankCond_Combo
  5, // 7 -> StageRankCond_KillEnemyScore
  0, // 8 -> StageRankCond_AliveTime
  8, // 9 -> StageRankCond_TotalKillEnemyScore
};

const std::string& StageRankCond_Name(
    StageRankCond value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          StageRankCond_entries,
          StageRankCond_entries_by_number,
          9, StageRankCond_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      StageRankCond_entries,
      StageRankCond_entries_by_number,
      9, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     StageRankCond_strings[idx].get();
}
bool StageRankCond_Parse(
    const std::string& name, StageRankCond* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      StageRankCond_entries, 9, name, &int_value);
  if (success) {
    *value = static_cast<StageRankCond>(int_value);
  }
  return success;
}
bool GuildAuctResultType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GuildAuctResultType_strings[3] = {};

static const char GuildAuctResultType_names[] =
  "GA_RESULT_BUY_AUCT"
  "GA_RESULT_BUY_NOW"
  "GA_RESULT_TO_WORLD";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GuildAuctResultType_entries[] = {
  { {GuildAuctResultType_names + 0, 18}, 2 },
  { {GuildAuctResultType_names + 18, 17}, 1 },
  { {GuildAuctResultType_names + 35, 18}, 3 },
};

static const int GuildAuctResultType_entries_by_number[] = {
  1, // 1 -> GA_RESULT_BUY_NOW
  0, // 2 -> GA_RESULT_BUY_AUCT
  2, // 3 -> GA_RESULT_TO_WORLD
};

const std::string& GuildAuctResultType_Name(
    GuildAuctResultType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GuildAuctResultType_entries,
          GuildAuctResultType_entries_by_number,
          3, GuildAuctResultType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GuildAuctResultType_entries,
      GuildAuctResultType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GuildAuctResultType_strings[idx].get();
}
bool GuildAuctResultType_Parse(
    const std::string& name, GuildAuctResultType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GuildAuctResultType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<GuildAuctResultType>(int_value);
  }
  return success;
}
bool IntegralState_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> IntegralState_strings[4] = {};

static const char IntegralState_names[] =
  "integralend"
  "integralenterscene"
  "integralready"
  "integralwatch";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry IntegralState_entries[] = {
  { {IntegralState_names + 0, 11}, 4 },
  { {IntegralState_names + 11, 18}, 2 },
  { {IntegralState_names + 29, 13}, 1 },
  { {IntegralState_names + 42, 13}, 3 },
};

static const int IntegralState_entries_by_number[] = {
  2, // 1 -> integralready
  1, // 2 -> integralenterscene
  3, // 3 -> integralwatch
  0, // 4 -> integralend
};

const std::string& IntegralState_Name(
    IntegralState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          IntegralState_entries,
          IntegralState_entries_by_number,
          4, IntegralState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      IntegralState_entries,
      IntegralState_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     IntegralState_strings[idx].get();
}
bool IntegralState_Parse(
    const std::string& name, IntegralState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      IntegralState_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<IntegralState>(int_value);
  }
  return success;
}
bool ResWarState_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ResWarState_strings[2] = {};

static const char ResWarState_names[] =
  "ResWarCancelState"
  "ResWarExploreState";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ResWarState_entries[] = {
  { {ResWarState_names + 0, 17}, 2 },
  { {ResWarState_names + 17, 18}, 1 },
};

static const int ResWarState_entries_by_number[] = {
  1, // 1 -> ResWarExploreState
  0, // 2 -> ResWarCancelState
};

const std::string& ResWarState_Name(
    ResWarState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ResWarState_entries,
          ResWarState_entries_by_number,
          2, ResWarState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ResWarState_entries,
      ResWarState_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ResWarState_strings[idx].get();
}
bool ResWarState_Parse(
    const std::string& name, ResWarState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ResWarState_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<ResWarState>(int_value);
  }
  return success;
}
bool ServerFlag_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 7:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ServerFlag_strings[7] = {};

static const char ServerFlag_names[] =
  "ServerFlag_Dummy"
  "ServerFlag_Full"
  "ServerFlag_Hot"
  "ServerFlag_Maintain"
  "ServerFlag_New"
  "ServerFlag_Recommend"
  "ServerFlag_Smooth";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ServerFlag_entries[] = {
  { {ServerFlag_names + 0, 16}, 5 },
  { {ServerFlag_names + 16, 15}, 3 },
  { {ServerFlag_names + 31, 14}, 2 },
  { {ServerFlag_names + 45, 19}, 0 },
  { {ServerFlag_names + 64, 14}, 1 },
  { {ServerFlag_names + 78, 20}, 4 },
  { {ServerFlag_names + 98, 17}, 7 },
};

static const int ServerFlag_entries_by_number[] = {
  3, // 0 -> ServerFlag_Maintain
  4, // 1 -> ServerFlag_New
  2, // 2 -> ServerFlag_Hot
  1, // 3 -> ServerFlag_Full
  5, // 4 -> ServerFlag_Recommend
  0, // 5 -> ServerFlag_Dummy
  6, // 7 -> ServerFlag_Smooth
};

const std::string& ServerFlag_Name(
    ServerFlag value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ServerFlag_entries,
          ServerFlag_entries_by_number,
          7, ServerFlag_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ServerFlag_entries,
      ServerFlag_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ServerFlag_strings[idx].get();
}
bool ServerFlag_Parse(
    const std::string& name, ServerFlag* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ServerFlag_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<ServerFlag>(int_value);
  }
  return success;
}
bool EnumServerState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> EnumServerState_strings[6] = {};

static const char EnumServerState_names[] =
  "ServerState_Auto"
  "ServerState_Full"
  "ServerState_Hot"
  "ServerState_Maintain"
  "ServerState_Recommend"
  "ServerState_Smooth";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry EnumServerState_entries[] = {
  { {EnumServerState_names + 0, 16}, 5 },
  { {EnumServerState_names + 16, 16}, 3 },
  { {EnumServerState_names + 32, 15}, 2 },
  { {EnumServerState_names + 47, 20}, 0 },
  { {EnumServerState_names + 67, 21}, 4 },
  { {EnumServerState_names + 88, 18}, 1 },
};

static const int EnumServerState_entries_by_number[] = {
  3, // 0 -> ServerState_Maintain
  5, // 1 -> ServerState_Smooth
  2, // 2 -> ServerState_Hot
  1, // 3 -> ServerState_Full
  4, // 4 -> ServerState_Recommend
  0, // 5 -> ServerState_Auto
};

const std::string& EnumServerState_Name(
    EnumServerState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          EnumServerState_entries,
          EnumServerState_entries_by_number,
          6, EnumServerState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      EnumServerState_entries,
      EnumServerState_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     EnumServerState_strings[idx].get();
}
bool EnumServerState_Parse(
    const std::string& name, EnumServerState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      EnumServerState_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<EnumServerState>(int_value);
  }
  return success;
}
bool OutLookStateType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> OutLookStateType_strings[8] = {};

static const char OutLookStateType_names[] =
  "OutLook_Dance"
  "OutLook_Fish"
  "OutLook_Inherit"
  "OutLook_Normal"
  "OutLook_RidePet"
  "OutLook_RidePetCopilot"
  "OutLook_Sit"
  "OutLook_Trans";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry OutLookStateType_entries[] = {
  { {OutLookStateType_names + 0, 13}, 2 },
  { {OutLookStateType_names + 13, 12}, 5 },
  { {OutLookStateType_names + 25, 15}, 4 },
  { {OutLookStateType_names + 40, 14}, 0 },
  { {OutLookStateType_names + 54, 15}, 3 },
  { {OutLookStateType_names + 69, 22}, 6 },
  { {OutLookStateType_names + 91, 11}, 1 },
  { {OutLookStateType_names + 102, 13}, 7 },
};

static const int OutLookStateType_entries_by_number[] = {
  3, // 0 -> OutLook_Normal
  6, // 1 -> OutLook_Sit
  0, // 2 -> OutLook_Dance
  4, // 3 -> OutLook_RidePet
  2, // 4 -> OutLook_Inherit
  1, // 5 -> OutLook_Fish
  5, // 6 -> OutLook_RidePetCopilot
  7, // 7 -> OutLook_Trans
};

const std::string& OutLookStateType_Name(
    OutLookStateType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          OutLookStateType_entries,
          OutLookStateType_entries_by_number,
          8, OutLookStateType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      OutLookStateType_entries,
      OutLookStateType_entries_by_number,
      8, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     OutLookStateType_strings[idx].get();
}
bool OutLookStateType_Parse(
    const std::string& name, OutLookStateType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      OutLookStateType_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<OutLookStateType>(int_value);
  }
  return success;
}
bool FunctionId_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> FunctionId_strings[3] = {};

static const char FunctionId_names[] =
  "FunctionId_IOSCheck"
  "FunctionId_QQVip"
  "FunctionId_StartPrivilege";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry FunctionId_entries[] = {
  { {FunctionId_names + 0, 19}, 1 },
  { {FunctionId_names + 19, 16}, 0 },
  { {FunctionId_names + 35, 25}, 2 },
};

static const int FunctionId_entries_by_number[] = {
  1, // 0 -> FunctionId_QQVip
  0, // 1 -> FunctionId_IOSCheck
  2, // 2 -> FunctionId_StartPrivilege
};

const std::string& FunctionId_Name(
    FunctionId value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          FunctionId_entries,
          FunctionId_entries_by_number,
          3, FunctionId_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      FunctionId_entries,
      FunctionId_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     FunctionId_strings[idx].get();
}
bool FunctionId_Parse(
    const std::string& name, FunctionId* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      FunctionId_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<FunctionId>(int_value);
  }
  return success;
}
bool LeaveTeamType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LeaveTeamType_strings[5] = {};

static const char LeaveTeamType_names[] =
  "LLT_LEADER_TIMEOVER"
  "LTT_BY_SELF"
  "LTT_DEL_ROBOT"
  "LTT_KICK"
  "LTT_MS_CRASH";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LeaveTeamType_entries[] = {
  { {LeaveTeamType_names + 0, 19}, 4 },
  { {LeaveTeamType_names + 19, 11}, 0 },
  { {LeaveTeamType_names + 30, 13}, 2 },
  { {LeaveTeamType_names + 43, 8}, 1 },
  { {LeaveTeamType_names + 51, 12}, 3 },
};

static const int LeaveTeamType_entries_by_number[] = {
  1, // 0 -> LTT_BY_SELF
  3, // 1 -> LTT_KICK
  2, // 2 -> LTT_DEL_ROBOT
  4, // 3 -> LTT_MS_CRASH
  0, // 4 -> LLT_LEADER_TIMEOVER
};

const std::string& LeaveTeamType_Name(
    LeaveTeamType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          LeaveTeamType_entries,
          LeaveTeamType_entries_by_number,
          5, LeaveTeamType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      LeaveTeamType_entries,
      LeaveTeamType_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     LeaveTeamType_strings[idx].get();
}
bool LeaveTeamType_Parse(
    const std::string& name, LeaveTeamType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      LeaveTeamType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<LeaveTeamType>(int_value);
  }
  return success;
}
bool StartUpType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> StartUpType_strings[3] = {};

static const char StartUpType_names[] =
  "StartUp_Normal"
  "StartUp_QQ"
  "StartUp_WX";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry StartUpType_entries[] = {
  { {StartUpType_names + 0, 14}, 1 },
  { {StartUpType_names + 14, 10}, 2 },
  { {StartUpType_names + 24, 10}, 3 },
};

static const int StartUpType_entries_by_number[] = {
  0, // 1 -> StartUp_Normal
  1, // 2 -> StartUp_QQ
  2, // 3 -> StartUp_WX
};

const std::string& StartUpType_Name(
    StartUpType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          StartUpType_entries,
          StartUpType_entries_by_number,
          3, StartUpType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      StartUpType_entries,
      StartUpType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     StartUpType_strings[idx].get();
}
bool StartUpType_Parse(
    const std::string& name, StartUpType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      StartUpType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<StartUpType>(int_value);
  }
  return success;
}
bool AntiAddictionReportType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AntiAddictionReportType_strings[2] = {};

static const char AntiAddictionReportType_names[] =
  "ReportTypeSingle"
  "ReportTypeTotal";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AntiAddictionReportType_entries[] = {
  { {AntiAddictionReportType_names + 0, 16}, 1 },
  { {AntiAddictionReportType_names + 16, 15}, 2 },
};

static const int AntiAddictionReportType_entries_by_number[] = {
  0, // 1 -> ReportTypeSingle
  1, // 2 -> ReportTypeTotal
};

const std::string& AntiAddictionReportType_Name(
    AntiAddictionReportType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          AntiAddictionReportType_entries,
          AntiAddictionReportType_entries_by_number,
          2, AntiAddictionReportType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      AntiAddictionReportType_entries,
      AntiAddictionReportType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     AntiAddictionReportType_strings[idx].get();
}
bool AntiAddictionReportType_Parse(
    const std::string& name, AntiAddictionReportType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      AntiAddictionReportType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<AntiAddictionReportType>(int_value);
  }
  return success;
}
bool DBOperType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DBOperType_strings[5] = {};

static const char DBOperType_names[] =
  "DBOper_Del"
  "DBOper_DelAll"
  "DBOper_Insert"
  "DBOper_ReplaceId"
  "DBOper_Update";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DBOperType_entries[] = {
  { {DBOperType_names + 0, 10}, 3 },
  { {DBOperType_names + 10, 13}, 4 },
  { {DBOperType_names + 23, 13}, 1 },
  { {DBOperType_names + 36, 16}, 5 },
  { {DBOperType_names + 52, 13}, 2 },
};

static const int DBOperType_entries_by_number[] = {
  2, // 1 -> DBOper_Insert
  4, // 2 -> DBOper_Update
  0, // 3 -> DBOper_Del
  1, // 4 -> DBOper_DelAll
  3, // 5 -> DBOper_ReplaceId
};

const std::string& DBOperType_Name(
    DBOperType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DBOperType_entries,
          DBOperType_entries_by_number,
          5, DBOperType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DBOperType_entries,
      DBOperType_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DBOperType_strings[idx].get();
}
bool DBOperType_Parse(
    const std::string& name, DBOperType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DBOperType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<DBOperType>(int_value);
  }
  return success;
}
bool MentorApplyStatus_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> MentorApplyStatus_strings[4] = {};

static const char MentorApplyStatus_names[] =
  "MentorApplyHas"
  "MentorApplyMaster"
  "MentorApplyStatusMax"
  "MentorApplyStudent";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry MentorApplyStatus_entries[] = {
  { {MentorApplyStatus_names + 0, 14}, 3 },
  { {MentorApplyStatus_names + 14, 17}, 1 },
  { {MentorApplyStatus_names + 31, 20}, 4 },
  { {MentorApplyStatus_names + 51, 18}, 2 },
};

static const int MentorApplyStatus_entries_by_number[] = {
  1, // 1 -> MentorApplyMaster
  3, // 2 -> MentorApplyStudent
  0, // 3 -> MentorApplyHas
  2, // 4 -> MentorApplyStatusMax
};

const std::string& MentorApplyStatus_Name(
    MentorApplyStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          MentorApplyStatus_entries,
          MentorApplyStatus_entries_by_number,
          4, MentorApplyStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      MentorApplyStatus_entries,
      MentorApplyStatus_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     MentorApplyStatus_strings[idx].get();
}
bool MentorApplyStatus_Parse(
    const std::string& name, MentorApplyStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      MentorApplyStatus_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<MentorApplyStatus>(int_value);
  }
  return success;
}
bool MentorRelationStatus_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> MentorRelationStatus_strings[5] = {};

static const char MentorRelationStatus_names[] =
  "MentorRelationBreak"
  "MentorRelationBreakApply"
  "MentorRelationComplete"
  "MentorRelationIn"
  "MentorRelationMax";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry MentorRelationStatus_entries[] = {
  { {MentorRelationStatus_names + 0, 19}, 4 },
  { {MentorRelationStatus_names + 19, 24}, 3 },
  { {MentorRelationStatus_names + 43, 22}, 2 },
  { {MentorRelationStatus_names + 65, 16}, 1 },
  { {MentorRelationStatus_names + 81, 17}, 5 },
};

static const int MentorRelationStatus_entries_by_number[] = {
  3, // 1 -> MentorRelationIn
  2, // 2 -> MentorRelationComplete
  1, // 3 -> MentorRelationBreakApply
  0, // 4 -> MentorRelationBreak
  4, // 5 -> MentorRelationMax
};

const std::string& MentorRelationStatus_Name(
    MentorRelationStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          MentorRelationStatus_entries,
          MentorRelationStatus_entries_by_number,
          5, MentorRelationStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      MentorRelationStatus_entries,
      MentorRelationStatus_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     MentorRelationStatus_strings[idx].get();
}
bool MentorRelationStatus_Parse(
    const std::string& name, MentorRelationStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      MentorRelationStatus_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<MentorRelationStatus>(int_value);
  }
  return success;
}
bool MentorMsgApplyType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> MentorMsgApplyType_strings[6] = {};

static const char MentorMsgApplyType_names[] =
  "MentorMsgApplyBreak"
  "MentorMsgApplyInherit"
  "MentorMsgApplyMaster"
  "MentorMsgApplyMax"
  "MentorMsgApplyReportTask"
  "MentorMsgApplyStudent";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry MentorMsgApplyType_entries[] = {
  { {MentorMsgApplyType_names + 0, 19}, 5 },
  { {MentorMsgApplyType_names + 19, 21}, 3 },
  { {MentorMsgApplyType_names + 40, 20}, 1 },
  { {MentorMsgApplyType_names + 60, 17}, 6 },
  { {MentorMsgApplyType_names + 77, 24}, 4 },
  { {MentorMsgApplyType_names + 101, 21}, 2 },
};

static const int MentorMsgApplyType_entries_by_number[] = {
  2, // 1 -> MentorMsgApplyMaster
  5, // 2 -> MentorMsgApplyStudent
  1, // 3 -> MentorMsgApplyInherit
  4, // 4 -> MentorMsgApplyReportTask
  0, // 5 -> MentorMsgApplyBreak
  3, // 6 -> MentorMsgApplyMax
};

const std::string& MentorMsgApplyType_Name(
    MentorMsgApplyType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          MentorMsgApplyType_entries,
          MentorMsgApplyType_entries_by_number,
          6, MentorMsgApplyType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      MentorMsgApplyType_entries,
      MentorMsgApplyType_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     MentorMsgApplyType_strings[idx].get();
}
bool MentorMsgApplyType_Parse(
    const std::string& name, MentorMsgApplyType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      MentorMsgApplyType_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<MentorMsgApplyType>(int_value);
  }
  return success;
}
bool MentorRelationOpType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> MentorRelationOpType_strings[10] = {};

static const char MentorRelationOpType_names[] =
  "MentorRelationOp_ApplyMaster"
  "MentorRelationOp_ApplyStudent"
  "MentorRelationOp_Break"
  "MentorRelationOp_BreakCancel"
  "MentorRelationOp_ForceComplete"
  "MentorRelationOp_Inherit"
  "MentorRelationOp_Max"
  "MentorRelationOp_NormalComplete"
  "MentorRelationOp_ReportAllTask"
  "MentorRelationOp_ReportTask";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry MentorRelationOpType_entries[] = {
  { {MentorRelationOpType_names + 0, 28}, 1 },
  { {MentorRelationOpType_names + 28, 29}, 2 },
  { {MentorRelationOpType_names + 57, 22}, 6 },
  { {MentorRelationOpType_names + 79, 28}, 7 },
  { {MentorRelationOpType_names + 107, 30}, 9 },
  { {MentorRelationOpType_names + 137, 24}, 3 },
  { {MentorRelationOpType_names + 161, 20}, 10 },
  { {MentorRelationOpType_names + 181, 31}, 8 },
  { {MentorRelationOpType_names + 212, 30}, 5 },
  { {MentorRelationOpType_names + 242, 27}, 4 },
};

static const int MentorRelationOpType_entries_by_number[] = {
  0, // 1 -> MentorRelationOp_ApplyMaster
  1, // 2 -> MentorRelationOp_ApplyStudent
  5, // 3 -> MentorRelationOp_Inherit
  9, // 4 -> MentorRelationOp_ReportTask
  8, // 5 -> MentorRelationOp_ReportAllTask
  2, // 6 -> MentorRelationOp_Break
  3, // 7 -> MentorRelationOp_BreakCancel
  7, // 8 -> MentorRelationOp_NormalComplete
  4, // 9 -> MentorRelationOp_ForceComplete
  6, // 10 -> MentorRelationOp_Max
};

const std::string& MentorRelationOpType_Name(
    MentorRelationOpType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          MentorRelationOpType_entries,
          MentorRelationOpType_entries_by_number,
          10, MentorRelationOpType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      MentorRelationOpType_entries,
      MentorRelationOpType_entries_by_number,
      10, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     MentorRelationOpType_strings[idx].get();
}
bool MentorRelationOpType_Parse(
    const std::string& name, MentorRelationOpType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      MentorRelationOpType_entries, 10, name, &int_value);
  if (success) {
    *value = static_cast<MentorRelationOpType>(int_value);
  }
  return success;
}
bool EMentorRelationPosition_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> EMentorRelationPosition_strings[3] = {};

static const char EMentorRelationPosition_names[] =
  "EMentorPosMaster"
  "EMentorPosMax"
  "EMentorPosStudent";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry EMentorRelationPosition_entries[] = {
  { {EMentorRelationPosition_names + 0, 16}, 1 },
  { {EMentorRelationPosition_names + 16, 13}, 3 },
  { {EMentorRelationPosition_names + 29, 17}, 2 },
};

static const int EMentorRelationPosition_entries_by_number[] = {
  0, // 1 -> EMentorPosMaster
  2, // 2 -> EMentorPosStudent
  1, // 3 -> EMentorPosMax
};

const std::string& EMentorRelationPosition_Name(
    EMentorRelationPosition value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          EMentorRelationPosition_entries,
          EMentorRelationPosition_entries_by_number,
          3, EMentorRelationPosition_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      EMentorRelationPosition_entries,
      EMentorRelationPosition_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     EMentorRelationPosition_strings[idx].get();
}
bool EMentorRelationPosition_Parse(
    const std::string& name, EMentorRelationPosition* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      EMentorRelationPosition_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<EMentorRelationPosition>(int_value);
  }
  return success;
}
bool EMentorTaskStatus_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> EMentorTaskStatus_strings[6] = {};

static const char EMentorTaskStatus_names[] =
  "EMentorTask_AlreadyReport"
  "EMentorTask_CanReport"
  "EMentorTask_CompleteBefore"
  "EMentorTask_ConfirmReport"
  "EMentorTask_Max"
  "EMentorTask_UnComplete";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry EMentorTaskStatus_entries[] = {
  { {EMentorTaskStatus_names + 0, 25}, 3 },
  { {EMentorTaskStatus_names + 25, 21}, 2 },
  { {EMentorTaskStatus_names + 46, 26}, 5 },
  { {EMentorTaskStatus_names + 72, 25}, 4 },
  { {EMentorTaskStatus_names + 97, 15}, 6 },
  { {EMentorTaskStatus_names + 112, 22}, 1 },
};

static const int EMentorTaskStatus_entries_by_number[] = {
  5, // 1 -> EMentorTask_UnComplete
  1, // 2 -> EMentorTask_CanReport
  0, // 3 -> EMentorTask_AlreadyReport
  3, // 4 -> EMentorTask_ConfirmReport
  2, // 5 -> EMentorTask_CompleteBefore
  4, // 6 -> EMentorTask_Max
};

const std::string& EMentorTaskStatus_Name(
    EMentorTaskStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          EMentorTaskStatus_entries,
          EMentorTaskStatus_entries_by_number,
          6, EMentorTaskStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      EMentorTaskStatus_entries,
      EMentorTaskStatus_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     EMentorTaskStatus_strings[idx].get();
}
bool EMentorTaskStatus_Parse(
    const std::string& name, EMentorTaskStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      EMentorTaskStatus_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<EMentorTaskStatus>(int_value);
  }
  return success;
}
bool EMentorMsgOpType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> EMentorMsgOpType_strings[5] = {};

static const char EMentorMsgOpType_names[] =
  "EMentorMsgOpType_Agree"
  "EMentorMsgOpType_Clear"
  "EMentorMsgOpType_Max"
  "EMentorMsgOpType_Reject"
  "EMentorMsgOp_Get";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry EMentorMsgOpType_entries[] = {
  { {EMentorMsgOpType_names + 0, 22}, 3 },
  { {EMentorMsgOpType_names + 22, 22}, 2 },
  { {EMentorMsgOpType_names + 44, 20}, 5 },
  { {EMentorMsgOpType_names + 64, 23}, 4 },
  { {EMentorMsgOpType_names + 87, 16}, 1 },
};

static const int EMentorMsgOpType_entries_by_number[] = {
  4, // 1 -> EMentorMsgOp_Get
  1, // 2 -> EMentorMsgOpType_Clear
  0, // 3 -> EMentorMsgOpType_Agree
  3, // 4 -> EMentorMsgOpType_Reject
  2, // 5 -> EMentorMsgOpType_Max
};

const std::string& EMentorMsgOpType_Name(
    EMentorMsgOpType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          EMentorMsgOpType_entries,
          EMentorMsgOpType_entries_by_number,
          5, EMentorMsgOpType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      EMentorMsgOpType_entries,
      EMentorMsgOpType_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     EMentorMsgOpType_strings[idx].get();
}
bool EMentorMsgOpType_Parse(
    const std::string& name, EMentorMsgOpType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      EMentorMsgOpType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<EMentorMsgOpType>(int_value);
  }
  return success;
}
bool PartnerUpdateType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PartnerUpdateType_strings[4] = {};

static const char PartnerUpdateType_names[] =
  "PUType_Dissolve"
  "PUType_Leave"
  "PUType_Normal"
  "PUType_Shop";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PartnerUpdateType_entries[] = {
  { {PartnerUpdateType_names + 0, 15}, 3 },
  { {PartnerUpdateType_names + 15, 12}, 2 },
  { {PartnerUpdateType_names + 27, 13}, 1 },
  { {PartnerUpdateType_names + 40, 11}, 4 },
};

static const int PartnerUpdateType_entries_by_number[] = {
  2, // 1 -> PUType_Normal
  1, // 2 -> PUType_Leave
  0, // 3 -> PUType_Dissolve
  3, // 4 -> PUType_Shop
};

const std::string& PartnerUpdateType_Name(
    PartnerUpdateType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PartnerUpdateType_entries,
          PartnerUpdateType_entries_by_number,
          4, PartnerUpdateType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PartnerUpdateType_entries,
      PartnerUpdateType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PartnerUpdateType_strings[idx].get();
}
bool PartnerUpdateType_Parse(
    const std::string& name, PartnerUpdateType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PartnerUpdateType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<PartnerUpdateType>(int_value);
  }
  return success;
}
bool PartnerOperType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PartnerOperType_strings[6] = {};

static const char PartnerOperType_names[] =
  "POT_ApplyLeave"
  "POT_CancelLeave"
  "POT_Dissolve"
  "POT_Leave"
  "POT_Liveness"
  "POT_Normal";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PartnerOperType_entries[] = {
  { {PartnerOperType_names + 0, 14}, 4 },
  { {PartnerOperType_names + 14, 15}, 5 },
  { {PartnerOperType_names + 29, 12}, 6 },
  { {PartnerOperType_names + 41, 9}, 3 },
  { {PartnerOperType_names + 50, 12}, 2 },
  { {PartnerOperType_names + 62, 10}, 1 },
};

static const int PartnerOperType_entries_by_number[] = {
  5, // 1 -> POT_Normal
  4, // 2 -> POT_Liveness
  3, // 3 -> POT_Leave
  0, // 4 -> POT_ApplyLeave
  1, // 5 -> POT_CancelLeave
  2, // 6 -> POT_Dissolve
};

const std::string& PartnerOperType_Name(
    PartnerOperType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PartnerOperType_entries,
          PartnerOperType_entries_by_number,
          6, PartnerOperType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PartnerOperType_entries,
      PartnerOperType_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PartnerOperType_strings[idx].get();
}
bool PartnerOperType_Parse(
    const std::string& name, PartnerOperType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PartnerOperType_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<PartnerOperType>(int_value);
  }
  return success;
}
bool InvFightReqType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> InvFightReqType_strings[5] = {};

static const char InvFightReqType_names[] =
  "IFRT_ACCEPT_ONE"
  "IFRT_IGNORE_ALL"
  "IFRT_INV_ONE"
  "IFRT_REFUSH_ONE"
  "IFRT_REQ_LIST";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry InvFightReqType_entries[] = {
  { {InvFightReqType_names + 0, 15}, 5 },
  { {InvFightReqType_names + 15, 15}, 3 },
  { {InvFightReqType_names + 30, 12}, 1 },
  { {InvFightReqType_names + 42, 15}, 2 },
  { {InvFightReqType_names + 57, 13}, 4 },
};

static const int InvFightReqType_entries_by_number[] = {
  2, // 1 -> IFRT_INV_ONE
  3, // 2 -> IFRT_REFUSH_ONE
  1, // 3 -> IFRT_IGNORE_ALL
  4, // 4 -> IFRT_REQ_LIST
  0, // 5 -> IFRT_ACCEPT_ONE
};

const std::string& InvFightReqType_Name(
    InvFightReqType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          InvFightReqType_entries,
          InvFightReqType_entries_by_number,
          5, InvFightReqType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      InvFightReqType_entries,
      InvFightReqType_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     InvFightReqType_strings[idx].get();
}
bool InvFightReqType_Parse(
    const std::string& name, InvFightReqType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      InvFightReqType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<InvFightReqType>(int_value);
  }
  return success;
}
bool InvFightNotifyType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> InvFightNotifyType_strings[2] = {};

static const char InvFightNotifyType_names[] =
  "IFNT_INVITE_ME"
  "IFNT_REFUSE_ME";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry InvFightNotifyType_entries[] = {
  { {InvFightNotifyType_names + 0, 14}, 2 },
  { {InvFightNotifyType_names + 14, 14}, 1 },
};

static const int InvFightNotifyType_entries_by_number[] = {
  1, // 1 -> IFNT_REFUSE_ME
  0, // 2 -> IFNT_INVITE_ME
};

const std::string& InvFightNotifyType_Name(
    InvFightNotifyType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          InvFightNotifyType_entries,
          InvFightNotifyType_entries_by_number,
          2, InvFightNotifyType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      InvFightNotifyType_entries,
      InvFightNotifyType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     InvFightNotifyType_strings[idx].get();
}
bool InvFightNotifyType_Parse(
    const std::string& name, InvFightNotifyType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      InvFightNotifyType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<InvFightNotifyType>(int_value);
  }
  return success;
}
bool GCFReqType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GCFReqType_strings[4] = {};

static const char GCFReqType_names[] =
  "GCF_FIGHT_REPORT"
  "GCF_FIGHT_RESULT"
  "GCF_JOIN_FIGHT_SCENE"
  "GCF_JOIN_READY_SCENE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GCFReqType_entries[] = {
  { {GCFReqType_names + 0, 16}, 2 },
  { {GCFReqType_names + 16, 16}, 3 },
  { {GCFReqType_names + 32, 20}, 4 },
  { {GCFReqType_names + 52, 20}, 1 },
};

static const int GCFReqType_entries_by_number[] = {
  3, // 1 -> GCF_JOIN_READY_SCENE
  0, // 2 -> GCF_FIGHT_REPORT
  1, // 3 -> GCF_FIGHT_RESULT
  2, // 4 -> GCF_JOIN_FIGHT_SCENE
};

const std::string& GCFReqType_Name(
    GCFReqType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GCFReqType_entries,
          GCFReqType_entries_by_number,
          4, GCFReqType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GCFReqType_entries,
      GCFReqType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GCFReqType_strings[idx].get();
}
bool GCFReqType_Parse(
    const std::string& name, GCFReqType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GCFReqType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<GCFReqType>(int_value);
  }
  return success;
}
bool GCFJvDianType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GCFJvDianType_strings[3] = {};

static const char GCFJvDianType_names[] =
  "GCF_JUDIAN_DOWN"
  "GCF_JUDIAN_MID"
  "GCF_JUDIAN_UP";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GCFJvDianType_entries[] = {
  { {GCFJvDianType_names + 0, 15}, 3 },
  { {GCFJvDianType_names + 15, 14}, 2 },
  { {GCFJvDianType_names + 29, 13}, 1 },
};

static const int GCFJvDianType_entries_by_number[] = {
  2, // 1 -> GCF_JUDIAN_UP
  1, // 2 -> GCF_JUDIAN_MID
  0, // 3 -> GCF_JUDIAN_DOWN
};

const std::string& GCFJvDianType_Name(
    GCFJvDianType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GCFJvDianType_entries,
          GCFJvDianType_entries_by_number,
          3, GCFJvDianType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GCFJvDianType_entries,
      GCFJvDianType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GCFJvDianType_strings[idx].get();
}
bool GCFJvDianType_Parse(
    const std::string& name, GCFJvDianType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GCFJvDianType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<GCFJvDianType>(int_value);
  }
  return success;
}
bool GCFZhanLingType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GCFZhanLingType_strings[3] = {};

static const char GCFZhanLingType_names[] =
  "GCFZL_BEGIN"
  "GCFZL_BREAK"
  "GCFZL_END";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GCFZhanLingType_entries[] = {
  { {GCFZhanLingType_names + 0, 11}, 1 },
  { {GCFZhanLingType_names + 11, 11}, 2 },
  { {GCFZhanLingType_names + 22, 9}, 3 },
};

static const int GCFZhanLingType_entries_by_number[] = {
  0, // 1 -> GCFZL_BEGIN
  1, // 2 -> GCFZL_BREAK
  2, // 3 -> GCFZL_END
};

const std::string& GCFZhanLingType_Name(
    GCFZhanLingType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GCFZhanLingType_entries,
          GCFZhanLingType_entries_by_number,
          3, GCFZhanLingType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GCFZhanLingType_entries,
      GCFZhanLingType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GCFZhanLingType_strings[idx].get();
}
bool GCFZhanLingType_Parse(
    const std::string& name, GCFZhanLingType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GCFZhanLingType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<GCFZhanLingType>(int_value);
  }
  return success;
}
bool GCFsynType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GCFsynType_strings[6] = {};

static const char GCFsynType_names[] =
  "GCF_SYN_BACK_TO_READY"
  "GCF_SYN_FIGHT_END"
  "GCF_SYN_KILL"
  "GCF_SYN_LEAVE_BATTLE"
  "GCF_SYN_MUL_POINT"
  "GCF_SYN_OCCUPY";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GCFsynType_entries[] = {
  { {GCFsynType_names + 0, 21}, 6 },
  { {GCFsynType_names + 21, 17}, 5 },
  { {GCFsynType_names + 38, 12}, 1 },
  { {GCFsynType_names + 50, 20}, 2 },
  { {GCFsynType_names + 70, 17}, 4 },
  { {GCFsynType_names + 87, 14}, 3 },
};

static const int GCFsynType_entries_by_number[] = {
  2, // 1 -> GCF_SYN_KILL
  3, // 2 -> GCF_SYN_LEAVE_BATTLE
  5, // 3 -> GCF_SYN_OCCUPY
  4, // 4 -> GCF_SYN_MUL_POINT
  1, // 5 -> GCF_SYN_FIGHT_END
  0, // 6 -> GCF_SYN_BACK_TO_READY
};

const std::string& GCFsynType_Name(
    GCFsynType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GCFsynType_entries,
          GCFsynType_entries_by_number,
          6, GCFsynType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GCFsynType_entries,
      GCFsynType_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GCFsynType_strings[idx].get();
}
bool GCFsynType_Parse(
    const std::string& name, GCFsynType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GCFsynType_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<GCFsynType>(int_value);
  }
  return success;
}
bool GUILDTERRTYPE_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GUILDTERRTYPE_strings[5] = {};

static const char GUILDTERRTYPE_names[] =
  "ALLIANCE"
  "TERR_END"
  "TERR_NOT_OPEN"
  "TERR_WARING"
  "WAITING";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GUILDTERRTYPE_entries[] = {
  { {GUILDTERRTYPE_names + 0, 8}, 2 },
  { {GUILDTERRTYPE_names + 8, 8}, 4 },
  { {GUILDTERRTYPE_names + 16, 13}, 1 },
  { {GUILDTERRTYPE_names + 29, 11}, 3 },
  { {GUILDTERRTYPE_names + 40, 7}, 5 },
};

static const int GUILDTERRTYPE_entries_by_number[] = {
  2, // 1 -> TERR_NOT_OPEN
  0, // 2 -> ALLIANCE
  3, // 3 -> TERR_WARING
  1, // 4 -> TERR_END
  4, // 5 -> WAITING
};

const std::string& GUILDTERRTYPE_Name(
    GUILDTERRTYPE value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GUILDTERRTYPE_entries,
          GUILDTERRTYPE_entries_by_number,
          5, GUILDTERRTYPE_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GUILDTERRTYPE_entries,
      GUILDTERRTYPE_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GUILDTERRTYPE_strings[idx].get();
}
bool GUILDTERRTYPE_Parse(
    const std::string& name, GUILDTERRTYPE* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GUILDTERRTYPE_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<GUILDTERRTYPE>(int_value);
  }
  return success;
}
bool GCFG2CSynType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GCFG2CSynType_strings[4] = {};

static const char GCFG2CSynType_names[] =
  "GCF_G2C_SYN_KILL_COUNT"
  "GCF_G2C_SYN_KILL_ONE"
  "GCF_G2C_SYN_MUL_POINT"
  "GCF_G2C_SYN_OCCUPY";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GCFG2CSynType_entries[] = {
  { {GCFG2CSynType_names + 0, 22}, 4 },
  { {GCFG2CSynType_names + 22, 20}, 1 },
  { {GCFG2CSynType_names + 42, 21}, 2 },
  { {GCFG2CSynType_names + 63, 18}, 3 },
};

static const int GCFG2CSynType_entries_by_number[] = {
  1, // 1 -> GCF_G2C_SYN_KILL_ONE
  2, // 2 -> GCF_G2C_SYN_MUL_POINT
  3, // 3 -> GCF_G2C_SYN_OCCUPY
  0, // 4 -> GCF_G2C_SYN_KILL_COUNT
};

const std::string& GCFG2CSynType_Name(
    GCFG2CSynType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GCFG2CSynType_entries,
          GCFG2CSynType_entries_by_number,
          4, GCFG2CSynType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GCFG2CSynType_entries,
      GCFG2CSynType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GCFG2CSynType_strings[idx].get();
}
bool GCFG2CSynType_Parse(
    const std::string& name, GCFG2CSynType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GCFG2CSynType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<GCFG2CSynType>(int_value);
  }
  return success;
}
bool UnitSpecialState_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> UnitSpecialState_strings[2] = {};

static const char UnitSpecialState_names[] =
  "Unit_Invisible"
  "Unit_Puppet";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry UnitSpecialState_entries[] = {
  { {UnitSpecialState_names + 0, 14}, 2 },
  { {UnitSpecialState_names + 14, 11}, 1 },
};

static const int UnitSpecialState_entries_by_number[] = {
  1, // 1 -> Unit_Puppet
  0, // 2 -> Unit_Invisible
};

const std::string& UnitSpecialState_Name(
    UnitSpecialState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          UnitSpecialState_entries,
          UnitSpecialState_entries_by_number,
          2, UnitSpecialState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      UnitSpecialState_entries,
      UnitSpecialState_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     UnitSpecialState_strings[idx].get();
}
bool UnitSpecialState_Parse(
    const std::string& name, UnitSpecialState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      UnitSpecialState_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<UnitSpecialState>(int_value);
  }
  return success;
}
bool PayAccessDataType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PayAccessDataType_strings[5] = {};

static const char PayAccessDataType_names[] =
  "PayAccess_ALL"
  "PayAccess_Consume"
  "PayAccess_Other"
  "PayAccess_SaveAmt"
  "PayAccess_Send";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PayAccessDataType_entries[] = {
  { {PayAccessDataType_names + 0, 13}, 5 },
  { {PayAccessDataType_names + 13, 17}, 4 },
  { {PayAccessDataType_names + 30, 15}, 2 },
  { {PayAccessDataType_names + 45, 17}, 1 },
  { {PayAccessDataType_names + 62, 14}, 3 },
};

static const int PayAccessDataType_entries_by_number[] = {
  3, // 1 -> PayAccess_SaveAmt
  2, // 2 -> PayAccess_Other
  4, // 3 -> PayAccess_Send
  1, // 4 -> PayAccess_Consume
  0, // 5 -> PayAccess_ALL
};

const std::string& PayAccessDataType_Name(
    PayAccessDataType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PayAccessDataType_entries,
          PayAccessDataType_entries_by_number,
          5, PayAccessDataType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PayAccessDataType_entries,
      PayAccessDataType_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PayAccessDataType_strings[idx].get();
}
bool PayAccessDataType_Parse(
    const std::string& name, PayAccessDataType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PayAccessDataType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<PayAccessDataType>(int_value);
  }
  return success;
}
bool BroadCastG2RType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> BroadCastG2RType_strings[3] = {};

static const char BroadCastG2RType_names[] =
  "BroadCastG2RType_DB"
  "BroadCastG2RType_MS"
  "BroadCastG2RType_NS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry BroadCastG2RType_entries[] = {
  { {BroadCastG2RType_names + 0, 19}, 3 },
  { {BroadCastG2RType_names + 19, 19}, 1 },
  { {BroadCastG2RType_names + 38, 19}, 2 },
};

static const int BroadCastG2RType_entries_by_number[] = {
  1, // 1 -> BroadCastG2RType_MS
  2, // 2 -> BroadCastG2RType_NS
  0, // 3 -> BroadCastG2RType_DB
};

const std::string& BroadCastG2RType_Name(
    BroadCastG2RType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          BroadCastG2RType_entries,
          BroadCastG2RType_entries_by_number,
          3, BroadCastG2RType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      BroadCastG2RType_entries,
      BroadCastG2RType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     BroadCastG2RType_strings[idx].get();
}
bool BroadCastG2RType_Parse(
    const std::string& name, BroadCastG2RType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      BroadCastG2RType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<BroadCastG2RType>(int_value);
  }
  return success;
}
bool HeroBattleOver_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> HeroBattleOver_strings[3] = {};

static const char HeroBattleOver_names[] =
  "HeroBattleOver_Draw"
  "HeroBattleOver_Lose"
  "HeroBattleOver_Win";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry HeroBattleOver_entries[] = {
  { {HeroBattleOver_names + 0, 19}, 3 },
  { {HeroBattleOver_names + 19, 19}, 2 },
  { {HeroBattleOver_names + 38, 18}, 1 },
};

static const int HeroBattleOver_entries_by_number[] = {
  2, // 1 -> HeroBattleOver_Win
  1, // 2 -> HeroBattleOver_Lose
  0, // 3 -> HeroBattleOver_Draw
};

const std::string& HeroBattleOver_Name(
    HeroBattleOver value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          HeroBattleOver_entries,
          HeroBattleOver_entries_by_number,
          3, HeroBattleOver_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      HeroBattleOver_entries,
      HeroBattleOver_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     HeroBattleOver_strings[idx].get();
}
bool HeroBattleOver_Parse(
    const std::string& name, HeroBattleOver* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      HeroBattleOver_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<HeroBattleOver>(int_value);
  }
  return success;
}
bool LeagueBattleTimeState_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LeagueBattleTimeState_strings[9] = {};

static const char LeagueBattleTimeState_names[] =
  "LBTS_Apply"
  "LBTS_BeforeOpen"
  "LBTS_CrossElimination"
  "LBTS_CrossIdle"
  "LBTS_CrossPointRace"
  "LBTS_Elimination"
  "LBTS_Idle"
  "LBTS_PointRace"
  "LBTS_SeasonEnd";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LeagueBattleTimeState_entries[] = {
  { {LeagueBattleTimeState_names + 0, 10}, 2 },
  { {LeagueBattleTimeState_names + 10, 15}, 1 },
  { {LeagueBattleTimeState_names + 25, 21}, 8 },
  { {LeagueBattleTimeState_names + 46, 14}, 6 },
  { {LeagueBattleTimeState_names + 60, 19}, 7 },
  { {LeagueBattleTimeState_names + 79, 16}, 5 },
  { {LeagueBattleTimeState_names + 95, 9}, 3 },
  { {LeagueBattleTimeState_names + 104, 14}, 4 },
  { {LeagueBattleTimeState_names + 118, 14}, 9 },
};

static const int LeagueBattleTimeState_entries_by_number[] = {
  1, // 1 -> LBTS_BeforeOpen
  0, // 2 -> LBTS_Apply
  6, // 3 -> LBTS_Idle
  7, // 4 -> LBTS_PointRace
  5, // 5 -> LBTS_Elimination
  3, // 6 -> LBTS_CrossIdle
  4, // 7 -> LBTS_CrossPointRace
  2, // 8 -> LBTS_CrossElimination
  8, // 9 -> LBTS_SeasonEnd
};

const std::string& LeagueBattleTimeState_Name(
    LeagueBattleTimeState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          LeagueBattleTimeState_entries,
          LeagueBattleTimeState_entries_by_number,
          9, LeagueBattleTimeState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      LeagueBattleTimeState_entries,
      LeagueBattleTimeState_entries_by_number,
      9, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     LeagueBattleTimeState_strings[idx].get();
}
bool LeagueBattleTimeState_Parse(
    const std::string& name, LeagueBattleTimeState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      LeagueBattleTimeState_entries, 9, name, &int_value);
  if (success) {
    *value = static_cast<LeagueBattleTimeState>(int_value);
  }
  return success;
}
bool LeagueBattleReqType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LeagueBattleReqType_strings[2] = {};

static const char LeagueBattleReqType_names[] =
  "LBReqType_CancelMatch"
  "LBReqType_Match";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LeagueBattleReqType_entries[] = {
  { {LeagueBattleReqType_names + 0, 21}, 2 },
  { {LeagueBattleReqType_names + 21, 15}, 1 },
};

static const int LeagueBattleReqType_entries_by_number[] = {
  1, // 1 -> LBReqType_Match
  0, // 2 -> LBReqType_CancelMatch
};

const std::string& LeagueBattleReqType_Name(
    LeagueBattleReqType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          LeagueBattleReqType_entries,
          LeagueBattleReqType_entries_by_number,
          2, LeagueBattleReqType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      LeagueBattleReqType_entries,
      LeagueBattleReqType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     LeagueBattleReqType_strings[idx].get();
}
bool LeagueBattleReqType_Parse(
    const std::string& name, LeagueBattleReqType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      LeagueBattleReqType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<LeagueBattleReqType>(int_value);
  }
  return success;
}
bool LeagueTeamState_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LeagueTeamState_strings[3] = {};

static const char LeagueTeamState_names[] =
  "LeagueTeamState_Battle"
  "LeagueTeamState_Idle"
  "LeagueTeamState_Match";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LeagueTeamState_entries[] = {
  { {LeagueTeamState_names + 0, 22}, 3 },
  { {LeagueTeamState_names + 22, 20}, 1 },
  { {LeagueTeamState_names + 42, 21}, 2 },
};

static const int LeagueTeamState_entries_by_number[] = {
  1, // 1 -> LeagueTeamState_Idle
  2, // 2 -> LeagueTeamState_Match
  0, // 3 -> LeagueTeamState_Battle
};

const std::string& LeagueTeamState_Name(
    LeagueTeamState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          LeagueTeamState_entries,
          LeagueTeamState_entries_by_number,
          3, LeagueTeamState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      LeagueTeamState_entries,
      LeagueTeamState_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     LeagueTeamState_strings[idx].get();
}
bool LeagueTeamState_Parse(
    const std::string& name, LeagueTeamState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      LeagueTeamState_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<LeagueTeamState>(int_value);
  }
  return success;
}
bool LeagueBattleRoleState_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LeagueBattleRoleState_strings[6] = {};

static const char LeagueBattleRoleState_names[] =
  "LBRoleState_Failed"
  "LBRoleState_Fighting"
  "LBRoleState_Leave"
  "LBRoleState_None"
  "LBRoleState_Waiting"
  "LBRoleState_Win";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LeagueBattleRoleState_entries[] = {
  { {LeagueBattleRoleState_names + 0, 18}, 6 },
  { {LeagueBattleRoleState_names + 18, 20}, 4 },
  { {LeagueBattleRoleState_names + 38, 17}, 3 },
  { {LeagueBattleRoleState_names + 55, 16}, 1 },
  { {LeagueBattleRoleState_names + 71, 19}, 2 },
  { {LeagueBattleRoleState_names + 90, 15}, 5 },
};

static const int LeagueBattleRoleState_entries_by_number[] = {
  3, // 1 -> LBRoleState_None
  4, // 2 -> LBRoleState_Waiting
  2, // 3 -> LBRoleState_Leave
  1, // 4 -> LBRoleState_Fighting
  5, // 5 -> LBRoleState_Win
  0, // 6 -> LBRoleState_Failed
};

const std::string& LeagueBattleRoleState_Name(
    LeagueBattleRoleState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          LeagueBattleRoleState_entries,
          LeagueBattleRoleState_entries_by_number,
          6, LeagueBattleRoleState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      LeagueBattleRoleState_entries,
      LeagueBattleRoleState_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     LeagueBattleRoleState_strings[idx].get();
}
bool LeagueBattleRoleState_Parse(
    const std::string& name, LeagueBattleRoleState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      LeagueBattleRoleState_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<LeagueBattleRoleState>(int_value);
  }
  return success;
}
bool LeagueBattleReadyOper_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LeagueBattleReadyOper_strings[2] = {};

static const char LeagueBattleReadyOper_names[] =
  "LBReady_Down"
  "LBReady_Up";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LeagueBattleReadyOper_entries[] = {
  { {LeagueBattleReadyOper_names + 0, 12}, 2 },
  { {LeagueBattleReadyOper_names + 12, 10}, 1 },
};

static const int LeagueBattleReadyOper_entries_by_number[] = {
  1, // 1 -> LBReady_Up
  0, // 2 -> LBReady_Down
};

const std::string& LeagueBattleReadyOper_Name(
    LeagueBattleReadyOper value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          LeagueBattleReadyOper_entries,
          LeagueBattleReadyOper_entries_by_number,
          2, LeagueBattleReadyOper_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      LeagueBattleReadyOper_entries,
      LeagueBattleReadyOper_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     LeagueBattleReadyOper_strings[idx].get();
}
bool LeagueBattleReadyOper_Parse(
    const std::string& name, LeagueBattleReadyOper* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      LeagueBattleReadyOper_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<LeagueBattleReadyOper>(int_value);
  }
  return success;
}
bool LeagueBattleType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LeagueBattleType_strings[4] = {};

static const char LeagueBattleType_names[] =
  "LeagueBattleType_CrossEliminate"
  "LeagueBattleType_CrossRacePoint"
  "LeagueBattleType_Eliminate"
  "LeagueBattleType_RacePoint";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LeagueBattleType_entries[] = {
  { {LeagueBattleType_names + 0, 31}, 4 },
  { {LeagueBattleType_names + 31, 31}, 3 },
  { {LeagueBattleType_names + 62, 26}, 2 },
  { {LeagueBattleType_names + 88, 26}, 1 },
};

static const int LeagueBattleType_entries_by_number[] = {
  3, // 1 -> LeagueBattleType_RacePoint
  2, // 2 -> LeagueBattleType_Eliminate
  1, // 3 -> LeagueBattleType_CrossRacePoint
  0, // 4 -> LeagueBattleType_CrossEliminate
};

const std::string& LeagueBattleType_Name(
    LeagueBattleType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          LeagueBattleType_entries,
          LeagueBattleType_entries_by_number,
          4, LeagueBattleType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      LeagueBattleType_entries,
      LeagueBattleType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     LeagueBattleType_strings[idx].get();
}
bool LeagueBattleType_Parse(
    const std::string& name, LeagueBattleType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      LeagueBattleType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<LeagueBattleType>(int_value);
  }
  return success;
}
bool SkillTypeEnum_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SkillTypeEnum_strings[7] = {};

static const char SkillTypeEnum_names[] =
  "Skill_Big"
  "Skill_Buff"
  "Skill_Help"
  "Skill_None"
  "Skill_Normal"
  "Skill_SceneBuff"
  "Skill_UnUsed";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SkillTypeEnum_entries[] = {
  { {SkillTypeEnum_names + 0, 9}, 2 },
  { {SkillTypeEnum_names + 9, 10}, 6 },
  { {SkillTypeEnum_names + 19, 10}, 5 },
  { {SkillTypeEnum_names + 29, 10}, 0 },
  { {SkillTypeEnum_names + 39, 12}, 1 },
  { {SkillTypeEnum_names + 51, 15}, 4 },
  { {SkillTypeEnum_names + 66, 12}, 3 },
};

static const int SkillTypeEnum_entries_by_number[] = {
  3, // 0 -> Skill_None
  4, // 1 -> Skill_Normal
  0, // 2 -> Skill_Big
  6, // 3 -> Skill_UnUsed
  5, // 4 -> Skill_SceneBuff
  2, // 5 -> Skill_Help
  1, // 6 -> Skill_Buff
};

const std::string& SkillTypeEnum_Name(
    SkillTypeEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SkillTypeEnum_entries,
          SkillTypeEnum_entries_by_number,
          7, SkillTypeEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SkillTypeEnum_entries,
      SkillTypeEnum_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SkillTypeEnum_strings[idx].get();
}
bool SkillTypeEnum_Parse(
    const std::string& name, SkillTypeEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SkillTypeEnum_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<SkillTypeEnum>(int_value);
  }
  return success;
}
bool LeagueBattleFightState_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LeagueBattleFightState_strings[4] = {};

static const char LeagueBattleFightState_names[] =
  "LBFight_Fight"
  "LBFight_None"
  "LBFight_Result"
  "LBFight_Wait";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LeagueBattleFightState_entries[] = {
  { {LeagueBattleFightState_names + 0, 13}, 3 },
  { {LeagueBattleFightState_names + 13, 12}, 1 },
  { {LeagueBattleFightState_names + 25, 14}, 4 },
  { {LeagueBattleFightState_names + 39, 12}, 2 },
};

static const int LeagueBattleFightState_entries_by_number[] = {
  1, // 1 -> LBFight_None
  3, // 2 -> LBFight_Wait
  0, // 3 -> LBFight_Fight
  2, // 4 -> LBFight_Result
};

const std::string& LeagueBattleFightState_Name(
    LeagueBattleFightState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          LeagueBattleFightState_entries,
          LeagueBattleFightState_entries_by_number,
          4, LeagueBattleFightState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      LeagueBattleFightState_entries,
      LeagueBattleFightState_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     LeagueBattleFightState_strings[idx].get();
}
bool LeagueBattleFightState_Parse(
    const std::string& name, LeagueBattleFightState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      LeagueBattleFightState_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<LeagueBattleFightState>(int_value);
  }
  return success;
}
bool LBEleRoomState_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LBEleRoomState_strings[3] = {};

static const char LBEleRoomState_names[] =
  "LBEleRoomState_Fighting"
  "LBEleRoomState_Finish"
  "LBEleRoomState_Idle";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LBEleRoomState_entries[] = {
  { {LBEleRoomState_names + 0, 23}, 2 },
  { {LBEleRoomState_names + 23, 21}, 3 },
  { {LBEleRoomState_names + 44, 19}, 1 },
};

static const int LBEleRoomState_entries_by_number[] = {
  2, // 1 -> LBEleRoomState_Idle
  0, // 2 -> LBEleRoomState_Fighting
  1, // 3 -> LBEleRoomState_Finish
};

const std::string& LBEleRoomState_Name(
    LBEleRoomState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          LBEleRoomState_entries,
          LBEleRoomState_entries_by_number,
          3, LBEleRoomState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      LBEleRoomState_entries,
      LBEleRoomState_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     LBEleRoomState_strings[idx].get();
}
bool LBEleRoomState_Parse(
    const std::string& name, LBEleRoomState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      LBEleRoomState_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<LBEleRoomState>(int_value);
  }
  return success;
}
bool GuildQAType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GuildQAType_strings[6] = {};

static const char GuildQAType_names[] =
  "AFTER_OPEN"
  "BEFORE_OPEN"
  "IN_TIME_NOT_OPEN"
  "IN_TIME_OPENING"
  "NOT_OPEN_DAY"
  "NO_GUILD";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GuildQAType_entries[] = {
  { {GuildQAType_names + 0, 10}, 4 },
  { {GuildQAType_names + 10, 11}, 1 },
  { {GuildQAType_names + 21, 16}, 2 },
  { {GuildQAType_names + 37, 15}, 3 },
  { {GuildQAType_names + 52, 12}, 5 },
  { {GuildQAType_names + 64, 8}, 0 },
};

static const int GuildQAType_entries_by_number[] = {
  5, // 0 -> NO_GUILD
  1, // 1 -> BEFORE_OPEN
  2, // 2 -> IN_TIME_NOT_OPEN
  3, // 3 -> IN_TIME_OPENING
  0, // 4 -> AFTER_OPEN
  4, // 5 -> NOT_OPEN_DAY
};

const std::string& GuildQAType_Name(
    GuildQAType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GuildQAType_entries,
          GuildQAType_entries_by_number,
          6, GuildQAType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GuildQAType_entries,
      GuildQAType_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GuildQAType_strings[idx].get();
}
bool GuildQAType_Parse(
    const std::string& name, GuildQAType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GuildQAType_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<GuildQAType>(int_value);
  }
  return success;
}
bool CommentType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CommentType_strings[6] = {};

static const char CommentType_names[] =
  "COMMENT_ATLAS"
  "COMMENT_DRAGON"
  "COMMENT_LADDER"
  "COMMENT_NEST"
  "COMMENT_PANDORA"
  "COMMENT_SPRITE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CommentType_entries[] = {
  { {CommentType_names + 0, 13}, 4 },
  { {CommentType_names + 13, 14}, 2 },
  { {CommentType_names + 27, 14}, 3 },
  { {CommentType_names + 41, 12}, 1 },
  { {CommentType_names + 53, 15}, 5 },
  { {CommentType_names + 68, 14}, 6 },
};

static const int CommentType_entries_by_number[] = {
  3, // 1 -> COMMENT_NEST
  1, // 2 -> COMMENT_DRAGON
  2, // 3 -> COMMENT_LADDER
  0, // 4 -> COMMENT_ATLAS
  4, // 5 -> COMMENT_PANDORA
  5, // 6 -> COMMENT_SPRITE
};

const std::string& CommentType_Name(
    CommentType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CommentType_entries,
          CommentType_entries_by_number,
          6, CommentType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CommentType_entries,
      CommentType_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CommentType_strings[idx].get();
}
bool CommentType_Parse(
    const std::string& name, CommentType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CommentType_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<CommentType>(int_value);
  }
  return success;
}
bool PersonalCarrerReqType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PersonalCarrerReqType_strings[3] = {};

static const char PersonalCarrerReqType_names[] =
  "PCRT_HOME_PAGE"
  "PCRT_PVP_PKINFO"
  "PCRT_TROPHY";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PersonalCarrerReqType_entries[] = {
  { {PersonalCarrerReqType_names + 0, 14}, 1 },
  { {PersonalCarrerReqType_names + 14, 15}, 2 },
  { {PersonalCarrerReqType_names + 29, 11}, 3 },
};

static const int PersonalCarrerReqType_entries_by_number[] = {
  0, // 1 -> PCRT_HOME_PAGE
  1, // 2 -> PCRT_PVP_PKINFO
  2, // 3 -> PCRT_TROPHY
};

const std::string& PersonalCarrerReqType_Name(
    PersonalCarrerReqType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PersonalCarrerReqType_entries,
          PersonalCarrerReqType_entries_by_number,
          3, PersonalCarrerReqType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PersonalCarrerReqType_entries,
      PersonalCarrerReqType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PersonalCarrerReqType_strings[idx].get();
}
bool PersonalCarrerReqType_Parse(
    const std::string& name, PersonalCarrerReqType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PersonalCarrerReqType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<PersonalCarrerReqType>(int_value);
  }
  return success;
}
bool CarrerDataType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CarrerDataType_strings[4] = {};

static const char CarrerDataType_names[] =
  "CARRER_DATA_CREATEROLE"
  "CARRER_DATA_DRAGON"
  "CARRER_DATA_LEVEL"
  "CARRER_DATA_NEST";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CarrerDataType_entries[] = {
  { {CarrerDataType_names + 0, 22}, 4 },
  { {CarrerDataType_names + 22, 18}, 3 },
  { {CarrerDataType_names + 40, 17}, 1 },
  { {CarrerDataType_names + 57, 16}, 2 },
};

static const int CarrerDataType_entries_by_number[] = {
  2, // 1 -> CARRER_DATA_LEVEL
  3, // 2 -> CARRER_DATA_NEST
  1, // 3 -> CARRER_DATA_DRAGON
  0, // 4 -> CARRER_DATA_CREATEROLE
};

const std::string& CarrerDataType_Name(
    CarrerDataType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CarrerDataType_entries,
          CarrerDataType_entries_by_number,
          4, CarrerDataType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CarrerDataType_entries,
      CarrerDataType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CarrerDataType_strings[idx].get();
}
bool CarrerDataType_Parse(
    const std::string& name, CarrerDataType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CarrerDataType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<CarrerDataType>(int_value);
  }
  return success;
}
bool MatchToWorldType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> MatchToWorldType_strings[3] = {};

static const char MatchToWorldType_names[] =
  "MTWT_ADD"
  "MTWT_DEL"
  "MTWT_MATCH_INWORLD";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry MatchToWorldType_entries[] = {
  { {MatchToWorldType_names + 0, 8}, 1 },
  { {MatchToWorldType_names + 8, 8}, 2 },
  { {MatchToWorldType_names + 16, 18}, 3 },
};

static const int MatchToWorldType_entries_by_number[] = {
  0, // 1 -> MTWT_ADD
  1, // 2 -> MTWT_DEL
  2, // 3 -> MTWT_MATCH_INWORLD
};

const std::string& MatchToWorldType_Name(
    MatchToWorldType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          MatchToWorldType_entries,
          MatchToWorldType_entries_by_number,
          3, MatchToWorldType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      MatchToWorldType_entries,
      MatchToWorldType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     MatchToWorldType_strings[idx].get();
}
bool MatchToWorldType_Parse(
    const std::string& name, MatchToWorldType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      MatchToWorldType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<MatchToWorldType>(int_value);
  }
  return success;
}
bool MentorTaskType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> MentorTaskType_strings[31] = {};

static const char MentorTaskType_names[] =
  "MentorTask_AllEquipQuality"
  "MentorTask_AllEquipStengthen"
  "MentorTask_AuctBuy"
  "MentorTask_AuctSale"
  "MentorTask_BossRush"
  "MentorTask_BuyFund"
  "MentorTask_BuyGift"
  "MentorTask_BuyPrivilege"
  "MentorTask_DailyActive"
  "MentorTask_DailyTask"
  "MentorTask_Emblem"
  "MentorTask_GuildAuctBenefit"
  "MentorTask_GuildBossCount"
  "MentorTask_GuildCheckIn"
  "MentorTask_GuildTianTiCount"
  "MentorTask_IBShopBuy"
  "MentorTask_Jade"
  "MentorTask_JoinGuild"
  "MentorTask_MentorIntimacy"
  "MentorTask_Pandora"
  "MentorTask_ProtectCaptain"
  "MentorTask_RiskStage"
  "MentorTask_SkyCount"
  "MentorTask_SkyFloor"
  "MentorTask_StageStar"
  "MentorTask_StageTypeCount"
  "MentorTask_TianTi"
  "MentorTask_Title"
  "MentorTask_TowerFloor"
  "MentorTask_WorldBossCount"
  "MentorTask_WorldBossRank";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry MentorTaskType_entries[] = {
  { {MentorTaskType_names + 0, 26}, 29 },
  { {MentorTaskType_names + 26, 28}, 22 },
  { {MentorTaskType_names + 54, 18}, 30 },
  { {MentorTaskType_names + 72, 19}, 31 },
  { {MentorTaskType_names + 91, 19}, 14 },
  { {MentorTaskType_names + 110, 18}, 27 },
  { {MentorTaskType_names + 128, 18}, 28 },
  { {MentorTaskType_names + 146, 23}, 26 },
  { {MentorTaskType_names + 169, 22}, 12 },
  { {MentorTaskType_names + 191, 20}, 20 },
  { {MentorTaskType_names + 211, 17}, 11 },
  { {MentorTaskType_names + 228, 27}, 7 },
  { {MentorTaskType_names + 255, 25}, 19 },
  { {MentorTaskType_names + 280, 23}, 6 },
  { {MentorTaskType_names + 303, 27}, 23 },
  { {MentorTaskType_names + 330, 20}, 25 },
  { {MentorTaskType_names + 350, 15}, 2 },
  { {MentorTaskType_names + 365, 20}, 1 },
  { {MentorTaskType_names + 385, 25}, 24 },
  { {MentorTaskType_names + 410, 18}, 4 },
  { {MentorTaskType_names + 428, 25}, 9 },
  { {MentorTaskType_names + 453, 20}, 8 },
  { {MentorTaskType_names + 473, 19}, 21 },
  { {MentorTaskType_names + 492, 19}, 16 },
  { {MentorTaskType_names + 511, 20}, 15 },
  { {MentorTaskType_names + 531, 25}, 5 },
  { {MentorTaskType_names + 556, 17}, 10 },
  { {MentorTaskType_names + 573, 16}, 3 },
  { {MentorTaskType_names + 589, 21}, 17 },
  { {MentorTaskType_names + 610, 25}, 13 },
  { {MentorTaskType_names + 635, 24}, 18 },
};

static const int MentorTaskType_entries_by_number[] = {
  17, // 1 -> MentorTask_JoinGuild
  16, // 2 -> MentorTask_Jade
  27, // 3 -> MentorTask_Title
  19, // 4 -> MentorTask_Pandora
  25, // 5 -> MentorTask_StageTypeCount
  13, // 6 -> MentorTask_GuildCheckIn
  11, // 7 -> MentorTask_GuildAuctBenefit
  21, // 8 -> MentorTask_RiskStage
  20, // 9 -> MentorTask_ProtectCaptain
  26, // 10 -> MentorTask_TianTi
  10, // 11 -> MentorTask_Emblem
  8, // 12 -> MentorTask_DailyActive
  29, // 13 -> MentorTask_WorldBossCount
  4, // 14 -> MentorTask_BossRush
  24, // 15 -> MentorTask_StageStar
  23, // 16 -> MentorTask_SkyFloor
  28, // 17 -> MentorTask_TowerFloor
  30, // 18 -> MentorTask_WorldBossRank
  12, // 19 -> MentorTask_GuildBossCount
  9, // 20 -> MentorTask_DailyTask
  22, // 21 -> MentorTask_SkyCount
  1, // 22 -> MentorTask_AllEquipStengthen
  14, // 23 -> MentorTask_GuildTianTiCount
  18, // 24 -> MentorTask_MentorIntimacy
  15, // 25 -> MentorTask_IBShopBuy
  7, // 26 -> MentorTask_BuyPrivilege
  5, // 27 -> MentorTask_BuyFund
  6, // 28 -> MentorTask_BuyGift
  0, // 29 -> MentorTask_AllEquipQuality
  2, // 30 -> MentorTask_AuctBuy
  3, // 31 -> MentorTask_AuctSale
};

const std::string& MentorTaskType_Name(
    MentorTaskType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          MentorTaskType_entries,
          MentorTaskType_entries_by_number,
          31, MentorTaskType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      MentorTaskType_entries,
      MentorTaskType_entries_by_number,
      31, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     MentorTaskType_strings[idx].get();
}
bool MentorTaskType_Parse(
    const std::string& name, MentorTaskType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      MentorTaskType_entries, 31, name, &int_value);
  if (success) {
    *value = static_cast<MentorTaskType>(int_value);
  }
  return success;
}
bool KKVsRoleState_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> KKVsRoleState_strings[4] = {};

static const char KKVsRoleState_names[] =
  "KK_VS_ROLE_DIE"
  "KK_VS_ROLE_NORMAL"
  "KK_VS_ROLE_QUIT"
  "KK_VS_ROLE_UNLOAD";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry KKVsRoleState_entries[] = {
  { {KKVsRoleState_names + 0, 14}, 3 },
  { {KKVsRoleState_names + 14, 17}, 2 },
  { {KKVsRoleState_names + 31, 15}, 4 },
  { {KKVsRoleState_names + 46, 17}, 1 },
};

static const int KKVsRoleState_entries_by_number[] = {
  3, // 1 -> KK_VS_ROLE_UNLOAD
  1, // 2 -> KK_VS_ROLE_NORMAL
  0, // 3 -> KK_VS_ROLE_DIE
  2, // 4 -> KK_VS_ROLE_QUIT
};

const std::string& KKVsRoleState_Name(
    KKVsRoleState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          KKVsRoleState_entries,
          KKVsRoleState_entries_by_number,
          4, KKVsRoleState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      KKVsRoleState_entries,
      KKVsRoleState_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     KKVsRoleState_strings[idx].get();
}
bool KKVsRoleState_Parse(
    const std::string& name, KKVsRoleState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      KKVsRoleState_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<KKVsRoleState>(int_value);
  }
  return success;
}
bool KMatchType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> KMatchType_strings[12] = {};

static const char KMatchType_names[] =
  "KMT_CUSTOM_PKTWO"
  "KMT_EXP"
  "KMT_HERO"
  "KMT_LEAGUE"
  "KMT_MOBA"
  "KMT_NONE"
  "KMT_PK"
  "KMT_PKTWO"
  "KMT_PVP"
  "KMT_SKYCRAFT"
  "KMT_SURVIVE"
  "KMT_WEEKEND_ACT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry KMatchType_entries[] = {
  { {KMatchType_names + 0, 16}, 10 },
  { {KMatchType_names + 16, 7}, 1 },
  { {KMatchType_names + 23, 8}, 3 },
  { {KMatchType_names + 31, 10}, 5 },
  { {KMatchType_names + 41, 8}, 8 },
  { {KMatchType_names + 49, 8}, 0 },
  { {KMatchType_names + 57, 6}, 4 },
  { {KMatchType_names + 63, 9}, 7 },
  { {KMatchType_names + 72, 7}, 2 },
  { {KMatchType_names + 79, 12}, 6 },
  { {KMatchType_names + 91, 11}, 11 },
  { {KMatchType_names + 102, 15}, 9 },
};

static const int KMatchType_entries_by_number[] = {
  5, // 0 -> KMT_NONE
  1, // 1 -> KMT_EXP
  8, // 2 -> KMT_PVP
  2, // 3 -> KMT_HERO
  6, // 4 -> KMT_PK
  3, // 5 -> KMT_LEAGUE
  9, // 6 -> KMT_SKYCRAFT
  7, // 7 -> KMT_PKTWO
  4, // 8 -> KMT_MOBA
  11, // 9 -> KMT_WEEKEND_ACT
  0, // 10 -> KMT_CUSTOM_PKTWO
  10, // 11 -> KMT_SURVIVE
};

const std::string& KMatchType_Name(
    KMatchType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          KMatchType_entries,
          KMatchType_entries_by_number,
          12, KMatchType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      KMatchType_entries,
      KMatchType_entries_by_number,
      12, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     KMatchType_strings[idx].get();
}
bool KMatchType_Parse(
    const std::string& name, KMatchType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      KMatchType_entries, 12, name, &int_value);
  if (success) {
    *value = static_cast<KMatchType>(int_value);
  }
  return success;
}
bool GiftIbItemState_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GiftIbItemState_strings[2] = {};

static const char GiftIbItemState_names[] =
  "GiftIbReply"
  "GiftIbWaitingReceipt";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GiftIbItemState_entries[] = {
  { {GiftIbItemState_names + 0, 11}, 2 },
  { {GiftIbItemState_names + 11, 20}, 1 },
};

static const int GiftIbItemState_entries_by_number[] = {
  1, // 1 -> GiftIbWaitingReceipt
  0, // 2 -> GiftIbReply
};

const std::string& GiftIbItemState_Name(
    GiftIbItemState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GiftIbItemState_entries,
          GiftIbItemState_entries_by_number,
          2, GiftIbItemState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GiftIbItemState_entries,
      GiftIbItemState_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GiftIbItemState_strings[idx].get();
}
bool GiftIbItemState_Parse(
    const std::string& name, GiftIbItemState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GiftIbItemState_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<GiftIbItemState>(int_value);
  }
  return success;
}
bool PayGiftIbStatus_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PayGiftIbStatus_strings[4] = {};

static const char PayGiftIbStatus_names[] =
  "PayGiftIbStatus_CreateBill"
  "PayGiftIbStatus_Fail"
  "PayGiftIbStatus_Success"
  "PayGiftIbStatus_SuccessNotAddItem";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PayGiftIbStatus_entries[] = {
  { {PayGiftIbStatus_names + 0, 26}, 1 },
  { {PayGiftIbStatus_names + 26, 20}, 2 },
  { {PayGiftIbStatus_names + 46, 23}, 3 },
  { {PayGiftIbStatus_names + 69, 33}, 4 },
};

static const int PayGiftIbStatus_entries_by_number[] = {
  0, // 1 -> PayGiftIbStatus_CreateBill
  1, // 2 -> PayGiftIbStatus_Fail
  2, // 3 -> PayGiftIbStatus_Success
  3, // 4 -> PayGiftIbStatus_SuccessNotAddItem
};

const std::string& PayGiftIbStatus_Name(
    PayGiftIbStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PayGiftIbStatus_entries,
          PayGiftIbStatus_entries_by_number,
          4, PayGiftIbStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PayGiftIbStatus_entries,
      PayGiftIbStatus_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PayGiftIbStatus_strings[idx].get();
}
bool PayGiftIbStatus_Parse(
    const std::string& name, PayGiftIbStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PayGiftIbStatus_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<PayGiftIbStatus>(int_value);
  }
  return success;
}
bool MysqlOpType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> MysqlOpType_strings[3] = {};

static const char MysqlOpType_names[] =
  "MYSQL_OP_ADD"
  "MYSQL_OP_DELETE"
  "MYSQL_OP_UPDATE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry MysqlOpType_entries[] = {
  { {MysqlOpType_names + 0, 12}, 1 },
  { {MysqlOpType_names + 12, 15}, 3 },
  { {MysqlOpType_names + 27, 15}, 2 },
};

static const int MysqlOpType_entries_by_number[] = {
  0, // 1 -> MYSQL_OP_ADD
  2, // 2 -> MYSQL_OP_UPDATE
  1, // 3 -> MYSQL_OP_DELETE
};

const std::string& MysqlOpType_Name(
    MysqlOpType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          MysqlOpType_entries,
          MysqlOpType_entries_by_number,
          3, MysqlOpType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      MysqlOpType_entries,
      MysqlOpType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     MysqlOpType_strings[idx].get();
}
bool MysqlOpType_Parse(
    const std::string& name, MysqlOpType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      MysqlOpType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<MysqlOpType>(int_value);
  }
  return success;
}
bool ArenaStarType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ArenaStarType_strings[4] = {};

static const char ArenaStarType_names[] =
  "AST_HEROBATTLE"
  "AST_LEAGUE"
  "AST_PK"
  "AST_WEEKNEST";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ArenaStarType_entries[] = {
  { {ArenaStarType_names + 0, 14}, 2 },
  { {ArenaStarType_names + 14, 10}, 4 },
  { {ArenaStarType_names + 24, 6}, 1 },
  { {ArenaStarType_names + 30, 12}, 3 },
};

static const int ArenaStarType_entries_by_number[] = {
  2, // 1 -> AST_PK
  0, // 2 -> AST_HEROBATTLE
  3, // 3 -> AST_WEEKNEST
  1, // 4 -> AST_LEAGUE
};

const std::string& ArenaStarType_Name(
    ArenaStarType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ArenaStarType_entries,
          ArenaStarType_entries_by_number,
          4, ArenaStarType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ArenaStarType_entries,
      ArenaStarType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ArenaStarType_strings[idx].get();
}
bool ArenaStarType_Parse(
    const std::string& name, ArenaStarType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ArenaStarType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<ArenaStarType>(int_value);
  }
  return success;
}
bool ArenaStarReqType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ArenaStarReqType_strings[2] = {};

static const char ArenaStarReqType_names[] =
  "ASRT_DIANZAN"
  "ASRT_ROLEDATA";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ArenaStarReqType_entries[] = {
  { {ArenaStarReqType_names + 0, 12}, 2 },
  { {ArenaStarReqType_names + 12, 13}, 1 },
};

static const int ArenaStarReqType_entries_by_number[] = {
  1, // 1 -> ASRT_ROLEDATA
  0, // 2 -> ASRT_DIANZAN
};

const std::string& ArenaStarReqType_Name(
    ArenaStarReqType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ArenaStarReqType_entries,
          ArenaStarReqType_entries_by_number,
          2, ArenaStarReqType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ArenaStarReqType_entries,
      ArenaStarReqType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ArenaStarReqType_strings[idx].get();
}
bool ArenaStarReqType_Parse(
    const std::string& name, ArenaStarReqType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ArenaStarReqType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<ArenaStarReqType>(int_value);
  }
  return success;
}
bool SkyTeamState_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SkyTeamState_strings[3] = {};

static const char SkyTeamState_names[] =
  "SkyTeamState_Battle"
  "SkyTeamState_Idle"
  "SkyTeamState_Match";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SkyTeamState_entries[] = {
  { {SkyTeamState_names + 0, 19}, 3 },
  { {SkyTeamState_names + 19, 17}, 1 },
  { {SkyTeamState_names + 36, 18}, 2 },
};

static const int SkyTeamState_entries_by_number[] = {
  1, // 1 -> SkyTeamState_Idle
  2, // 2 -> SkyTeamState_Match
  0, // 3 -> SkyTeamState_Battle
};

const std::string& SkyTeamState_Name(
    SkyTeamState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SkyTeamState_entries,
          SkyTeamState_entries_by_number,
          3, SkyTeamState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SkyTeamState_entries,
      SkyTeamState_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SkyTeamState_strings[idx].get();
}
bool SkyTeamState_Parse(
    const std::string& name, SkyTeamState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SkyTeamState_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<SkyTeamState>(int_value);
  }
  return success;
}
bool SkyCraftMatchReqTpe_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SkyCraftMatchReqTpe_strings[2] = {};

static const char SkyCraftMatchReqTpe_names[] =
  "SCMR_CancelMatch"
  "SCMR_Match";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SkyCraftMatchReqTpe_entries[] = {
  { {SkyCraftMatchReqTpe_names + 0, 16}, 2 },
  { {SkyCraftMatchReqTpe_names + 16, 10}, 1 },
};

static const int SkyCraftMatchReqTpe_entries_by_number[] = {
  1, // 1 -> SCMR_Match
  0, // 2 -> SCMR_CancelMatch
};

const std::string& SkyCraftMatchReqTpe_Name(
    SkyCraftMatchReqTpe value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SkyCraftMatchReqTpe_entries,
          SkyCraftMatchReqTpe_entries_by_number,
          2, SkyCraftMatchReqTpe_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SkyCraftMatchReqTpe_entries,
      SkyCraftMatchReqTpe_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SkyCraftMatchReqTpe_strings[idx].get();
}
bool SkyCraftMatchReqTpe_Parse(
    const std::string& name, SkyCraftMatchReqTpe* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SkyCraftMatchReqTpe_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<SkyCraftMatchReqTpe>(int_value);
  }
  return success;
}
bool SkyCraftMatchNtfType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SkyCraftMatchNtfType_strings[3] = {};

static const char SkyCraftMatchNtfType_names[] =
  "SCMN_Start"
  "SCMN_Stop"
  "SCMN_Timeout";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SkyCraftMatchNtfType_entries[] = {
  { {SkyCraftMatchNtfType_names + 0, 10}, 1 },
  { {SkyCraftMatchNtfType_names + 10, 9}, 2 },
  { {SkyCraftMatchNtfType_names + 19, 12}, 3 },
};

static const int SkyCraftMatchNtfType_entries_by_number[] = {
  0, // 1 -> SCMN_Start
  1, // 2 -> SCMN_Stop
  2, // 3 -> SCMN_Timeout
};

const std::string& SkyCraftMatchNtfType_Name(
    SkyCraftMatchNtfType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SkyCraftMatchNtfType_entries,
          SkyCraftMatchNtfType_entries_by_number,
          3, SkyCraftMatchNtfType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SkyCraftMatchNtfType_entries,
      SkyCraftMatchNtfType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SkyCraftMatchNtfType_strings[idx].get();
}
bool SkyCraftMatchNtfType_Parse(
    const std::string& name, SkyCraftMatchNtfType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SkyCraftMatchNtfType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<SkyCraftMatchNtfType>(int_value);
  }
  return success;
}
bool SkyCraftType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SkyCraftType_strings[2] = {};

static const char SkyCraftType_names[] =
  "SCT_Eliminate"
  "SCT_RacePoint";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SkyCraftType_entries[] = {
  { {SkyCraftType_names + 0, 13}, 2 },
  { {SkyCraftType_names + 13, 13}, 1 },
};

static const int SkyCraftType_entries_by_number[] = {
  1, // 1 -> SCT_RacePoint
  0, // 2 -> SCT_Eliminate
};

const std::string& SkyCraftType_Name(
    SkyCraftType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SkyCraftType_entries,
          SkyCraftType_entries_by_number,
          2, SkyCraftType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SkyCraftType_entries,
      SkyCraftType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SkyCraftType_strings[idx].get();
}
bool SkyCraftType_Parse(
    const std::string& name, SkyCraftType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SkyCraftType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<SkyCraftType>(int_value);
  }
  return success;
}
bool SCEliRoundType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SCEliRoundType_strings[4] = {};

static const char SCEliRoundType_names[] =
  "SCEliRound_2to1"
  "SCEliRound_4to2"
  "SCEliRound_8to4"
  "SCEliRound_None";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SCEliRoundType_entries[] = {
  { {SCEliRoundType_names + 0, 15}, 3 },
  { {SCEliRoundType_names + 15, 15}, 2 },
  { {SCEliRoundType_names + 30, 15}, 1 },
  { {SCEliRoundType_names + 45, 15}, 0 },
};

static const int SCEliRoundType_entries_by_number[] = {
  3, // 0 -> SCEliRound_None
  2, // 1 -> SCEliRound_8to4
  1, // 2 -> SCEliRound_4to2
  0, // 3 -> SCEliRound_2to1
};

const std::string& SCEliRoundType_Name(
    SCEliRoundType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SCEliRoundType_entries,
          SCEliRoundType_entries_by_number,
          4, SCEliRoundType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SCEliRoundType_entries,
      SCEliRoundType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SCEliRoundType_strings[idx].get();
}
bool SCEliRoundType_Parse(
    const std::string& name, SCEliRoundType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SCEliRoundType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<SCEliRoundType>(int_value);
  }
  return success;
}
bool TeamMemberType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TeamMemberType_strings[3] = {};

static const char TeamMemberType_names[] =
  "TMT_HELPER"
  "TMT_NORMAL"
  "TMT_USETICKET";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TeamMemberType_entries[] = {
  { {TeamMemberType_names + 0, 10}, 2 },
  { {TeamMemberType_names + 10, 10}, 1 },
  { {TeamMemberType_names + 20, 13}, 3 },
};

static const int TeamMemberType_entries_by_number[] = {
  1, // 1 -> TMT_NORMAL
  0, // 2 -> TMT_HELPER
  2, // 3 -> TMT_USETICKET
};

const std::string& TeamMemberType_Name(
    TeamMemberType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TeamMemberType_entries,
          TeamMemberType_entries_by_number,
          3, TeamMemberType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TeamMemberType_entries,
      TeamMemberType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TeamMemberType_strings[idx].get();
}
bool TeamMemberType_Parse(
    const std::string& name, TeamMemberType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TeamMemberType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<TeamMemberType>(int_value);
  }
  return success;
}
bool WeekReportDataType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> WeekReportDataType_strings[6] = {};

static const char WeekReportDataType_names[] =
  "WeekReportData_GuildArena"
  "WeekReportData_GuildBoss"
  "WeekReportData_GuildRisk"
  "WeekReportData_GuildSign"
  "WeekReportData_GuildTerryitory"
  "WeekReportData_WorldBoss";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry WeekReportDataType_entries[] = {
  { {WeekReportDataType_names + 0, 25}, 4 },
  { {WeekReportDataType_names + 25, 24}, 5 },
  { {WeekReportDataType_names + 49, 24}, 3 },
  { {WeekReportDataType_names + 73, 24}, 1 },
  { {WeekReportDataType_names + 97, 30}, 6 },
  { {WeekReportDataType_names + 127, 24}, 2 },
};

static const int WeekReportDataType_entries_by_number[] = {
  3, // 1 -> WeekReportData_GuildSign
  5, // 2 -> WeekReportData_WorldBoss
  2, // 3 -> WeekReportData_GuildRisk
  0, // 4 -> WeekReportData_GuildArena
  1, // 5 -> WeekReportData_GuildBoss
  4, // 6 -> WeekReportData_GuildTerryitory
};

const std::string& WeekReportDataType_Name(
    WeekReportDataType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          WeekReportDataType_entries,
          WeekReportDataType_entries_by_number,
          6, WeekReportDataType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      WeekReportDataType_entries,
      WeekReportDataType_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     WeekReportDataType_strings[idx].get();
}
bool WeekReportDataType_Parse(
    const std::string& name, WeekReportDataType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      WeekReportDataType_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<WeekReportDataType>(int_value);
  }
  return success;
}
bool LeagueEliType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LeagueEliType_strings[3] = {};

static const char LeagueEliType_names[] =
  "LeagueEliType_Cross"
  "LeagueEliType_None"
  "LeagueEliType_Self";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LeagueEliType_entries[] = {
  { {LeagueEliType_names + 0, 19}, 3 },
  { {LeagueEliType_names + 19, 18}, 1 },
  { {LeagueEliType_names + 37, 18}, 2 },
};

static const int LeagueEliType_entries_by_number[] = {
  1, // 1 -> LeagueEliType_None
  2, // 2 -> LeagueEliType_Self
  0, // 3 -> LeagueEliType_Cross
};

const std::string& LeagueEliType_Name(
    LeagueEliType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          LeagueEliType_entries,
          LeagueEliType_entries_by_number,
          3, LeagueEliType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      LeagueEliType_entries,
      LeagueEliType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     LeagueEliType_strings[idx].get();
}
bool LeagueEliType_Parse(
    const std::string& name, LeagueEliType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      LeagueEliType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<LeagueEliType>(int_value);
  }
  return success;
}
bool QueryResWarEnum_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> QueryResWarEnum_strings[2] = {};

static const char QueryResWarEnum_names[] =
  "RESWAR_BATTLE"
  "RESWAR_FLOWAWARD";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry QueryResWarEnum_entries[] = {
  { {QueryResWarEnum_names + 0, 13}, 2 },
  { {QueryResWarEnum_names + 13, 16}, 1 },
};

static const int QueryResWarEnum_entries_by_number[] = {
  1, // 1 -> RESWAR_FLOWAWARD
  0, // 2 -> RESWAR_BATTLE
};

const std::string& QueryResWarEnum_Name(
    QueryResWarEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          QueryResWarEnum_entries,
          QueryResWarEnum_entries_by_number,
          2, QueryResWarEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      QueryResWarEnum_entries,
      QueryResWarEnum_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     QueryResWarEnum_strings[idx].get();
}
bool QueryResWarEnum_Parse(
    const std::string& name, QueryResWarEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      QueryResWarEnum_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<QueryResWarEnum>(int_value);
  }
  return success;
}
bool CustomBattleOp_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CustomBattleOp_strings[18] = {};

static const char CustomBattleOp_names[] =
  "CustomBattle_ClearCD"
  "CustomBattle_Create"
  "CustomBattle_DoClearCD"
  "CustomBattle_DoCreate"
  "CustomBattle_DoJoin"
  "CustomBattle_Drop"
  "CustomBattle_Join"
  "CustomBattle_Match"
  "CustomBattle_Modify"
  "CustomBattle_Query"
  "CustomBattle_QueryOne"
  "CustomBattle_QueryRandom"
  "CustomBattle_QuerySelf"
  "CustomBattle_Reward"
  "CustomBattle_Search"
  "CustomBattle_StartNow"
  "CustomBattle_UnJoin"
  "CustomBattle_UnMatch";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CustomBattleOp_entries[] = {
  { {CustomBattleOp_names + 0, 20}, 6 },
  { {CustomBattleOp_names + 20, 19}, 2 },
  { {CustomBattleOp_names + 39, 22}, 16 },
  { {CustomBattleOp_names + 61, 21}, 9 },
  { {CustomBattleOp_names + 82, 19}, 10 },
  { {CustomBattleOp_names + 101, 17}, 17 },
  { {CustomBattleOp_names + 118, 17}, 3 },
  { {CustomBattleOp_names + 135, 18}, 4 },
  { {CustomBattleOp_names + 153, 19}, 13 },
  { {CustomBattleOp_names + 172, 18}, 1 },
  { {CustomBattleOp_names + 190, 21}, 8 },
  { {CustomBattleOp_names + 211, 24}, 7 },
  { {CustomBattleOp_names + 235, 22}, 14 },
  { {CustomBattleOp_names + 257, 19}, 5 },
  { {CustomBattleOp_names + 276, 19}, 18 },
  { {CustomBattleOp_names + 295, 21}, 15 },
  { {CustomBattleOp_names + 316, 19}, 11 },
  { {CustomBattleOp_names + 335, 20}, 12 },
};

static const int CustomBattleOp_entries_by_number[] = {
  9, // 1 -> CustomBattle_Query
  1, // 2 -> CustomBattle_Create
  6, // 3 -> CustomBattle_Join
  7, // 4 -> CustomBattle_Match
  13, // 5 -> CustomBattle_Reward
  0, // 6 -> CustomBattle_ClearCD
  11, // 7 -> CustomBattle_QueryRandom
  10, // 8 -> CustomBattle_QueryOne
  3, // 9 -> CustomBattle_DoCreate
  4, // 10 -> CustomBattle_DoJoin
  16, // 11 -> CustomBattle_UnJoin
  17, // 12 -> CustomBattle_UnMatch
  8, // 13 -> CustomBattle_Modify
  12, // 14 -> CustomBattle_QuerySelf
  15, // 15 -> CustomBattle_StartNow
  2, // 16 -> CustomBattle_DoClearCD
  5, // 17 -> CustomBattle_Drop
  14, // 18 -> CustomBattle_Search
};

const std::string& CustomBattleOp_Name(
    CustomBattleOp value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CustomBattleOp_entries,
          CustomBattleOp_entries_by_number,
          18, CustomBattleOp_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CustomBattleOp_entries,
      CustomBattleOp_entries_by_number,
      18, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CustomBattleOp_strings[idx].get();
}
bool CustomBattleOp_Parse(
    const std::string& name, CustomBattleOp* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CustomBattleOp_entries, 18, name, &int_value);
  if (success) {
    *value = static_cast<CustomBattleOp>(int_value);
  }
  return success;
}
bool CustomBattleScale_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CustomBattleScale_strings[4] = {};

static const char CustomBattleScale_names[] =
  "CustomBattle_Scale_All"
  "CustomBattle_Scale_Friend"
  "CustomBattle_Scale_Guild"
  "CustomBattle_Scale_Server";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CustomBattleScale_entries[] = {
  { {CustomBattleScale_names + 0, 22}, 4 },
  { {CustomBattleScale_names + 22, 25}, 1 },
  { {CustomBattleScale_names + 47, 24}, 2 },
  { {CustomBattleScale_names + 71, 25}, 3 },
};

static const int CustomBattleScale_entries_by_number[] = {
  1, // 1 -> CustomBattle_Scale_Friend
  2, // 2 -> CustomBattle_Scale_Guild
  3, // 3 -> CustomBattle_Scale_Server
  0, // 4 -> CustomBattle_Scale_All
};

const std::string& CustomBattleScale_Name(
    CustomBattleScale value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CustomBattleScale_entries,
          CustomBattleScale_entries_by_number,
          4, CustomBattleScale_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CustomBattleScale_entries,
      CustomBattleScale_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CustomBattleScale_strings[idx].get();
}
bool CustomBattleScale_Parse(
    const std::string& name, CustomBattleScale* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CustomBattleScale_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<CustomBattleScale>(int_value);
  }
  return success;
}
bool CustomBattleType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CustomBattleType_strings[2] = {};

static const char CustomBattleType_names[] =
  "CustomBattle_PKTwo_Normal"
  "CustomBattle_PK_Normal";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CustomBattleType_entries[] = {
  { {CustomBattleType_names + 0, 25}, 2 },
  { {CustomBattleType_names + 25, 22}, 1 },
};

static const int CustomBattleType_entries_by_number[] = {
  1, // 1 -> CustomBattle_PK_Normal
  0, // 2 -> CustomBattle_PKTwo_Normal
};

const std::string& CustomBattleType_Name(
    CustomBattleType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CustomBattleType_entries,
          CustomBattleType_entries_by_number,
          2, CustomBattleType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CustomBattleType_entries,
      CustomBattleType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CustomBattleType_strings[idx].get();
}
bool CustomBattleType_Parse(
    const std::string& name, CustomBattleType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CustomBattleType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<CustomBattleType>(int_value);
  }
  return success;
}
bool CustomBattleState_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CustomBattleState_strings[4] = {};

static const char CustomBattleState_names[] =
  "CustomBattle_Destory"
  "CustomBattle_End"
  "CustomBattle_Going"
  "CustomBattle_Ready";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CustomBattleState_entries[] = {
  { {CustomBattleState_names + 0, 20}, 4 },
  { {CustomBattleState_names + 20, 16}, 3 },
  { {CustomBattleState_names + 36, 18}, 2 },
  { {CustomBattleState_names + 54, 18}, 1 },
};

static const int CustomBattleState_entries_by_number[] = {
  3, // 1 -> CustomBattle_Ready
  2, // 2 -> CustomBattle_Going
  1, // 3 -> CustomBattle_End
  0, // 4 -> CustomBattle_Destory
};

const std::string& CustomBattleState_Name(
    CustomBattleState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CustomBattleState_entries,
          CustomBattleState_entries_by_number,
          4, CustomBattleState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CustomBattleState_entries,
      CustomBattleState_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CustomBattleState_strings[idx].get();
}
bool CustomBattleState_Parse(
    const std::string& name, CustomBattleState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CustomBattleState_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<CustomBattleState>(int_value);
  }
  return success;
}
bool CustomBattleRoleState_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CustomBattleRoleState_strings[4] = {};

static const char CustomBattleRoleState_names[] =
  "CustomBattle_RoleState_Join"
  "CustomBattle_RoleState_Ready"
  "CustomBattle_RoleState_Reward"
  "Custombattle_RoleState_Taken";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CustomBattleRoleState_entries[] = {
  { {CustomBattleRoleState_names + 0, 27}, 2 },
  { {CustomBattleRoleState_names + 27, 28}, 1 },
  { {CustomBattleRoleState_names + 55, 29}, 3 },
  { {CustomBattleRoleState_names + 84, 28}, 4 },
};

static const int CustomBattleRoleState_entries_by_number[] = {
  1, // 1 -> CustomBattle_RoleState_Ready
  0, // 2 -> CustomBattle_RoleState_Join
  2, // 3 -> CustomBattle_RoleState_Reward
  3, // 4 -> Custombattle_RoleState_Taken
};

const std::string& CustomBattleRoleState_Name(
    CustomBattleRoleState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CustomBattleRoleState_entries,
          CustomBattleRoleState_entries_by_number,
          4, CustomBattleRoleState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CustomBattleRoleState_entries,
      CustomBattleRoleState_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CustomBattleRoleState_strings[idx].get();
}
bool CustomBattleRoleState_Parse(
    const std::string& name, CustomBattleRoleState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CustomBattleRoleState_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<CustomBattleRoleState>(int_value);
  }
  return success;
}
bool SaveHistIbGiftEnum_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SaveHistIbGiftEnum_strings[3] = {};

static const char SaveHistIbGiftEnum_names[] =
  "SaveIbGift_All"
  "SaveIbGift_Self"
  "SaveIbGift_Target";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SaveHistIbGiftEnum_entries[] = {
  { {SaveHistIbGiftEnum_names + 0, 14}, 1 },
  { {SaveHistIbGiftEnum_names + 14, 15}, 2 },
  { {SaveHistIbGiftEnum_names + 29, 17}, 3 },
};

static const int SaveHistIbGiftEnum_entries_by_number[] = {
  0, // 1 -> SaveIbGift_All
  1, // 2 -> SaveIbGift_Self
  2, // 3 -> SaveIbGift_Target
};

const std::string& SaveHistIbGiftEnum_Name(
    SaveHistIbGiftEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SaveHistIbGiftEnum_entries,
          SaveHistIbGiftEnum_entries_by_number,
          3, SaveHistIbGiftEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SaveHistIbGiftEnum_entries,
      SaveHistIbGiftEnum_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SaveHistIbGiftEnum_strings[idx].get();
}
bool SaveHistIbGiftEnum_Parse(
    const std::string& name, SaveHistIbGiftEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SaveHistIbGiftEnum_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<SaveHistIbGiftEnum>(int_value);
  }
  return success;
}
bool GuildCampItemOperate_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GuildCampItemOperate_strings[6] = {};

static const char GuildCampItemOperate_names[] =
  "AUDIOCHAT"
  "CANCEL"
  "CONFIRM"
  "SWINGDOWNITEM"
  "SWINGUPITEM"
  "TEXTCHAT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GuildCampItemOperate_entries[] = {
  { {GuildCampItemOperate_names + 0, 9}, 5 },
  { {GuildCampItemOperate_names + 9, 6}, 3 },
  { {GuildCampItemOperate_names + 15, 7}, 4 },
  { {GuildCampItemOperate_names + 22, 13}, 2 },
  { {GuildCampItemOperate_names + 35, 11}, 1 },
  { {GuildCampItemOperate_names + 46, 8}, 6 },
};

static const int GuildCampItemOperate_entries_by_number[] = {
  4, // 1 -> SWINGUPITEM
  3, // 2 -> SWINGDOWNITEM
  1, // 3 -> CANCEL
  2, // 4 -> CONFIRM
  0, // 5 -> AUDIOCHAT
  5, // 6 -> TEXTCHAT
};

const std::string& GuildCampItemOperate_Name(
    GuildCampItemOperate value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GuildCampItemOperate_entries,
          GuildCampItemOperate_entries_by_number,
          6, GuildCampItemOperate_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GuildCampItemOperate_entries,
      GuildCampItemOperate_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GuildCampItemOperate_strings[idx].get();
}
bool GuildCampItemOperate_Parse(
    const std::string& name, GuildCampItemOperate* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GuildCampItemOperate_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<GuildCampItemOperate>(int_value);
  }
  return success;
}
bool GuildCampPartyTradeType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GuildCampPartyTradeType_strings[2] = {};

static const char GuildCampPartyTradeType_names[] =
  "TRADE_INVITATION"
  "UPDATA_TRADE_STATUS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GuildCampPartyTradeType_entries[] = {
  { {GuildCampPartyTradeType_names + 0, 16}, 1 },
  { {GuildCampPartyTradeType_names + 16, 19}, 2 },
};

static const int GuildCampPartyTradeType_entries_by_number[] = {
  0, // 1 -> TRADE_INVITATION
  1, // 2 -> UPDATA_TRADE_STATUS
};

const std::string& GuildCampPartyTradeType_Name(
    GuildCampPartyTradeType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GuildCampPartyTradeType_entries,
          GuildCampPartyTradeType_entries_by_number,
          2, GuildCampPartyTradeType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GuildCampPartyTradeType_entries,
      GuildCampPartyTradeType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GuildCampPartyTradeType_strings[idx].get();
}
bool GuildCampPartyTradeType_Parse(
    const std::string& name, GuildCampPartyTradeType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GuildCampPartyTradeType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<GuildCampPartyTradeType>(int_value);
  }
  return success;
}
bool GiftIbShipStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GiftIbShipStatus_strings[3] = {};

static const char GiftIbShipStatus_names[] =
  "GIFTIB_BEING_SHIPPED"
  "GIFTIB_FINISH_SHIPPED"
  "GIFTIB_NOT_SHIPPED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GiftIbShipStatus_entries[] = {
  { {GiftIbShipStatus_names + 0, 20}, 1 },
  { {GiftIbShipStatus_names + 20, 21}, 2 },
  { {GiftIbShipStatus_names + 41, 18}, 0 },
};

static const int GiftIbShipStatus_entries_by_number[] = {
  2, // 0 -> GIFTIB_NOT_SHIPPED
  0, // 1 -> GIFTIB_BEING_SHIPPED
  1, // 2 -> GIFTIB_FINISH_SHIPPED
};

const std::string& GiftIbShipStatus_Name(
    GiftIbShipStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GiftIbShipStatus_entries,
          GiftIbShipStatus_entries_by_number,
          3, GiftIbShipStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GiftIbShipStatus_entries,
      GiftIbShipStatus_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GiftIbShipStatus_strings[idx].get();
}
bool GiftIbShipStatus_Parse(
    const std::string& name, GiftIbShipStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GiftIbShipStatus_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<GiftIbShipStatus>(int_value);
  }
  return success;
}
bool EmblemSlotType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> EmblemSlotType_strings[4] = {};

static const char EmblemSlotType_names[] =
  "EmblemSlotType_Attri"
  "EmblemSlotType_ExtraSkill"
  "EmblemSlotType_None"
  "EmblemSlotType_Skill";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry EmblemSlotType_entries[] = {
  { {EmblemSlotType_names + 0, 20}, 1 },
  { {EmblemSlotType_names + 20, 25}, 3 },
  { {EmblemSlotType_names + 45, 19}, 0 },
  { {EmblemSlotType_names + 64, 20}, 2 },
};

static const int EmblemSlotType_entries_by_number[] = {
  2, // 0 -> EmblemSlotType_None
  0, // 1 -> EmblemSlotType_Attri
  3, // 2 -> EmblemSlotType_Skill
  1, // 3 -> EmblemSlotType_ExtraSkill
};

const std::string& EmblemSlotType_Name(
    EmblemSlotType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          EmblemSlotType_entries,
          EmblemSlotType_entries_by_number,
          4, EmblemSlotType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      EmblemSlotType_entries,
      EmblemSlotType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     EmblemSlotType_strings[idx].get();
}
bool EmblemSlotType_Parse(
    const std::string& name, EmblemSlotType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      EmblemSlotType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<EmblemSlotType>(int_value);
  }
  return success;
}
bool KMatchOp_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> KMatchOp_strings[2] = {};

static const char KMatchOp_names[] =
  "KMATCH_OP_START"
  "KMATCH_OP_STOP";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry KMatchOp_entries[] = {
  { {KMatchOp_names + 0, 15}, 1 },
  { {KMatchOp_names + 15, 14}, 2 },
};

static const int KMatchOp_entries_by_number[] = {
  0, // 1 -> KMATCH_OP_START
  1, // 2 -> KMATCH_OP_STOP
};

const std::string& KMatchOp_Name(
    KMatchOp value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          KMatchOp_entries,
          KMatchOp_entries_by_number,
          2, KMatchOp_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      KMatchOp_entries,
      KMatchOp_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     KMatchOp_strings[idx].get();
}
bool KMatchOp_Parse(
    const std::string& name, KMatchOp* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      KMatchOp_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<KMatchOp>(int_value);
  }
  return success;
}
bool BagType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> BagType_strings[4] = {};

static const char BagType_names[] =
  "ArtifactBag"
  "EmblemBag"
  "EquipBag"
  "ItemBag";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry BagType_entries[] = {
  { {BagType_names + 0, 11}, 3 },
  { {BagType_names + 11, 9}, 2 },
  { {BagType_names + 20, 8}, 1 },
  { {BagType_names + 28, 7}, 4 },
};

static const int BagType_entries_by_number[] = {
  2, // 1 -> EquipBag
  1, // 2 -> EmblemBag
  0, // 3 -> ArtifactBag
  3, // 4 -> ItemBag
};

const std::string& BagType_Name(
    BagType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          BagType_entries,
          BagType_entries_by_number,
          4, BagType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      BagType_entries,
      BagType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     BagType_strings[idx].get();
}
bool BagType_Parse(
    const std::string& name, BagType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      BagType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<BagType>(int_value);
  }
  return success;
}
bool CustomBattleTag_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CustomBattleTag_strings[4] = {};

static const char CustomBattleTag_names[] =
  "CustomBattle_Tag_Cross"
  "CustomBattle_Tag_Friend"
  "CustomBattle_Tag_GM"
  "CustomBattle_Tag_Guild";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CustomBattleTag_entries[] = {
  { {CustomBattleTag_names + 0, 22}, 3 },
  { {CustomBattleTag_names + 22, 23}, 1 },
  { {CustomBattleTag_names + 45, 19}, 4 },
  { {CustomBattleTag_names + 64, 22}, 2 },
};

static const int CustomBattleTag_entries_by_number[] = {
  1, // 1 -> CustomBattle_Tag_Friend
  3, // 2 -> CustomBattle_Tag_Guild
  0, // 3 -> CustomBattle_Tag_Cross
  2, // 4 -> CustomBattle_Tag_GM
};

const std::string& CustomBattleTag_Name(
    CustomBattleTag value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CustomBattleTag_entries,
          CustomBattleTag_entries_by_number,
          4, CustomBattleTag_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CustomBattleTag_entries,
      CustomBattleTag_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CustomBattleTag_strings[idx].get();
}
bool CustomBattleTag_Parse(
    const std::string& name, CustomBattleTag* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CustomBattleTag_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<CustomBattleTag>(int_value);
  }
  return success;
}
bool PkNVNType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PkNVNType_strings[2] = {};

static const char PkNVNType_names[] =
  "PK_1v1"
  "PK_2v2";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PkNVNType_entries[] = {
  { {PkNVNType_names + 0, 6}, 1 },
  { {PkNVNType_names + 6, 6}, 2 },
};

static const int PkNVNType_entries_by_number[] = {
  0, // 1 -> PK_1v1
  1, // 2 -> PK_2v2
};

const std::string& PkNVNType_Name(
    PkNVNType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PkNVNType_entries,
          PkNVNType_entries_by_number,
          2, PkNVNType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PkNVNType_entries,
      PkNVNType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PkNVNType_strings[idx].get();
}
bool PkNVNType_Parse(
    const std::string& name, PkNVNType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PkNVNType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<PkNVNType>(int_value);
  }
  return success;
}
bool ForgeOpType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ForgeOpType_strings[3] = {};

static const char ForgeOpType_names[] =
  "Forge_Equip"
  "Forge_Replace"
  "Forge_Retain";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ForgeOpType_entries[] = {
  { {ForgeOpType_names + 0, 11}, 1 },
  { {ForgeOpType_names + 11, 13}, 2 },
  { {ForgeOpType_names + 24, 12}, 3 },
};

static const int ForgeOpType_entries_by_number[] = {
  0, // 1 -> Forge_Equip
  1, // 2 -> Forge_Replace
  2, // 3 -> Forge_Retain
};

const std::string& ForgeOpType_Name(
    ForgeOpType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ForgeOpType_entries,
          ForgeOpType_entries_by_number,
          3, ForgeOpType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ForgeOpType_entries,
      ForgeOpType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ForgeOpType_strings[idx].get();
}
bool ForgeOpType_Parse(
    const std::string& name, ForgeOpType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ForgeOpType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<ForgeOpType>(int_value);
  }
  return success;
}
bool HeroKillUnitType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> HeroKillUnitType_strings[2] = {};

static const char HeroKillUnitType_names[] =
  "HeroKillUnit_Enemy"
  "HeroKillUnit_Hero";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry HeroKillUnitType_entries[] = {
  { {HeroKillUnitType_names + 0, 18}, 2 },
  { {HeroKillUnitType_names + 18, 17}, 1 },
};

static const int HeroKillUnitType_entries_by_number[] = {
  1, // 1 -> HeroKillUnit_Hero
  0, // 2 -> HeroKillUnit_Enemy
};

const std::string& HeroKillUnitType_Name(
    HeroKillUnitType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          HeroKillUnitType_entries,
          HeroKillUnitType_entries_by_number,
          2, HeroKillUnitType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      HeroKillUnitType_entries,
      HeroKillUnitType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     HeroKillUnitType_strings[idx].get();
}
bool HeroKillUnitType_Parse(
    const std::string& name, HeroKillUnitType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      HeroKillUnitType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<HeroKillUnitType>(int_value);
  }
  return success;
}
bool MobaOp_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> MobaOp_strings[2] = {};

static const char MobaOp_names[] =
  "MobaOp_LevelSkill"
  "MobaOp_Upgrade";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry MobaOp_entries[] = {
  { {MobaOp_names + 0, 17}, 1 },
  { {MobaOp_names + 17, 14}, 2 },
};

static const int MobaOp_entries_by_number[] = {
  0, // 1 -> MobaOp_LevelSkill
  1, // 2 -> MobaOp_Upgrade
};

const std::string& MobaOp_Name(
    MobaOp value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          MobaOp_entries,
          MobaOp_entries_by_number,
          2, MobaOp_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      MobaOp_entries,
      MobaOp_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     MobaOp_strings[idx].get();
}
bool MobaOp_Parse(
    const std::string& name, MobaOp* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      MobaOp_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<MobaOp>(int_value);
  }
  return success;
}
bool DHRState_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DHRState_strings[3] = {};

static const char DHRState_names[] =
  "DHR_CANNOT"
  "DHR_CAN_HAVE"
  "DHR_CAN_HAVEHOT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DHRState_entries[] = {
  { {DHRState_names + 0, 10}, 1 },
  { {DHRState_names + 10, 12}, 3 },
  { {DHRState_names + 22, 15}, 2 },
};

static const int DHRState_entries_by_number[] = {
  0, // 1 -> DHR_CANNOT
  2, // 2 -> DHR_CAN_HAVEHOT
  1, // 3 -> DHR_CAN_HAVE
};

const std::string& DHRState_Name(
    DHRState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DHRState_entries,
          DHRState_entries_by_number,
          3, DHRState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DHRState_entries,
      DHRState_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DHRState_strings[idx].get();
}
bool DHRState_Parse(
    const std::string& name, DHRState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DHRState_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<DHRState>(int_value);
  }
  return success;
}
bool DHRReqOp_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DHRReqOp_strings[4] = {};

static const char DHRReqOp_names[] =
  "DHR_OP_FETCH_REWARD"
  "DHR_OP_LIST"
  "DHR_OP_WANT_BE_HELP"
  "DHR_OP_WANT_NOT_HELP";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DHRReqOp_entries[] = {
  { {DHRReqOp_names + 0, 19}, 2 },
  { {DHRReqOp_names + 19, 11}, 1 },
  { {DHRReqOp_names + 30, 19}, 3 },
  { {DHRReqOp_names + 49, 20}, 4 },
};

static const int DHRReqOp_entries_by_number[] = {
  1, // 1 -> DHR_OP_LIST
  0, // 2 -> DHR_OP_FETCH_REWARD
  2, // 3 -> DHR_OP_WANT_BE_HELP
  3, // 4 -> DHR_OP_WANT_NOT_HELP
};

const std::string& DHRReqOp_Name(
    DHRReqOp value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DHRReqOp_entries,
          DHRReqOp_entries_by_number,
          4, DHRReqOp_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DHRReqOp_entries,
      DHRReqOp_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DHRReqOp_strings[idx].get();
}
bool DHRReqOp_Parse(
    const std::string& name, DHRReqOp* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DHRReqOp_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<DHRReqOp>(int_value);
  }
  return success;
}
bool PetOtherOp_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PetOtherOp_strings[3] = {};

static const char PetOtherOp_names[] =
  "AgreePetPairRide"
  "DoPetPairRide"
  "InvitePetPairRide";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PetOtherOp_entries[] = {
  { {PetOtherOp_names + 0, 16}, 3 },
  { {PetOtherOp_names + 16, 13}, 1 },
  { {PetOtherOp_names + 29, 17}, 2 },
};

static const int PetOtherOp_entries_by_number[] = {
  1, // 1 -> DoPetPairRide
  2, // 2 -> InvitePetPairRide
  0, // 3 -> AgreePetPairRide
};

const std::string& PetOtherOp_Name(
    PetOtherOp value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PetOtherOp_entries,
          PetOtherOp_entries_by_number,
          3, PetOtherOp_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PetOtherOp_entries,
      PetOtherOp_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PetOtherOp_strings[idx].get();
}
bool PetOtherOp_Parse(
    const std::string& name, PetOtherOp* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PetOtherOp_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<PetOtherOp>(int_value);
  }
  return success;
}
bool ArtifactComposeType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ArtifactComposeType_strings[2] = {};

static const char ArtifactComposeType_names[] =
  "ArtifactCompose_Multi"
  "ArtifactCompose_Single";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ArtifactComposeType_entries[] = {
  { {ArtifactComposeType_names + 0, 21}, 2 },
  { {ArtifactComposeType_names + 21, 22}, 1 },
};

static const int ArtifactComposeType_entries_by_number[] = {
  1, // 1 -> ArtifactCompose_Single
  0, // 2 -> ArtifactCompose_Multi
};

const std::string& ArtifactComposeType_Name(
    ArtifactComposeType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ArtifactComposeType_entries,
          ArtifactComposeType_entries_by_number,
          2, ArtifactComposeType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ArtifactComposeType_entries,
      ArtifactComposeType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ArtifactComposeType_strings[idx].get();
}
bool ArtifactComposeType_Parse(
    const std::string& name, ArtifactComposeType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ArtifactComposeType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<ArtifactComposeType>(int_value);
  }
  return success;
}
bool WeddingState_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> WeddingState_strings[2] = {};

static const char WeddingState_names[] =
  "WeddingState_Prepare"
  "WeddingState_Running";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry WeddingState_entries[] = {
  { {WeddingState_names + 0, 20}, 1 },
  { {WeddingState_names + 20, 20}, 2 },
};

static const int WeddingState_entries_by_number[] = {
  0, // 1 -> WeddingState_Prepare
  1, // 2 -> WeddingState_Running
};

const std::string& WeddingState_Name(
    WeddingState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          WeddingState_entries,
          WeddingState_entries_by_number,
          2, WeddingState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      WeddingState_entries,
      WeddingState_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     WeddingState_strings[idx].get();
}
bool WeddingState_Parse(
    const std::string& name, WeddingState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      WeddingState_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<WeddingState>(int_value);
  }
  return success;
}
bool WeddingType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> WeddingType_strings[2] = {};

static const char WeddingType_names[] =
  "WeddingType_Luxury"
  "WeddingType_Normal";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry WeddingType_entries[] = {
  { {WeddingType_names + 0, 18}, 2 },
  { {WeddingType_names + 18, 18}, 1 },
};

static const int WeddingType_entries_by_number[] = {
  1, // 1 -> WeddingType_Normal
  0, // 2 -> WeddingType_Luxury
};

const std::string& WeddingType_Name(
    WeddingType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          WeddingType_entries,
          WeddingType_entries_by_number,
          2, WeddingType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      WeddingType_entries,
      WeddingType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     WeddingType_strings[idx].get();
}
bool WeddingType_Parse(
    const std::string& name, WeddingType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      WeddingType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<WeddingType>(int_value);
  }
  return success;
}
bool MarriageOpType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> MarriageOpType_strings[6] = {};

static const char MarriageOpType_names[] =
  "MarriageOpType_Divorce"
  "MarriageOpType_DivorceCancel"
  "MarriageOpType_MarryAgree"
  "MarriageOpType_MarryApply"
  "MarriageOpType_MarryRefuse"
  "MarriageOpType_Max";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry MarriageOpType_entries[] = {
  { {MarriageOpType_names + 0, 22}, 4 },
  { {MarriageOpType_names + 22, 28}, 5 },
  { {MarriageOpType_names + 50, 25}, 2 },
  { {MarriageOpType_names + 75, 25}, 1 },
  { {MarriageOpType_names + 100, 26}, 3 },
  { {MarriageOpType_names + 126, 18}, 6 },
};

static const int MarriageOpType_entries_by_number[] = {
  3, // 1 -> MarriageOpType_MarryApply
  2, // 2 -> MarriageOpType_MarryAgree
  4, // 3 -> MarriageOpType_MarryRefuse
  0, // 4 -> MarriageOpType_Divorce
  1, // 5 -> MarriageOpType_DivorceCancel
  5, // 6 -> MarriageOpType_Max
};

const std::string& MarriageOpType_Name(
    MarriageOpType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          MarriageOpType_entries,
          MarriageOpType_entries_by_number,
          6, MarriageOpType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      MarriageOpType_entries,
      MarriageOpType_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     MarriageOpType_strings[idx].get();
}
bool MarriageOpType_Parse(
    const std::string& name, MarriageOpType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      MarriageOpType_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<MarriageOpType>(int_value);
  }
  return success;
}
bool MarriageStatus_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> MarriageStatus_strings[10] = {};

static const char MarriageStatus_names[] =
  "MarriageStatus_DivorceApply"
  "MarriageStatus_Divorced"
  "MarriageStatus_Marriaged"
  "MarriageStatus_Max"
  "MarriageStatus_Null"
  "MarriageStatus_WeddingCarNoWedding"
  "MarriageStatus_WeddingHoldedAndCar"
  "MarriageStatus_WeddingHoldedNoCar"
  "MarriageStatus_WeddingHoldingAndCar"
  "MarriageStatus_WeddingHoldingNoCar";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry MarriageStatus_entries[] = {
  { {MarriageStatus_names + 0, 27}, 8 },
  { {MarriageStatus_names + 27, 23}, 9 },
  { {MarriageStatus_names + 50, 24}, 2 },
  { {MarriageStatus_names + 74, 18}, 10 },
  { {MarriageStatus_names + 92, 19}, 1 },
  { {MarriageStatus_names + 111, 34}, 5 },
  { {MarriageStatus_names + 145, 34}, 7 },
  { {MarriageStatus_names + 179, 33}, 4 },
  { {MarriageStatus_names + 212, 35}, 6 },
  { {MarriageStatus_names + 247, 34}, 3 },
};

static const int MarriageStatus_entries_by_number[] = {
  4, // 1 -> MarriageStatus_Null
  2, // 2 -> MarriageStatus_Marriaged
  9, // 3 -> MarriageStatus_WeddingHoldingNoCar
  7, // 4 -> MarriageStatus_WeddingHoldedNoCar
  5, // 5 -> MarriageStatus_WeddingCarNoWedding
  8, // 6 -> MarriageStatus_WeddingHoldingAndCar
  6, // 7 -> MarriageStatus_WeddingHoldedAndCar
  0, // 8 -> MarriageStatus_DivorceApply
  1, // 9 -> MarriageStatus_Divorced
  3, // 10 -> MarriageStatus_Max
};

const std::string& MarriageStatus_Name(
    MarriageStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          MarriageStatus_entries,
          MarriageStatus_entries_by_number,
          10, MarriageStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      MarriageStatus_entries,
      MarriageStatus_entries_by_number,
      10, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     MarriageStatus_strings[idx].get();
}
bool MarriageStatus_Parse(
    const std::string& name, MarriageStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      MarriageStatus_entries, 10, name, &int_value);
  if (success) {
    *value = static_cast<MarriageStatus>(int_value);
  }
  return success;
}
bool WeddingInviteOperType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> WeddingInviteOperType_strings[8] = {};

static const char WeddingInviteOperType_names[] =
  "Wedding_AgreeApply"
  "Wedding_Apply"
  "Wedding_CarCutScene"
  "Wedding_DisagreeApply"
  "Wedding_ForbidStranger"
  "Wedding_Invite"
  "Wedding_PermitStranger"
  "Wedding_Start";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry WeddingInviteOperType_entries[] = {
  { {WeddingInviteOperType_names + 0, 18}, 3 },
  { {WeddingInviteOperType_names + 18, 13}, 2 },
  { {WeddingInviteOperType_names + 31, 19}, 7 },
  { {WeddingInviteOperType_names + 50, 21}, 4 },
  { {WeddingInviteOperType_names + 71, 22}, 6 },
  { {WeddingInviteOperType_names + 93, 14}, 1 },
  { {WeddingInviteOperType_names + 107, 22}, 5 },
  { {WeddingInviteOperType_names + 129, 13}, 8 },
};

static const int WeddingInviteOperType_entries_by_number[] = {
  5, // 1 -> Wedding_Invite
  1, // 2 -> Wedding_Apply
  0, // 3 -> Wedding_AgreeApply
  3, // 4 -> Wedding_DisagreeApply
  6, // 5 -> Wedding_PermitStranger
  4, // 6 -> Wedding_ForbidStranger
  2, // 7 -> Wedding_CarCutScene
  7, // 8 -> Wedding_Start
};

const std::string& WeddingInviteOperType_Name(
    WeddingInviteOperType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          WeddingInviteOperType_entries,
          WeddingInviteOperType_entries_by_number,
          8, WeddingInviteOperType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      WeddingInviteOperType_entries,
      WeddingInviteOperType_entries_by_number,
      8, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     WeddingInviteOperType_strings[idx].get();
}
bool WeddingInviteOperType_Parse(
    const std::string& name, WeddingInviteOperType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      WeddingInviteOperType_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<WeddingInviteOperType>(int_value);
  }
  return success;
}
bool MarriagePos_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> MarriagePos_strings[4] = {};

static const char MarriagePos_names[] =
  "MarriagePos_Husband"
  "MarriagePos_Null"
  "MarriagePos_Wife"
  "Marriage_Max";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry MarriagePos_entries[] = {
  { {MarriagePos_names + 0, 19}, 2 },
  { {MarriagePos_names + 19, 16}, 1 },
  { {MarriagePos_names + 35, 16}, 3 },
  { {MarriagePos_names + 51, 12}, 4 },
};

static const int MarriagePos_entries_by_number[] = {
  1, // 1 -> MarriagePos_Null
  0, // 2 -> MarriagePos_Husband
  2, // 3 -> MarriagePos_Wife
  3, // 4 -> Marriage_Max
};

const std::string& MarriagePos_Name(
    MarriagePos value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          MarriagePos_entries,
          MarriagePos_entries_by_number,
          4, MarriagePos_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      MarriagePos_entries,
      MarriagePos_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     MarriagePos_strings[idx].get();
}
bool MarriagePos_Parse(
    const std::string& name, MarriagePos* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      MarriagePos_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<MarriagePos>(int_value);
  }
  return success;
}
bool WeddingOperType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> WeddingOperType_strings[12] = {};

static const char WeddingOperType_names[] =
  "WeddingOper_AgreeVows"
  "WeddingOper_ApplyVows"
  "WeddingOper_Candy"
  "WeddingOper_CandyRewardOverMax"
  "WeddingOper_DisAgreeVows"
  "WeddingOper_Fireworks"
  "WeddingOper_FireworksRewardOverMax"
  "WeddingOper_Flower"
  "WeddingOper_FlowerRewardOverMax"
  "WeddingOper_RoleNum"
  "WeddingOper_VowsPrepare"
  "WeddingOper_VowsStart";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry WeddingOperType_entries[] = {
  { {WeddingOperType_names + 0, 21}, 4 },
  { {WeddingOperType_names + 21, 21}, 3 },
  { {WeddingOperType_names + 42, 17}, 11 },
  { {WeddingOperType_names + 59, 30}, 10 },
  { {WeddingOperType_names + 89, 24}, 5 },
  { {WeddingOperType_names + 113, 21}, 2 },
  { {WeddingOperType_names + 134, 34}, 9 },
  { {WeddingOperType_names + 168, 18}, 1 },
  { {WeddingOperType_names + 186, 31}, 8 },
  { {WeddingOperType_names + 217, 19}, 12 },
  { {WeddingOperType_names + 236, 23}, 6 },
  { {WeddingOperType_names + 259, 21}, 7 },
};

static const int WeddingOperType_entries_by_number[] = {
  7, // 1 -> WeddingOper_Flower
  5, // 2 -> WeddingOper_Fireworks
  1, // 3 -> WeddingOper_ApplyVows
  0, // 4 -> WeddingOper_AgreeVows
  4, // 5 -> WeddingOper_DisAgreeVows
  10, // 6 -> WeddingOper_VowsPrepare
  11, // 7 -> WeddingOper_VowsStart
  8, // 8 -> WeddingOper_FlowerRewardOverMax
  6, // 9 -> WeddingOper_FireworksRewardOverMax
  3, // 10 -> WeddingOper_CandyRewardOverMax
  2, // 11 -> WeddingOper_Candy
  9, // 12 -> WeddingOper_RoleNum
};

const std::string& WeddingOperType_Name(
    WeddingOperType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          WeddingOperType_entries,
          WeddingOperType_entries_by_number,
          12, WeddingOperType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      WeddingOperType_entries,
      WeddingOperType_entries_by_number,
      12, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     WeddingOperType_strings[idx].get();
}
bool WeddingOperType_Parse(
    const std::string& name, WeddingOperType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      WeddingOperType_entries, 12, name, &int_value);
  if (success) {
    *value = static_cast<WeddingOperType>(int_value);
  }
  return success;
}
bool ArtifactDeityStoveOpType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ArtifactDeityStoveOpType_strings[3] = {};

static const char ArtifactDeityStoveOpType_names[] =
  "ArtifactDeityStove_Fuse"
  "ArtifactDeityStove_Inscription"
  "ArtifactDeityStove_Recast";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ArtifactDeityStoveOpType_entries[] = {
  { {ArtifactDeityStoveOpType_names + 0, 23}, 2 },
  { {ArtifactDeityStoveOpType_names + 23, 30}, 3 },
  { {ArtifactDeityStoveOpType_names + 53, 25}, 1 },
};

static const int ArtifactDeityStoveOpType_entries_by_number[] = {
  2, // 1 -> ArtifactDeityStove_Recast
  0, // 2 -> ArtifactDeityStove_Fuse
  1, // 3 -> ArtifactDeityStove_Inscription
};

const std::string& ArtifactDeityStoveOpType_Name(
    ArtifactDeityStoveOpType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ArtifactDeityStoveOpType_entries,
          ArtifactDeityStoveOpType_entries_by_number,
          3, ArtifactDeityStoveOpType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ArtifactDeityStoveOpType_entries,
      ArtifactDeityStoveOpType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ArtifactDeityStoveOpType_strings[idx].get();
}
bool ArtifactDeityStoveOpType_Parse(
    const std::string& name, ArtifactDeityStoveOpType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ArtifactDeityStoveOpType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<ArtifactDeityStoveOpType>(int_value);
  }
  return success;
}
bool DragonWeakType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DragonWeakType_strings[4] = {};

static const char DragonWeakType_names[] =
  "DragonWeakType_Max"
  "DragonWeakType_NotPass"
  "DragonWeakType_Null"
  "DragonWeakType_Pass";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DragonWeakType_entries[] = {
  { {DragonWeakType_names + 0, 18}, 4 },
  { {DragonWeakType_names + 18, 22}, 3 },
  { {DragonWeakType_names + 40, 19}, 1 },
  { {DragonWeakType_names + 59, 19}, 2 },
};

static const int DragonWeakType_entries_by_number[] = {
  2, // 1 -> DragonWeakType_Null
  3, // 2 -> DragonWeakType_Pass
  1, // 3 -> DragonWeakType_NotPass
  0, // 4 -> DragonWeakType_Max
};

const std::string& DragonWeakType_Name(
    DragonWeakType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DragonWeakType_entries,
          DragonWeakType_entries_by_number,
          4, DragonWeakType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DragonWeakType_entries,
      DragonWeakType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DragonWeakType_strings[idx].get();
}
bool DragonWeakType_Parse(
    const std::string& name, DragonWeakType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DragonWeakType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<DragonWeakType>(int_value);
  }
  return success;
}
bool BattleFieldType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> BattleFieldType_strings[2] = {};

static const char BattleFieldType_names[] =
  "BATTLE_FIELD_READY_ENTER"
  "BATTLE_FIELD_READY_LEAVE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry BattleFieldType_entries[] = {
  { {BattleFieldType_names + 0, 24}, 1 },
  { {BattleFieldType_names + 24, 24}, 2 },
};

static const int BattleFieldType_entries_by_number[] = {
  0, // 1 -> BATTLE_FIELD_READY_ENTER
  1, // 2 -> BATTLE_FIELD_READY_LEAVE
};

const std::string& BattleFieldType_Name(
    BattleFieldType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          BattleFieldType_entries,
          BattleFieldType_entries_by_number,
          2, BattleFieldType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      BattleFieldType_entries,
      BattleFieldType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     BattleFieldType_strings[idx].get();
}
bool BattleFieldType_Parse(
    const std::string& name, BattleFieldType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      BattleFieldType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<BattleFieldType>(int_value);
  }
  return success;
}
bool DragonGuildTaskType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DragonGuildTaskType_strings[2] = {};

static const char DragonGuildTaskType_names[] =
  "TASK_ACHIVEMENT"
  "TASK_NORMAL";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DragonGuildTaskType_entries[] = {
  { {DragonGuildTaskType_names + 0, 15}, 2 },
  { {DragonGuildTaskType_names + 15, 11}, 1 },
};

static const int DragonGuildTaskType_entries_by_number[] = {
  1, // 1 -> TASK_NORMAL
  0, // 2 -> TASK_ACHIVEMENT
};

const std::string& DragonGuildTaskType_Name(
    DragonGuildTaskType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DragonGuildTaskType_entries,
          DragonGuildTaskType_entries_by_number,
          2, DragonGuildTaskType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DragonGuildTaskType_entries,
      DragonGuildTaskType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DragonGuildTaskType_strings[idx].get();
}
bool DragonGuildTaskType_Parse(
    const std::string& name, DragonGuildTaskType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DragonGuildTaskType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<DragonGuildTaskType>(int_value);
  }
  return success;
}
bool DragonGuildTaskConditionType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DragonGuildTaskConditionType_strings[4] = {};

static const char DragonGuildTaskConditionType_names[] =
  "TASK_PASS_NODIE"
  "TASK_PASS_PARTNER_COUNT"
  "TASK_PASS_SCENE"
  "TASK_TIME_SPAN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DragonGuildTaskConditionType_entries[] = {
  { {DragonGuildTaskConditionType_names + 0, 15}, 2 },
  { {DragonGuildTaskConditionType_names + 15, 23}, 4 },
  { {DragonGuildTaskConditionType_names + 38, 15}, 1 },
  { {DragonGuildTaskConditionType_names + 53, 14}, 3 },
};

static const int DragonGuildTaskConditionType_entries_by_number[] = {
  2, // 1 -> TASK_PASS_SCENE
  0, // 2 -> TASK_PASS_NODIE
  3, // 3 -> TASK_TIME_SPAN
  1, // 4 -> TASK_PASS_PARTNER_COUNT
};

const std::string& DragonGuildTaskConditionType_Name(
    DragonGuildTaskConditionType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DragonGuildTaskConditionType_entries,
          DragonGuildTaskConditionType_entries_by_number,
          4, DragonGuildTaskConditionType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DragonGuildTaskConditionType_entries,
      DragonGuildTaskConditionType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DragonGuildTaskConditionType_strings[idx].get();
}
bool DragonGuildTaskConditionType_Parse(
    const std::string& name, DragonGuildTaskConditionType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DragonGuildTaskConditionType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<DragonGuildTaskConditionType>(int_value);
  }
  return success;
}
bool DragonGuildSortType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DragonGuildSortType_strings[6] = {};

static const char DragonGuildSortType_names[] =
  "DragonGuildSortByLeaderName"
  "DragonGuildSortByLevel"
  "DragonGuildSortByMemberCount"
  "DragonGuildSortByName"
  "DragonGuildSortBySceneID"
  "DragongGuildSortByTotalPPT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DragonGuildSortType_entries[] = {
  { {DragonGuildSortType_names + 0, 27}, 6 },
  { {DragonGuildSortType_names + 27, 22}, 1 },
  { {DragonGuildSortType_names + 49, 28}, 2 },
  { {DragonGuildSortType_names + 77, 21}, 5 },
  { {DragonGuildSortType_names + 98, 24}, 4 },
  { {DragonGuildSortType_names + 122, 26}, 3 },
};

static const int DragonGuildSortType_entries_by_number[] = {
  1, // 1 -> DragonGuildSortByLevel
  2, // 2 -> DragonGuildSortByMemberCount
  5, // 3 -> DragongGuildSortByTotalPPT
  4, // 4 -> DragonGuildSortBySceneID
  3, // 5 -> DragonGuildSortByName
  0, // 6 -> DragonGuildSortByLeaderName
};

const std::string& DragonGuildSortType_Name(
    DragonGuildSortType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DragonGuildSortType_entries,
          DragonGuildSortType_entries_by_number,
          6, DragonGuildSortType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DragonGuildSortType_entries,
      DragonGuildSortType_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DragonGuildSortType_strings[idx].get();
}
bool DragonGuildSortType_Parse(
    const std::string& name, DragonGuildSortType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DragonGuildSortType_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<DragonGuildSortType>(int_value);
  }
  return success;
}
bool DragonGuildUpdateType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DragonGuildUpdateType_strings[5] = {};

static const char DragonGuildUpdateType_names[] =
  "DUType_AddMember"
  "DUType_Dissmiss"
  "DUType_LeaveMember"
  "DUType_Level"
  "DUType_ShopRefresh";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DragonGuildUpdateType_entries[] = {
  { {DragonGuildUpdateType_names + 0, 16}, 1 },
  { {DragonGuildUpdateType_names + 16, 15}, 3 },
  { {DragonGuildUpdateType_names + 31, 18}, 2 },
  { {DragonGuildUpdateType_names + 49, 12}, 5 },
  { {DragonGuildUpdateType_names + 61, 18}, 4 },
};

static const int DragonGuildUpdateType_entries_by_number[] = {
  0, // 1 -> DUType_AddMember
  2, // 2 -> DUType_LeaveMember
  1, // 3 -> DUType_Dissmiss
  4, // 4 -> DUType_ShopRefresh
  3, // 5 -> DUType_Level
};

const std::string& DragonGuildUpdateType_Name(
    DragonGuildUpdateType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DragonGuildUpdateType_entries,
          DragonGuildUpdateType_entries_by_number,
          5, DragonGuildUpdateType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DragonGuildUpdateType_entries,
      DragonGuildUpdateType_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DragonGuildUpdateType_strings[idx].get();
}
bool DragonGuildUpdateType_Parse(
    const std::string& name, DragonGuildUpdateType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DragonGuildUpdateType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<DragonGuildUpdateType>(int_value);
  }
  return success;
}
bool CompeteDragonOpArg_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CompeteDragonOpArg_strings[2] = {};

static const char CompeteDragonOpArg_names[] =
  "CompeteDragon_GetInfo"
  "CompeteDragon_GetReward";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CompeteDragonOpArg_entries[] = {
  { {CompeteDragonOpArg_names + 0, 21}, 1 },
  { {CompeteDragonOpArg_names + 21, 23}, 2 },
};

static const int CompeteDragonOpArg_entries_by_number[] = {
  0, // 1 -> CompeteDragon_GetInfo
  1, // 2 -> CompeteDragon_GetReward
};

const std::string& CompeteDragonOpArg_Name(
    CompeteDragonOpArg value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CompeteDragonOpArg_entries,
          CompeteDragonOpArg_entries_by_number,
          2, CompeteDragonOpArg_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CompeteDragonOpArg_entries,
      CompeteDragonOpArg_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CompeteDragonOpArg_strings[idx].get();
}
bool CompeteDragonOpArg_Parse(
    const std::string& name, CompeteDragonOpArg* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CompeteDragonOpArg_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<CompeteDragonOpArg>(int_value);
  }
  return success;
}
bool TaskConnType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TaskConnType_strings[7] = {};

static const char TaskConnType_names[] =
  "TaskConn_Activity"
  "TaskConn_ItemID"
  "TaskConn_ItemTypeQuality"
  "TaskConn_MonsterID"
  "TaskConn_StageID"
  "TaskConn_StageType"
  "TaskConn_WorldBossRank";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TaskConnType_entries[] = {
  { {TaskConnType_names + 0, 17}, 5 },
  { {TaskConnType_names + 17, 15}, 1 },
  { {TaskConnType_names + 32, 24}, 4 },
  { {TaskConnType_names + 56, 18}, 3 },
  { {TaskConnType_names + 74, 16}, 2 },
  { {TaskConnType_names + 90, 18}, 7 },
  { {TaskConnType_names + 108, 22}, 6 },
};

static const int TaskConnType_entries_by_number[] = {
  1, // 1 -> TaskConn_ItemID
  4, // 2 -> TaskConn_StageID
  3, // 3 -> TaskConn_MonsterID
  2, // 4 -> TaskConn_ItemTypeQuality
  0, // 5 -> TaskConn_Activity
  6, // 6 -> TaskConn_WorldBossRank
  5, // 7 -> TaskConn_StageType
};

const std::string& TaskConnType_Name(
    TaskConnType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TaskConnType_entries,
          TaskConnType_entries_by_number,
          7, TaskConnType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TaskConnType_entries,
      TaskConnType_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TaskConnType_strings[idx].get();
}
bool TaskConnType_Parse(
    const std::string& name, TaskConnType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TaskConnType_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<TaskConnType>(int_value);
  }
  return success;
}
bool TaskActivityType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TaskActivityType_strings[18] = {};

static const char TaskActivityType_names[] =
  "TaskActType_Banquet"
  "TaskActType_BigmeleeKill"
  "TaskActType_BigmeleeScore"
  "TaskActType_Cooking"
  "TaskActType_DonateItem"
  "TaskActType_Dragonexp"
  "TaskActType_Fish"
  "TaskActType_GardenHarvest"
  "TaskActType_GardenSteal"
  "TaskActType_GuildBoss"
  "TaskActType_Help"
  "TaskActType_HeroBattleWin"
  "TaskActType_JoinBanquet"
  "TaskActType_PkWin"
  "TaskActType_SkyCityRound"
  "TaskActType_SuperRisk"
  "TaskActType_Tower"
  "TaskActType_WorldBoss";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TaskActivityType_entries[] = {
  { {TaskActivityType_names + 0, 19}, 16 },
  { {TaskActivityType_names + 19, 24}, 5 },
  { {TaskActivityType_names + 43, 25}, 6 },
  { {TaskActivityType_names + 68, 19}, 15 },
  { {TaskActivityType_names + 87, 22}, 11 },
  { {TaskActivityType_names + 109, 21}, 1 },
  { {TaskActivityType_names + 130, 16}, 12 },
  { {TaskActivityType_names + 146, 25}, 14 },
  { {TaskActivityType_names + 171, 23}, 13 },
  { {TaskActivityType_names + 194, 21}, 7 },
  { {TaskActivityType_names + 215, 16}, 10 },
  { {TaskActivityType_names + 231, 25}, 8 },
  { {TaskActivityType_names + 256, 23}, 17 },
  { {TaskActivityType_names + 279, 17}, 9 },
  { {TaskActivityType_names + 296, 24}, 4 },
  { {TaskActivityType_names + 320, 21}, 3 },
  { {TaskActivityType_names + 341, 17}, 2 },
  { {TaskActivityType_names + 358, 21}, 18 },
};

static const int TaskActivityType_entries_by_number[] = {
  5, // 1 -> TaskActType_Dragonexp
  16, // 2 -> TaskActType_Tower
  15, // 3 -> TaskActType_SuperRisk
  14, // 4 -> TaskActType_SkyCityRound
  1, // 5 -> TaskActType_BigmeleeKill
  2, // 6 -> TaskActType_BigmeleeScore
  9, // 7 -> TaskActType_GuildBoss
  11, // 8 -> TaskActType_HeroBattleWin
  13, // 9 -> TaskActType_PkWin
  10, // 10 -> TaskActType_Help
  4, // 11 -> TaskActType_DonateItem
  6, // 12 -> TaskActType_Fish
  8, // 13 -> TaskActType_GardenSteal
  7, // 14 -> TaskActType_GardenHarvest
  3, // 15 -> TaskActType_Cooking
  0, // 16 -> TaskActType_Banquet
  12, // 17 -> TaskActType_JoinBanquet
  17, // 18 -> TaskActType_WorldBoss
};

const std::string& TaskActivityType_Name(
    TaskActivityType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TaskActivityType_entries,
          TaskActivityType_entries_by_number,
          18, TaskActivityType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TaskActivityType_entries,
      TaskActivityType_entries_by_number,
      18, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TaskActivityType_strings[idx].get();
}
bool TaskActivityType_Parse(
    const std::string& name, TaskActivityType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TaskActivityType_entries, 18, name, &int_value);
  if (success) {
    *value = static_cast<TaskActivityType>(int_value);
  }
  return success;
}
bool PeriodTaskType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PeriodTaskType_strings[2] = {};

static const char PeriodTaskType_names[] =
  "PeriodTaskType_Daily"
  "PeriodTaskType_Weekly";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PeriodTaskType_entries[] = {
  { {PeriodTaskType_names + 0, 20}, 1 },
  { {PeriodTaskType_names + 20, 21}, 2 },
};

static const int PeriodTaskType_entries_by_number[] = {
  0, // 1 -> PeriodTaskType_Daily
  1, // 2 -> PeriodTaskType_Weekly
};

const std::string& PeriodTaskType_Name(
    PeriodTaskType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PeriodTaskType_entries,
          PeriodTaskType_entries_by_number,
          2, PeriodTaskType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PeriodTaskType_entries,
      PeriodTaskType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PeriodTaskType_strings[idx].get();
}
bool PeriodTaskType_Parse(
    const std::string& name, PeriodTaskType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PeriodTaskType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<PeriodTaskType>(int_value);
  }
  return success;
}
bool TaskOper_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TaskOper_strings[3] = {};

static const char TaskOper_names[] =
  "TaskOper_Add"
  "TaskOper_Del"
  "TaskOper_Set";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TaskOper_entries[] = {
  { {TaskOper_names + 0, 12}, 2 },
  { {TaskOper_names + 12, 12}, 3 },
  { {TaskOper_names + 24, 12}, 1 },
};

static const int TaskOper_entries_by_number[] = {
  2, // 1 -> TaskOper_Set
  0, // 2 -> TaskOper_Add
  1, // 3 -> TaskOper_Del
};

const std::string& TaskOper_Name(
    TaskOper value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TaskOper_entries,
          TaskOper_entries_by_number,
          3, TaskOper_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TaskOper_entries,
      TaskOper_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TaskOper_strings[idx].get();
}
bool TaskOper_Parse(
    const std::string& name, TaskOper* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TaskOper_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<TaskOper>(int_value);
  }
  return success;
}
bool NpcFlReqType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> NpcFlReqType_strings[6] = {};

static const char NpcFlReqType_names[] =
  "NPCFL_BASE_DATA"
  "NPCFL_BUY_GIFT_COUNT"
  "NPCFL_EXCHANGE"
  "NPCFL_GIVE_GIFT"
  "NPCFL_NPC_LEVEL_UP"
  "NPCFL_UNITE_ACT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry NpcFlReqType_entries[] = {
  { {NpcFlReqType_names + 0, 15}, 3 },
  { {NpcFlReqType_names + 15, 20}, 6 },
  { {NpcFlReqType_names + 35, 14}, 2 },
  { {NpcFlReqType_names + 49, 15}, 1 },
  { {NpcFlReqType_names + 64, 18}, 4 },
  { {NpcFlReqType_names + 82, 15}, 5 },
};

static const int NpcFlReqType_entries_by_number[] = {
  3, // 1 -> NPCFL_GIVE_GIFT
  2, // 2 -> NPCFL_EXCHANGE
  0, // 3 -> NPCFL_BASE_DATA
  4, // 4 -> NPCFL_NPC_LEVEL_UP
  5, // 5 -> NPCFL_UNITE_ACT
  1, // 6 -> NPCFL_BUY_GIFT_COUNT
};

const std::string& NpcFlReqType_Name(
    NpcFlReqType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          NpcFlReqType_entries,
          NpcFlReqType_entries_by_number,
          6, NpcFlReqType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      NpcFlReqType_entries,
      NpcFlReqType_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     NpcFlReqType_strings[idx].get();
}
bool NpcFlReqType_Parse(
    const std::string& name, NpcFlReqType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      NpcFlReqType_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<NpcFlReqType>(int_value);
  }
  return success;
}
bool NpcFlItemType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> NpcFlItemType_strings[3] = {};

static const char NpcFlItemType_names[] =
  "NPCFL_ITEM_NORMAL"
  "NPCFL_ITEM_RANDOM"
  "NPCFL_ITEM_TRIGGER_FAVOR";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry NpcFlItemType_entries[] = {
  { {NpcFlItemType_names + 0, 17}, 1 },
  { {NpcFlItemType_names + 17, 17}, 2 },
  { {NpcFlItemType_names + 34, 24}, 3 },
};

static const int NpcFlItemType_entries_by_number[] = {
  0, // 1 -> NPCFL_ITEM_NORMAL
  1, // 2 -> NPCFL_ITEM_RANDOM
  2, // 3 -> NPCFL_ITEM_TRIGGER_FAVOR
};

const std::string& NpcFlItemType_Name(
    NpcFlItemType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          NpcFlItemType_entries,
          NpcFlItemType_entries_by_number,
          3, NpcFlItemType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      NpcFlItemType_entries,
      NpcFlItemType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     NpcFlItemType_strings[idx].get();
}
bool NpcFlItemType_Parse(
    const std::string& name, NpcFlItemType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      NpcFlItemType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<NpcFlItemType>(int_value);
  }
  return success;
}
bool DailyRefreshOperType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DailyRefreshOperType_strings[4] = {};

static const char DailyRefreshOperType_names[] =
  "DROT_AskHelp"
  "DROT_BuyCount"
  "DROT_Refresh"
  "DROT_Refuse";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DailyRefreshOperType_entries[] = {
  { {DailyRefreshOperType_names + 0, 12}, 4 },
  { {DailyRefreshOperType_names + 12, 13}, 3 },
  { {DailyRefreshOperType_names + 25, 12}, 1 },
  { {DailyRefreshOperType_names + 37, 11}, 2 },
};

static const int DailyRefreshOperType_entries_by_number[] = {
  2, // 1 -> DROT_Refresh
  3, // 2 -> DROT_Refuse
  1, // 3 -> DROT_BuyCount
  0, // 4 -> DROT_AskHelp
};

const std::string& DailyRefreshOperType_Name(
    DailyRefreshOperType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DailyRefreshOperType_entries,
          DailyRefreshOperType_entries_by_number,
          4, DailyRefreshOperType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DailyRefreshOperType_entries,
      DailyRefreshOperType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DailyRefreshOperType_strings[idx].get();
}
bool DailyRefreshOperType_Parse(
    const std::string& name, DailyRefreshOperType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DailyRefreshOperType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<DailyRefreshOperType>(int_value);
  }
  return success;
}
bool DailyTaskIconType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DailyTaskIconType_strings[2] = {};

static const char DailyTaskIconType_names[] =
  "DailyTaskIcon_AskHelp"
  "DailyTaskIcon_BeHelp";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DailyTaskIconType_entries[] = {
  { {DailyTaskIconType_names + 0, 21}, 1 },
  { {DailyTaskIconType_names + 21, 20}, 2 },
};

static const int DailyTaskIconType_entries_by_number[] = {
  0, // 1 -> DailyTaskIcon_AskHelp
  1, // 2 -> DailyTaskIcon_BeHelp
};

const std::string& DailyTaskIconType_Name(
    DailyTaskIconType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DailyTaskIconType_entries,
          DailyTaskIconType_entries_by_number,
          2, DailyTaskIconType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DailyTaskIconType_entries,
      DailyTaskIconType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DailyTaskIconType_strings[idx].get();
}
bool DailyTaskIconType_Parse(
    const std::string& name, DailyTaskIconType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DailyTaskIconType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<DailyTaskIconType>(int_value);
  }
  return success;
}
bool SurviveFightEndType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SurviveFightEndType_strings[4] = {};

static const char SurviveFightEndType_names[] =
  "SURVIVE_DIE"
  "SURVIVE_LOAD_TIMEOUT"
  "SURVIVE_QUIT"
  "SURVIVE_WIN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SurviveFightEndType_entries[] = {
  { {SurviveFightEndType_names + 0, 11}, 2 },
  { {SurviveFightEndType_names + 11, 20}, 1 },
  { {SurviveFightEndType_names + 31, 12}, 3 },
  { {SurviveFightEndType_names + 43, 11}, 4 },
};

static const int SurviveFightEndType_entries_by_number[] = {
  1, // 1 -> SURVIVE_LOAD_TIMEOUT
  0, // 2 -> SURVIVE_DIE
  2, // 3 -> SURVIVE_QUIT
  3, // 4 -> SURVIVE_WIN
};

const std::string& SurviveFightEndType_Name(
    SurviveFightEndType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SurviveFightEndType_entries,
          SurviveFightEndType_entries_by_number,
          4, SurviveFightEndType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SurviveFightEndType_entries,
      SurviveFightEndType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SurviveFightEndType_strings[idx].get();
}
bool SurviveFightEndType_Parse(
    const std::string& name, SurviveFightEndType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SurviveFightEndType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<SurviveFightEndType>(int_value);
  }
  return success;
}
bool SurviveFightStage_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SurviveFightStage_strings[2] = {};

static const char SurviveFightStage_names[] =
  "SURVIVE_STAGE_FIGHT"
  "SURVIVE_STAGE_READY";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SurviveFightStage_entries[] = {
  { {SurviveFightStage_names + 0, 19}, 2 },
  { {SurviveFightStage_names + 19, 19}, 1 },
};

static const int SurviveFightStage_entries_by_number[] = {
  1, // 1 -> SURVIVE_STAGE_READY
  0, // 2 -> SURVIVE_STAGE_FIGHT
};

const std::string& SurviveFightStage_Name(
    SurviveFightStage value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SurviveFightStage_entries,
          SurviveFightStage_entries_by_number,
          2, SurviveFightStage_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SurviveFightStage_entries,
      SurviveFightStage_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SurviveFightStage_strings[idx].get();
}
bool SurviveFightStage_Parse(
    const std::string& name, SurviveFightStage* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SurviveFightStage_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<SurviveFightStage>(int_value);
  }
  return success;
}
bool BackFlowActOp_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> BackFlowActOp_strings[5] = {};

static const char BackFlowActOp_names[] =
  "BackFlowAct_GetTreasure"
  "BackFlowAct_ShopBuy"
  "BackFlowAct_ShopData"
  "BackFlowAct_ShopUpdate"
  "BackFlowAct_TreasureData";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry BackFlowActOp_entries[] = {
  { {BackFlowActOp_names + 0, 23}, 2 },
  { {BackFlowActOp_names + 23, 19}, 4 },
  { {BackFlowActOp_names + 42, 20}, 3 },
  { {BackFlowActOp_names + 62, 22}, 5 },
  { {BackFlowActOp_names + 84, 24}, 1 },
};

static const int BackFlowActOp_entries_by_number[] = {
  4, // 1 -> BackFlowAct_TreasureData
  0, // 2 -> BackFlowAct_GetTreasure
  2, // 3 -> BackFlowAct_ShopData
  1, // 4 -> BackFlowAct_ShopBuy
  3, // 5 -> BackFlowAct_ShopUpdate
};

const std::string& BackFlowActOp_Name(
    BackFlowActOp value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          BackFlowActOp_entries,
          BackFlowActOp_entries_by_number,
          5, BackFlowActOp_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      BackFlowActOp_entries,
      BackFlowActOp_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     BackFlowActOp_strings[idx].get();
}
bool BackFlowActOp_Parse(
    const std::string& name, BackFlowActOp* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      BackFlowActOp_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<BackFlowActOp>(int_value);
  }
  return success;
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace KKSG
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
