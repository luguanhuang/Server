// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: enum.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_enum_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_enum_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_enum_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_enum_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE
namespace KKSG {

enum KickType : int {
  KICK_NORMAL = 0,
  KICK_RELOGIN = 1,
  KICK_GMFORBID = 2,
  KICK_SERVER_SHUTDOWN = 3,
  KICK_DEL_ROLE = 4,
  KICK_CHANGE_PROFESSION = 5,
  KICK_HG = 6
};
bool KickType_IsValid(int value);
constexpr KickType KickType_MIN = KICK_NORMAL;
constexpr KickType KickType_MAX = KICK_HG;
constexpr int KickType_ARRAYSIZE = KickType_MAX + 1;

const std::string& KickType_Name(KickType value);
template<typename T>
inline const std::string& KickType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, KickType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function KickType_Name.");
  return KickType_Name(static_cast<KickType>(enum_t_value));
}
bool KickType_Parse(
    const std::string& name, KickType* value);
enum ErrorCode : int {
  ERR_SUCCESS = 0,
  ERR_UNKNOWN = 1,
  ERR_PASSWORD_ERROR = 2,
  ERR_RELOGIN = 3,
  ERR_ACCOUNT_NOT_EXIST = 4,
  ERR_NAME_EXIST = 5,
  ERR_INVALID_NAME = 6,
  ERR_STATE_ERROR = 7,
  ERR_PROFESSION_TYPE = 8,
  ERR_FAILED = 9,
  ERR_ACCOUNT_ROLE_FULL = 10,
  ERR_ACCOUNT_DATA_ERROR = 11,
  ERR_TIMEOUT = 12,
  ERR_SKILL_CONFIGERROR = 13,
  ERR_SKILL_LEVELREQ = 14,
  ERR_SKILL_ITEMREQ = 15,
  ERR_ACHIVE_NOTCOMPLETE = 16,
  ERR_ACHIVE_NOTCONFIG = 17,
  ERR_SKILL_POINT = 18,
  ERR_PROF_ERROR = 19,
  ERR_PROF_LEVELREQ = 20,
  ERR_PROF_LEVELREQ2 = 21,
  ERR_BIND_SKILL_OUTRANGE = 22,
  ERR_BIND_SKILL_NOT_LEARN = 23,
  ERR_BIND_SKILL_MISSSLOT = 24,
  ERR_ENHANCE_ERROR = 25,
  ERR_ENHANCE_LACKITEM = 26,
  ERR_ENHANCE_FAILED = 27,
  ERR_ENHANCE_SUCCEED = 28,
  ERR_ENHANCE_MAX = 29,
  ERR_ARENA_ERROR = 30,
  ERR_ARENA_COUNTLIMIT = 31,
  ERR_DECOMPOSE_FAILED = 32,
  ERR_DECOMPOSE_CANNOT = 33,
  ERR_DECOMPOSE_NOTFIND = 34,
  ERR_SCENE_LEVELREQ = 35,
  ERR_SCENE_NOFATIGUE = 36,
  ERR_SCENE_TODYCOUNTLIMIT = 37,
  ERR_SCENE_NEEDPREVCOMPLETE = 38,
  ERR_ITEM_NOTEXIST = 39,
  ERR_ITEM_LEVELLIMIT = 40,
  ERR_ITEM_CANNOTBEEQUIPED = 41,
  ERR_EMBLEM_NOEMPTYSLOT = 42,
  ERR_ITEM_NOT_ENOUGH = 43,
  ERR_EMBLEM_MAXLEVEL = 44,
  ERR_JADE_MAXLEVEL = 45,
  ERR_JADECOMPOSE_NOTFIND = 46,
  ERR_JADEATTACH_NOEMPTYSLOT = 47,
  ERR_JADE_COUNTNOTENOUGH = 48,
  ERR_CHECKIN_FULL = 49,
  ERR_CHECKIN_LACKDRAGONCOIN = 50,
  ERR_ACTIVITY_NOCHESTINDEX = 51,
  ERR_ACTIVITY_HASGETCHEST = 52,
  ERR_ACTIVITY_NOTENOUGHVALUE = 53,
  ERR_ACTIVITY_SPECIALCHESTCOUNTLIMIT = 54,
  ERR_ARENA_ADDCOUNTLACKCOIN = 55,
  ERR_JADE_OPENJADELACKCOIN = 56,
  ERR_JADE_NOEMPTYSLOT = 57,
  ERR_ITEM_NEED_DRAGONCOIN = 58,
  ERR_BUY_LIMIT = 59,
  ERR_SWEEP_NOT_THREE_STAR = 60,
  ERR_SHOP_ITEMNOTEXIST = 61,
  ERR_SHOP_LACKMONEY = 62,
  ERR_TEAM_ALREADY_INTEAM = 63,
  ERR_TEAM_NOT_EXIST = 64,
  ERR_TEAM_FULL = 65,
  ERR_TEAM_WRONG_PASSWORD = 66,
  ERR_SCENE_TIMELIMIT = 67,
  ERR_TEAM_EXPEDITIONID_NOT_EXIST = 68,
  ERR_TEAM_LEVEL_REQUARE = 69,
  ERR_SCENE_COOLDOWN = 70,
  ERR_SKILL_MAXLEVEL = 71,
  ERR_WORLDBOSS_DEAD = 72,
  ERR_REINFORCE_LEVELLIMIT = 73,
  ERR_REINFORCE_LACKMONEY = 74,
  ERR_ARENA_REWARDTAKEN = 75,
  ERR_SKILL_PROFESSION_ERROR = 76,
  ERR_SKILL_NEED_PRESKILL = 77,
  ERR_LOGIN_TIMEOUT = 78,
  ERR_LOGIN_NOSERVER = 79,
  ERR_SHOP_LEVELLIMIT = 80,
  ERR_SHOP_PPTLIMIT = 81,
  ERR_SHOP_COUNTLIMIT = 82,
  ERR_SHOP_DAILYCOUNTLIMIT = 83,
  ERR_CHAT_LEVELLIMIT = 84,
  ERR_CHAT_LENGTHLIMIT = 85,
  ERR_CHAT_TIMELIMIT = 86,
  ERR_FASHOIN_ALREADY_EXIST = 87,
  ERR_FASHION_NOT_EXIST = 88,
  ERR_FRIEND_MAX = 89,
  ERR_FRIEND_REPEATED = 90,
  ERR_FRIEND_NOTEXIST = 91,
  ERR_BLACK_INSELF = 92,
  ERR_BLACK_INOTHER = 93,
  ERR_BLACK_NOTEXIST = 94,
  ERR_LOGIN_VERIFY_FAILED = 95,
  ERR_GUILD_NOT_EXIST = 96,
  ERR_GUILD_NAME_EXIST = 97,
  ERR_GUILD_NOT_IN_GUILD = 98,
  ERR_GUILD_ALREADY_IN_GUILD = 99,
  ERR_GUILD_NO_PERMISSION = 100,
  ERR_CHAPTERCHEST_ALREADY_FETCHED = 101,
  ERR_CHAPTERCHEST_NEEDSTAR = 102,
  ERR_SESSION_KICKOFF = 103,
  ERR_ALIVE_TIMEOUT = 104,
  ERR_GS_CLOSED = 105,
  ERR_FASHIONCOMPOSE_LEVEL_REQ = 106,
  ERR_GUILD_FULL = 107,
  ERR_GUILD_PPT_REQ = 108,
  ERR_GUILD_WAITAPPROVAL = 109,
  ERR_GUILD_MEMBER_NOT_EXIST = 110,
  ERR_FLOWER_SELF = 111,
  ERR_FLOWER_COUNTLIMIT = 112,
  ERR_FLOWER_ROLELIMIT = 113,
  ERR_FLOWER_COSTLIMIT = 114,
  ERR_GUILDCARD_ALLCOUNTLIMIT = 115,
  ERR_GUILDCARD_COUNTLIMIT = 116,
  ERR_GUILDCARD_CHANGELIMIT = 117,
  ERR_GUILDCHECKIN_LIMIT = 118,
  ERR_GUILDCHECKIN_MONEY = 119,
  ERR_GUILDCHECKIN_TAKEN = 120,
  ERR_GUILDCHECKIN_BOXLIMIT = 121,
  ERR_SCENE_NEED_PRESCENE = 122,
  ERR_GUILDBONUS_NOTEXIST = 123,
  ERR_GUILDBONUS_ALREADYGET = 124,
  ERR_GUILDBONUS_EXCEED = 125,
  ERR_GUILD_OPENLIMIT = 126,
  ERR_SHOP_OPENLIMIT = 127,
  ERR_GUILDCHECKIN_ALLCOUNT = 128,
  ERR_TEAM_EXPEDITION_DAYCOUNT = 129,
  ERR_TEAM_GUILD_DAYCOUNT = 130,
  ERR_TEAM_NEST_DAYCOUNT = 131,
  ERR_GUILD_LEVEL_REQ = 132,
  ERR_TEAM_NOT_OPENTIME = 133,
  ERR_TEAM_NEED_ATLEAST_2_MEMBER = 134,
  ERR_TEAM_ONLY_LEADER_CAN_KICK = 135,
  ERR_TEAM_MEMBER_NOT_EXIST = 136,
  ERR_SKILL_GUILD_CONTRIBUTE = 137,
  ERR_REWARD_TAKEN = 138,
  ERR_REWARD_LIMIT = 139,
  ERR_REWARD_NOTEXIST = 140,
  ERR_GUILD_VICE_FULL = 141,
  ERR_GUILD_OFFICER_FULL = 142,
  ERR_GUILD_ELITE_FULL = 143,
  ERR_TEAM_MEMBER_NOT_ONLINE = 144,
  ERR_TEAM_DISAGREE_BATTLE = 145,
  ERR_TEAM_ONLY_LEADER_CAN_STARTBATTLE = 146,
  ERR_TEAM_MATCHING = 147,
  ERR_ROLE_NOT_ONLINE = 148,
  ERR_TEAM_ONLY_LEADER_CAN_DO = 149,
  ERR_LACKCOIN = 150,
  ERR_LACKDIAMOND = 151,
  ERR_SMELTING_INVALID = 152,
  ERR_SMELTING_TRANSINVALID = 153,
  ERR_GUILD_NAME_TOO_SHORT = 154,
  ERR_GUILD_NAME_TOO_LONG = 155,
  ERR_TEAM_NOT_IN_HALL = 156,
  ERR_TEAM_IN_BATTLE = 157,
  ERR_TEAM_VOTE = 158,
  ERR_TEAM_STATE_ERROR = 159,
  ERR_TEAM_INVITE_ROLE_IS_IN_BATTLE = 160,
  ERR_ITEM_COOLDOWN = 161,
  ERR_LOGIN_FORBID = 162,
  ERR_LOGIN_MAXNUM = 163,
  ERR_SCENE_NEED_PRETASK = 164,
  ERR_NAME_HAS_INVALID_CHAR = 165,
  ERR_SMELTING_LACKMONEY = 166,
  ERR_OTHER_GAOJIGU_NOTOPEN = 167,
  ERR_FISHING_NUMNOTENOUGH = 168,
  ERR_FISHING_ALREADYSEAT = 169,
  ERR_FISHING_SEATNOTEMPTY = 170,
  ERR_SLOTATTR_NOEQUIP = 171,
  ERR_SLOTATTR_MONEYLIMIT = 172,
  ERR_SLOTATTR_LEVELLIMIT = 173,
  ERR_PK_NOMATCH = 174,
  ERR_ITEM_WRONG_PROFESSION = 175,
  ERR_SKILL_NOT_MATCH = 176,
  ERR_TSHOW_LEVEL_NOTENOUGH = 177,
  ERR_TRANSFER_LACKMONEY = 178,
  ERR_AUCT_HAVEBIDDING = 179,
  ERR_AUCT_ITEMOUTSALE = 180,
  ERR_AUCT_PRICECHAGE = 181,
  ERR_AUCT_SURPASSSELF = 182,
  ERR_AUCT_POINTLESS = 183,
  ERR_AUCT_DRAGONCOINLESS = 184,
  ERR_AUCT_BUYSELF = 185,
  ERR_ALREADY_IN_CAMP = 186,
  ERR_NOT_IN_CAMP = 187,
  ERR_AUCT_ONSALEMAX = 188,
  ERR_AUCT_COMMONERR = 189,
  ERR_AUCT_ITEMSALED = 190,
  ERR_SCENE_NOT_IN_CONFIG = 191,
  ERR_GAOJIGU_MODEL_DUPLICATE_FASHIONID = 192,
  ERR_TEAMBUY_COUNT_MAX = 193,
  ERR_TEAMBUY_DIAMOND_LESS = 194,
  ERR_ADDFRIEND_DUMMYROLE = 195,
  ERR_VERSION_FAILED = 196,
  ERR_EXPBACK_ALREADYGET = 197,
  ERR_PK_OPENTIME = 198,
  ERR_ITEM_NEED_DIAMOND = 199,
  ERR_WORD_FORBID = 200,
  ERR_TEAM_TOWER_DAYCOUNT = 201,
  ERR_AUCTGOLDLESS = 202,
  ERR_ILLEGAL_CODE = 203,
  ERR_GUILD_CHECKINBONUS_TIMEERROR = 204,
  ERR_GUILD_CHECKINBONUS_ASKTOOMUCH = 205,
  ERR_TEAM_NOJOININBATTLE = 206,
  ERR_REGISTER_NUM_LIMIT = 207,
  ERR_FRIEND_MAXOTHER = 208,
  ERR_FRIEND_SENDLIMIT = 209,
  ERR_FRIEND_TAKENLIMIT = 210,
  ERR_ROLE_NOTEXIST = 211,
  ERR_RANDOMFRIEND_CD = 212,
  ERR_ENHANCE_TRANSLEVEL = 213,
  ERR_ENHANCE_TRANSPOS = 214,
  ERR_GUILD_LVL_LIMIT = 215,
  ERR_FRIEND_HASSEND = 216,
  ERR_GUILD_APPLYFULL = 217,
  ERR_BLACK_CHAT = 218,
  ERR_PVP_ROLE_INBATTLE = 219,
  ERR_FRIEND_SELF = 220,
  ERR_BLACK_MAX = 221,
  ERR_EMBLEM_NOIDENTIFY = 222,
  ERR_EMBLEM_NOTHIRDSLOT = 223,
  ERR_EMBLEM_CANTIDENTIFY = 224,
  GUILD_SKILL_STUDY_LEVEL_LIMIT = 225,
  GUILD_SKILL_GUILD_LEVEL_LIMIT = 226,
  ERR_GUILD_EXP_LIMIT = 227,
  ERR_REVIVE_MAXNUM = 228,
  ERR_QA_OVER_NAME_TIME = 229,
  ERR_QA_IN_OTHER_TYPE = 230,
  ERR_JADE_MINEQUIPLEVEL = 231,
  ERR_SWEEP_POWERPOINT_LESS = 232,
  ERR_SWEEP_TICKET_LESS = 233,
  ERR_ACCOUNT_INVALID = 234,
  ERR_JADE_WRONGTYPE = 235,
  ERR_SHOP_TIMELIMIT = 236,
  ERR_SHOP_VIPLIMIT = 237,
  ERR_SHOP_ARENALIMIT = 238,
  ERR_SHOP_PKLIMIT = 239,
  ERR_SHOP_GUILDLIMIT = 240,
  ERR_AUDIO_NOT_EXIST = 241,
  ERR_SHOP_INVALID = 242,
  ERR_WATCH_LIVEISOVER = 243,
  ERR_WATCH_LIVEISFULL = 244,
  ERR_TOWER_INSWEEP = 245,
  ERR_TOWER_FLOOR_NOTENOUGH = 246,
  ERR_DRAGON_TICKET_NOTENOUGH = 247,
  ERR_WATCH_WAIT = 248,
  ERR_OP_EXP_NOT_OPEN = 249,
  ERR_TEAM_GODDESS_DAYCOUNT = 250,
  ERR_TEAM_SEAL_TYPE = 251,
  ERR_DRAGON_PROGRESS_INVALID = 252,
  ERR_TEAMBUY_DRAGONCOIN_LESS = 253,
  ERR_JADE_REPLACE = 254,
  ERR_PVP_TEAM_MATCH = 255,
  ERR_GS_UNREADY = 256,
  ERR_INVALID_REQUEST = 257,
  ERR_PET_NOT_EXIST = 258,
  ERR_PE_CAN_NOT_RELEASE = 259,
  ERR_PETSYS_NOT_OPEN = 260,
  ERR_PET_SEAT_NOT_ENOUGH = 261,
  ERR_ACCOUNT_QUEUING = 262,
  ERR_TITLE_MAX = 263,
  ERR_TITLE_LACKITEM = 264,
  ERR_TITLE_PPTLIMIT = 265,
  ERR_BLACK_REPEATED = 266,
  ERR_BLACK_SELF = 267,
  ERR_TEAM_LEADER_NOTHELPER = 268,
  ERR_PET_IS_FULL = 269,
  ERR_IBSHOP_LACKGOODS = 270,
  ERR_IBSHOP_LIMITCOUNT = 271,
  ERR_IBSHOP_LACKDIAMOND = 272,
  ERR_IBSHOP_LACKDRAGON = 273,
  ERR_CHAT_PUNISH = 274,
  ERR_LOCKED_ROLE = 275,
  ERR_IBSHOP_ERRPARAM = 276,
  ERR_IBSHOP_BUYLV = 277,
  ERR_SPRITE_NOTFIND = 278,
  ERR_SPRITE_LEVELMAX = 279,
  ERR_SPRITE_EVOLUTION_LEVELMAX = 280,
  ERR_SPRITE_EVOLUTION_LEVELLIMIT = 281,
  ERR_SPRITE_EVOLUTION_LACKOFCOST = 282,
  ERR_SPRITE_AWAKE_LACKOFCOST = 283,
  ERR_SPRITE_LEVELUP_LACKOFCOST = 284,
  ERR_SPRITE_ALREADY_INFIGHT = 285,
  ERR_SPRITE_INFIGHT_FULL = 286,
  ERR_SPRITE_ALREADY_OUTFIGHT = 287,
  ERR_REVIVE_ITEMLIMIT = 288,
  ERR_REVIVE_MONEYLIMIT = 289,
  ERR_ENHANCE_NO_EQUIP_CAN_TRANSFORM = 290,
  ERR_IBSHOP_VIPLEVEL = 291,
  ERR_IBSHOP_OPENGROUP = 292,
  ERR_SPRITE_INFIGHT_SAMETYPE = 293,
  ERR_SMELT_MINLEVEL = 294,
  ERR_JADE_GOLDNOTENOUGH = 295,
  ATLAS_CARD_NOT_ENOUGH = 296,
  ERR_AUCT_ITEM_LESS = 297,
  ERR_AUCT_ITEM_LOCK = 298,
  ERR_AUCT_PRICE_NOTCHANGE = 299,
  ERR_LEVELSEAL_PROP_NOT_ENGOUTH = 300,
  ERR_AUCT_AUTOREFRESH_TIME = 301,
  ERR_ATLAS_NOT_BREAK = 302,
  ERR_LOGIN_NOT_IN_WHITE_LIST = 303,
  ERR_TEAM_NOT_PASS = 304,
  ERR_QA_ALEADY_IN_ROOM = 500,
  ERR_QA_NO_DATA = 501,
  ERR_QA_LEVEL_NOT_ENOUGH = 502,
  ERR_QA_NOT_IN_TIME = 503,
  ERR_QA_NO_GUILD = 504,
  ERR_QA_NO_COUNT = 505,
  ERR_TASK_NOT_ACCEPT = 510,
  ERR_TASK_ALREADY_TAKE = 511,
  ERR_TASK_NOT_FOUND = 512,
  ERR_TASK_NOT_FINISH = 513,
  ERR_TASK_NO_TABLE = 514,
  ERR_GUILD_LADDER_NOT_OPEN = 515,
  ERR_GARDEN_NOTEXIST_FARMLAND = 516,
  ERR_GARDEN_NOHARVESTSTATE = 517,
  ERR_GARDEN_STEALEDTIMES_EXCEED = 518,
  ERR_GARDEN_NOTEXIST_SEEDID = 519,
  ERR_GARDEN_NOTEXIST_SPRITE = 520,
  ERR_SKYCITY_NOT_OPEN = 521,
  ERR_GMF_UP_INCOOL = 522,
  ERR_GMF_UP_FULL = 523,
  ERR_QA_NO_GUILD_ROOM = 524,
  ERR_TEAM_ALREADY_INOTHERTEAM = 525,
  ERR_TEAM_IDIP = 526,
  ERR_COMMENDWATCH_COUNTLIMIT = 527,
  ERR_CARDMATCH_BEGINFAILED = 528,
  ERR_CARDMATCH_NOBEGIN = 529,
  ERR_CARDMATCH_ENDSOON = 530,
  ERR_CARDMATCH_CHANGELIMIT = 531,
  ERR_SKILL_PREPOINTLIMIT = 532,
  ERR_SPACTIVITY_TASK_NOT_COMPLETE = 533,
  ERR_SPACTIVITY_TASK_GET = 534,
  ERR_SPACTIVITY_NOPRIZE = 535,
  ERR_SPACTIVITY_NOTPRIZETIME = 536,
  ERR_SPACTIVITY_NOTENOUGH_MONEY = 537,
  ERR_SPACTIVITY_PRIZE_GET = 538,
  ERR_GARDEN_PLANT_CD = 539,
  ERR_GARDEN_COOKING_EXCEED = 540,
  ERR_GARDEN_COOKINGLEVEL_LOW = 541,
  ERR_GARDEN_PLANT_CUL_ERR = 542,
  ERR_GARDEN_ERR_SEED = 543,
  ERR_GARDEN_NOSEED = 544,
  ERR_GARDEN_NOALLOW = 545,
  ERR_GMF_NOPOWER_KICK_LEADER = 546,
  ERR_SPRITE_ALREADY_ISLEADER = 547,
  ERR_SPRITE_AWAKE_ROLE_LEVELLIMIT = 548,
  ERR_SPRITE_EVOLUTION_ROLE_LEVELLIMIT = 549,
  ERR_GUILD_ALREADY_BIND = 550,
  ERR_GUILD_NOT_BIND = 551,
  ERR_ALREADY_IN_QQGROUP = 552,
  ERR_INSPIRE_COOLDOWN = 553,
  ERR_SKYCITY_IN_TEAM = 554,
  ERR_SKYCITY_TEAM_OUTTIME = 555,
  ERR_GMF_DOWN_FIGHTING = 556,
  ERR_GMF_DOWN_HAVEFAILED = 557,
  ERR_JADE_SAME_TYPE = 558,
  ERR_CHAT_BLACK_INSELF = 559,
  ERR_CHAT_BLACK_INOTHER = 560,
  ERR_GARDEN_QUESTS_NOENOUGH = 561,
  ERR_GARDEN_NOTINGARDEN = 562,
  ERR_GARDEN_FOODBOOK_ACTIVED = 563,
  ERR_ROLE_LOGOUT = 564,
  ERR_TEAM_INV_LOGOUT = 565,
  ERR_SKYCITY_LV = 566,
  ERR_RESWAR_TEAM = 567,
  ERR_RESWAR_ACTIVITY = 568,
  ERR_RESWAR_GROUP = 569,
  ERR_RESWAR_STATE = 570,
  ERR_RESWAR_CD = 571,
  ERR_BAG_FULL = 572,
  ERR_BAG_FULL_TAKEOFF_EQUIP = 573,
  ERR_BAG_FULL_TAKEOFF_FASHION = 574,
  ERR_BAG_FULL_TAKEOFF_EMBLEM = 575,
  ERR_BAG_FULL_TAKEOFF_JADE = 576,
  ERR_BAG_FULL_GIVE_MAIL_REWARD = 577,
  ERR_AUCT_PRICE_CHANGE = 578,
  ERR_GMF_UPBATTLE_REPEAT = 579,
  ERR_PANDORA_LACKOF_FIRE = 580,
  ERR_AUCT_AUCTOVER = 581,
  ERR_GOLDCLICK_LIMIT = 582,
  ERR_DRAGONCOIN_LIMIT = 583,
  ERR_NOTGUILD = 584,
  ERR_SCENE_NOT_PET = 585,
  ERR_GUILDBONUS_ALLGET = 586,
  ERR_GUILDBUFF_GUILD = 587,
  ERR_GUILDBUFF_POS = 588,
  ERR_GUILDBUFF_CD = 589,
  ERR_GUILDBUFF_ITEM = 590,
  ERR_RESWAR_LEADER = 591,
  ERR_RESWAR_LACKPLAYER = 592,
  ERR_TEAM_INV_IN_FAMILY = 593,
  ERR_TASK_NO_ASK_HELPNUM = 594,
  ERR_TASK_CANNOT_HELP = 595,
  ERR_TASK_ALREADY_FINISH = 596,
  ERR_TASK_ALREADY_ASKED = 597,
  ERR_GARDEN_NOEXIST_FOODID = 598,
  ERR_GARDEN_FOOD_NOALLOW = 599,
  ERR_TASK_NO_ASKINFO = 600,
  ERR_TASK_ASKITEM_REFRESH = 601,
  ERR_ANTI_CHEAT_DETECTED = 305,
  ERR_MS_UNREADY = 306,
  ERR_PET_EXP_EQUAL = 602,
  ERR_TASK_CANNT_HELPSELF = 603,
  CanNotDelInGuildArena = 604,
  ERR_RESWAR_TEAMFIGHTING = 605,
  ERR_TASK_CANNOT_GIVEUP = 606,
  ERR_GUILD_INHERIT_NOT_EXIT = 607,
  ERR_GUILD_INHERIT_GAP = 608,
  ERR_GUILD_INHERIT_LVL = 609,
  ERR_GUILD_INHERIT_TIMES = 610,
  ERR_GUILD_INHERIT_MAP_WRONG = 611,
  ERR_TEAMCOST_DIAMOND = 612,
  ERR_TEAMCOST_DRAGON = 613,
  ERR_TEAM_PPTLIMIT = 614,
  ERR_GUILD_INHERIT_CD_TIME = 615,
  ERR_MS_UNNORMAL = 616,
  ERR_TEAMCOST_NUMLIMIT = 617,
  ERR_STATE_CANTCHANGE = 618,
  ERR_TEAM_MEMCOUNT_OVER = 619,
  ERR_GUILD_INHERIT_CAN_NOT = 620,
  ERR_SYS_NOTOPEN = 621,
  ERR_NAME_ALLNUM = 622,
  ERR_NAME_TOO_LONG = 623,
  ERR_NAME_TOO_SHORT = 624,
  ERR_GUILD_INHERIT_OTHER_TIMES = 625,
  ERR_NEED_FIRST_PROMOTE = 626,
  ERR_FM_NOANCHOR = 627,
  ERR_CAN_NOT_USE_PET_SKILL_BOOK = 628,
  ERR_ENCHANT_MINLEVEL = 629,
  ERR_ENCHANT_LACKITEM = 631,
  ERR_ENCHANT_WRONGPOS = 632,
  ERR_PARTNER_NUM_INVALID = 650,
  ERR_PARTNER_FDEGREE_NOT_ENOUGH = 651,
  ERR_PARTNER_NOT_IN_MAIN_HALL = 652,
  ERR_PARTNER_NOT_ENOUGH_DRAGON = 653,
  ERR_PARTNER_CD_NOT_OK = 654,
  ERR_HORSE_ACTIVITY = 655,
  ERR_TEAM_WEEK_NEST_EXP = 656,
  ERR_PARTNER_CHEST_TAKED = 657,
  ERR_PARTNER_NO_PARTNER = 658,
  ERR_PARTNER_LN_NOT_ENOUGH = 659,
  ERR_PARTNER_ALREADY_HAS = 660,
  ERR_PARTNER_ALREADY_APPLY_LEAVE = 661,
  ERR_PARTNER_NOT_APPLY_LEAVE = 662,
  ERR_INVFIGHT_ROLE_LOGOUT = 663,
  ERR_INVFIGHT_ME_LEVEL = 664,
  ERR_INVFIGHT_ME_SCENE = 665,
  ERR_INVFIGHT_OTHER_LEVEL = 666,
  ERR_INVFIGHT_OTHER_SCENE = 667,
  ERR_INVFIGHT_INV_REPEAT = 668,
  ERR_INVFIGHT_INV_COUNT_MAX = 669,
  ERR_INVFIGHT_INV_TIME_OVER = 670,
  ERR_INVFIGHT_INV_DELAY = 671,
  ERR_DOODAD_FULL = 672,
  ERR_INVFIGHT_INV_TO_COUNT_MAX = 673,
  ERR_PARTNER_ITEM_NOT_FOUND = 674,
  ERR_PARTNER_OTHER_BUYING = 675,
  ERR_PARTNER_SHOP_NO_COUNT = 676,
  ERR_FRIEND_IS_PARTNER = 677,
  ERR_PANDORA_LACKOF_HEART = 678,
  ERR_SELF_HAS_ALLIANCE = 679,
  ERR_OTHER_HAS_ALLIANCE = 680,
  ERR_AUDIOTXT = 681,
  ERR_MENTOR_ASKMAXTODAY = 682,
  ERR_MENTOR_REFRESHTOOFAST = 683,
  ERR_MENTOR_OTHER_ONLINE = 684,
  ERR_PARTNER_LEVEL_NOT_ENOUGH = 685,
  ERR_GCASTLE_NOT_IN_ACT = 686,
  ERR_GCASTLE_NOT_IN_FIGHT = 687,
  ERR_GCASTLE_ROLE_FULL = 688,
  ERR_CARDMATCH_SIGNUP_LIMIT = 689,
  ERR_GUILDAUCT_PUBLIC_TIME = 690,
  ERR_FASHIONCOMPOSE_TIMELIMIT = 691,
  ERR_FASHIONCOMPOSE_QUALITY = 692,
  ERR_FASHIONCOMPOSE_FAILED = 693,
  ERR_FASHIONCOMPOSE_POS = 694,
  ERR_RESWAR_LEAVETEAM = 695,
  ERR_RECONNECT_FAIL = 696,
  ERR_CANTCHOOSEHERO = 697,
  ERR_HERO_INVALID = 698,
  ERR_TEAM_SERVER_OPEN_TIME = 699,
  ERR_AUDIO_CHAT = 700,
  ERR_HERO_LACKMONEY = 701,
  ERR_HEROBATTLE_CANTGETPRIZE = 702,
  ERR_HEROBATTLE_ALREADYGET = 703,
  ERR_CAN_NOT_DEL_IN_GUILD_TERRITOYR = 704,
  ERR_HORSE_TEAM = 705,
  ERR_GCASTLE_ROLE_LEVEL = 706,
  ERR_CAN_INGORE = 707,
  ERR_LEAGUE_NOT_IN_TEAM = 708,
  ERR_LEAGUE_ALREADY_HAS_TEAM = 709,
  ERR_LEAGUE_TEAM_ROLE_NUM_INVALID = 710,
  ERR_LEAGUE_HAS_NO_TEAM = 711,
  ERR_LEAGUE_TEAM_NOT_EXIST = 712,
  ERR_GARDEN_STEAL_LIMIT = 713,
  ERR_LEAGUE_TEAM_IN_MATCH = 714,
  ERR_LEAGUE_TEAM_NOT_IN_MATCH = 715,
  ERR_SKILL_NEED_EXPRESKILL = 716,
  ERR_EQUIP_CANTFORGE = 717,
  ERR_EQUIP_FORGE_LACK_ITEM = 718,
  ERR_EQUIP_FORGE_LACK_STONE = 719,
  ERR_LEAGUE_ROLE_ALREADY_UP = 720,
  ERR_LEAGUE_ROLE_FIGHTING = 721,
  ERR_LEAGUE_ROLE_ALREADY_BATTLE = 722,
  ERR_REQUEST_REPEAT = 723,
  ERR_EQUIP_FORGE_FAILED = 724,
  ERR_NOMAIL_GETREWARD = 725,
  ERR_MIDAS_FAILED = 726,
  ERR_LEAGUE_TEAM_IN_BATTLE = 727,
  ERR_ENCHANT_NOTHAVE = 728,
  ERR_ENCHANT_ALREADYHAVE = 729,
  ERR_ENCHANT_TRANSFER_LEVEL_LIMIT = 730,
  ERR_FM_NOINAUDIO = 731,
  ERR_FM_NOINROOM = 732,
  ERR_CHANGEPRO_LEVEL = 733,
  ERR_CHANGEPRO_TIME = 734,
  ERR_CHANGEPRO_COUNT = 735,
  ERR_CHANGEPRO_INVALID = 736,
  ERR_CHANGEPRO_SAMEPRO = 737,
  ERR_CHANGEPRO_ITEMLIMIT = 738,
  ERR_SMELT_MAXVALUE = 739,
  ERR_SPRITE_AWAKE_MAX = 740,
  ERR_CHANGEPRO_KICK = 741,
  ERR_LEAGUE_NOT_IN_MATCH_TIME = 742,
  ERR_LEAGUE_TEAM_NOT_IN_BATTLE = 743,
  ERR_SPRITE_TRAIN_MAX = 744,
  ERR_SPRITE_TRAIN_CHOOSEMAX = 745,
  ERR_SPRITE_TRAIN_LACKITEM = 746,
  ERR_SPRITE_NOTTRAIN = 747,
  ERR_SPRITE_RESETTRAIN_LACKITEM = 748,
  ERR_LEAGUE_ALREADY_FIGHTED = 749,
  ERR_LEAGUE_NOT_IN_APPLY_TIME = 750,
  ERR_HORSE_INTEAM = 751,
  ERR_LEAGUE_INV_NOT_IN_TEAM = 752,
  ERR_LEAGUE_INV_ALREADY_HAS_TEAM = 753,
  ERR_SPRITE_TRAIN_NOT_ENOUGH = 754,
  ERR_DECLAREWAR_OUT_TIME = 756,
  ERR_LEAGUE_TEAM_CANNOT_CROSS = 757,
  ERR_DECLARATION_TOO_LONG = 758,
  ERR_CROSS_ZONE_UNUSABLE = 759,
  ERR_NOT_DEL_GUILD_IN_TERR = 760,
  ERR_GCASTLE_FIGHT_END = 761,
  ERR_CAREER_PVP_NOTOPEN = 762,
  ERR_APOLLO_CDN = 763,
  ERR_LEAGUE_HAS_MEMBER_NOT_TEAM = 764,
  ERR_POK_MATCH_ENDSOON = 765,
  ERR_QUESTCAREER_NOT_ONLINE = 766,
  ERR_MIDAS_BALANCE_NOTENOUTH = 767,
  ERR_HAS_JOIN_OTHER_GUILD_BOSS = 768,
  ERR_AUTH_TOKEN_INVALID = 769,
  ERR_TEAM_TICKET_LESS = 770,
  ERR_TEAM_USE_TICKET_COUNT_LESS = 771,
  ERR_TEAM_TICKET_CONFIG = 772,
  ERR_TEAM_TICKET_SEAL = 773,
  ERR_INVALID_IBBUY = 774,
  ERR_CROSS_IBBUY = 775,
  ERR_GUILD_NAME_NULL = 776,
  ERR_GUILD_LOCK_NAME = 777,
  ERR_ARGENTA_DAILY_GET = 778,
  ERR_WORLDBOSSGUILD_COUNTLIMIT = 779,
  ERR_WORLDBOSSGUILD_UNMATCH = 780,
  ERR_HERO_EXPERIENCE_HAVE = 781,
  ERR_PLATSHARE_FAILED = 782,
  ERR_HERO_ALREADY_CHOSEN = 783,
  ERR_SKY_NOT_TEAM_MEMBER = 784,
  ERR_SKY_ALREADY_HAS_TEAM = 785,
  ERR_SKY_HAS_NO_TEAM = 786,
  ERR_SKY_INV_NOT_TEAM_MEMBER = 787,
  ERR_SKY_TEAM_IN_MATCH = 788,
  ERR_SKY_INV_ALREADY_HAS_TEAM = 789,
  ERR_SKY_TEAM_ROLE_NUM_INVALID = 790,
  ERR_SKY_TEAM_IN_BATTLE = 791,
  ERR_SKY_HAS_NOT_TEAM_MEMBER = 792,
  ERR_MENTOR_COMPLETE_OTHER_OFFLINE_NEED_DAYS = 793,
  ERR_MENTOR_COMPLETE_IN_RELATION_NEED_DAYS = 794,
  ERR_TRANSFERR_OTHER_ROLES_LEAVE = 795,
  ERR_PLAT_BANACC = 796,
  ERR_RESWAR_DIFF_GUILD = 797,
  ERR_SKY_ALREADY_FIGHTED = 798,
  ERR_SKY_TEAM_NO_DAILY_NUM = 799,
  ERR_IBGIFT_NOT_ENOUCH = 800,
  ERR_IBGIFT_DAY_MAXBUYCOUNT = 801,
  ERR_IBGIFT_FRIEND = 802,
  ERR_ALREADY_BUYAILEEN = 803,
  ERR_GUILDACMPPATY_NOTOPEN = 804,
  ERR_GUILDACMPPATY_ERRSTAGE = 805,
  ERR_GUILDACMPPATY_DISTANCE = 806,
  ERR_MENTOR_ALREADY_INRELATION = 807,
  ERR_GUILDACMPPATY_SPRITE_ONTEXIST = 808,
  ERR_BAG_FULL_CANT_COMPOSE = 809,
  ERR_BAG_FULL_TAKEOFF_ARTIFACT = 810,
  ERR_GIFTIB_NOTGOODS = 811,
  ERR_ARTIFACT_COMPOSE_LEVELNOTEQUAL = 812,
  ERR_ARTIFACT_COMPOSE_QUALITYNOTEQUAL = 813,
  ERR_ARTIFACT_COMPOSE_NUMBER = 814,
  ERR_ARTIFACT_COMPOSE_CANTCOMPOSE = 815,
  ERR_CUSTOMBATTLE_INVALIDREQUEST = 816,
  ERR_CUSTOMBATTLE_WORLDNOTOPEN = 817,
  ERR_CUSTOMBATTLE_HASJOIN = 818,
  ERR_CUSTOMBATTLE_NOTJOIN = 819,
  ERR_CUSTOMBATTLE_CREATFAILED = 820,
  ERR_CUSTOMBATTLE_LEVELLIMIT = 821,
  ERR_CUSTOMBATTLE_ROELNOTEXIST = 822,
  ERR_CUSTOMBATTLE_CREATECONFINVALID = 823,
  ERR_CUSTOMBATTLE_JOINNOTRELATED = 824,
  ERR_CUSTOMBATTLE_JOINNOTINREADYTIME = 825,
  ERR_CUSTOMBATTLE_JOINFULL = 826,
  ERR_CUSTOMBATTLE_JOININVALIDPASSWORD = 827,
  ERR_CUSTOMBATTLE_JOINFAILED = 828,
  ERR_CUSTOMBATTLE_NOTCREATER = 829,
  ERR_CUSTOMBATTLE_BATTLENOTFIND = 830,
  ERR_CUSTOMBATTLE_MATCHFAILED = 831,
  ERR_IBGIFT_MAX_COUNT = 832,
  ERR_ENCHANT_NOTHAVEATTRID = 833,
  ERR_EXTRA_EMBLEM_SLOT_FULL = 834,
  ERR_EXTRA_EMBLEM_SLOT_LEVEL = 835,
  ERR_IBGIFT_OVERMAXUNRECV = 836,
  ERR_TEAM_CANNOT_FORNOW = 837,
  ERR_ALREADY_REPORTED = 838,
  ERR_CUSTOMBATTLE_REWARDCD = 839,
  ERR_CUSTOMBATTLE_REWARDCANGET = 840,
  ERR_FASHION_ITEM_NOT_ENOUGH = 841,
  ERR_GUILDPARTY_TRADIING = 842,
  ERR_SPACTIVITY_NOTOPEN = 843,
  ERR_BAGEXPAND_LESSITEM = 844,
  ERR_BAGEXPAND_MAXCOUNT = 845,
  ERR_SHOP_WEEKCOUNTLIMIT = 846,
  ERR_GUILDBONUS_MAXNUM = 847,
  ERR_SELF_GIFT_SELF = 848,
  ERR_IBSHOP_BUSY = 849,
  ERR_ABYSS_LEVEL = 850,
  ERR_GUILDCAMP_SELF_NOTIN = 851,
  ERR_GUILDCAMP_OTHER_NOTIN = 852,
  ERR_SMELTCOUNT_ZERO = 853,
  ERR_CUSTOMBATTLE_REWARDHASGET = 854,
  ERR_CUSTOMBATTLE_PASSWORDINVALID = 855,
  ERR_CUSTOMBATTLE_CREATORLEAVE = 856,
  ERR_GUILDCAMP_SPRITE_NOTEXIST = 857,
  ERR_TEAM_INV_TIMEOUT = 858,
  ERR_FORGE_NOREPLACE = 859,
  ERR_CUSTOMBATTLE_NAMEMAX = 860,
  ERR_CUSTOMBATTLE_NAMEMIN = 861,
  ERR_CUSTOMBATTLE_NAMEINVALID = 862,
  ERR_REPORT_FORBID = 863,
  ERR_TEAM_COST_CANCEL = 864,
  ERR_TEAM_COST_WIN = 865,
  ERR_CUSTOM_NOTOPEN = 866,
  ERR_CUSTOM_GMLIMIT = 867,
  ERR_MILITARY_TRIGGER_CHECK = 868,
  ERR_MENTOR_INHERIT_ING = 869,
  ERR_MOBA_UPGRADENUM_EMPTY = 870,
  ERR_FASHION_ERROR_COLOR = 871,
  ERR_FASHION_COLOR_UNLOOK = 872,
  ERR_FASHION_NO_HAIR = 873,
  ERR_FASHION_COLOR_LOOK = 874,
  ERR_MOBA_SIGNAL_TOOFAST = 875,
  ERR_NOT_BESPEAK = 876,
  ERR_PAIRPET_OUTRANGE = 877,
  ERR_PAIRPET_INVITEINVALID = 878,
  ERR_ROLE_IN_OTHER_SERVER = 879,
  ERR_MOBA_CANTMATCH = 880,
  ERR_PAIRPET_INVITEREPEAT = 881,
  ERR_PAIRPET_SCENEINVALID = 882,
  ERR_PAIRPET_SELF = 883,
  ERR_PAIRPET_OTHER = 884,
  ERR_PAIRPET_OTHERNOTIN = 885,
  ERR_MENTOR_OTHER_APPLY_BREAK = 886,
  ERR_MENTOR_ALREADY_COMPLETE_MENTOR = 887,
  ERR_MENTOR_OTHER_ALREADY_APPLY_INHERIT = 888,
  ERR_MENTOR_CUR_STATUS_CANNOT_BREAK = 889,
  ERR_CUSTOM_SAMEMATCH = 890,
  ERR_CUSTOM_NOMATCHING = 891,
  ERR_MENTOR_CUR_STATUS_CANNOT_APPLYSTUDENT = 892,
  ERR_MENTOR_CUR_STATUS_CANNOT_APPLYMASTER = 893,
  ERR_TEAM_DIAMOND_COST_LIMIT = 894,
  ERR_ACT_NOT_OPEN = 895,
  ERR_MOBA_MOBMAXLEVEL = 896,
  ERR_ACTIVITY = 897,
  ERR_NOCONDITION = 898,
  ERR_SERVER_UNNORMAL = 899,
  ERR_CUSTOMBATTLE_BOUNTYMODE_NOTOPEN = 900,
  ERR_GROUPCHAT_FULLGROUP = 901,
  ERR_GROUPCHAT_ROLENOCOUNT = 902,
  ERR_GROUPCHAT_LEADERNOCOUNT = 903,
  ERR_GROUPCHAT_GROUPFULLMEMBERS = 904,
  ERR_UNUSE1 = 905,
  ERR_HAVE_GOT_AWARD = 906,
  ERR_ANCIENTPOWER_LESSPOINT = 907,
  ERR_ANCIENTPOWER_DEAD = 908,
  ERR_JADE_DRAGONNOTENOUGH = 909,
  ERR_WEDDING_NOT_EXISTS = 910,
  ERR_WEDDING_ALREADY_INVITE = 911,
  ERR_WEDDING_NOT_INVITE = 912,
  ERR_WEDDING_NOT_APPLY = 913,
  ERR_MARRIAGE_LEVEL_NOTENOUGH = 914,
  ERR_MARRIAGE_NEED_TWO_NOTMARRY = 915,
  ERR_MARRIAGE_DISTANCE_TOOFAR = 916,
  ERR_WEDDING_OPER_CD = 917,
  ERR_WEDDING_ALREADY_VOWS = 918,
  ERR_WEDDING_HP_NOT_ENOUGH = 919,
  ERR_WEDDING_NOT_OWNER = 920,
  ERR_MARRIAGE_NOTINMARRIAGE = 921,
  ERR_MARRIAGE_ALREADY_APPLYDIVORCE = 922,
  ERR_MARRIAGE_NOT_DIVORCESTATUS = 923,
  ERR_MARRIAGE_ONLY_APPLIER_CANCLEDIVORCE = 924,
  ERR_FRIEND_DEGREE_NOTENOUGH = 925,
  ERR_WEDDING_ALREADY_HOLDED = 926,
  ERR_WEDDING_ALREADY_TAKECAR = 927,
  ERR_INVALID_PAYROLE = 928,
  ERR_WEDDING_IS_HOLDING = 929,
  ERR_WEDDING_NOT_RUNNING = 930,
  ERR_LIVENESS_NOT_ENOUGH = 931,
  ERR_CHEST_TAKED = 932,
  ERR_WEDDING_ALREADY_APPLY = 933,
  ERR_GROUPCHAT_FULLGROUP_OTHER = 934,
  ERR_GROUPCHAT_TIMEOUT = 935,
  ERR_GROUPCHAT_NO_MANAGER = 936,
  ERR_ITEM_NOT_ENOUGH_COMMON = 937,
  ERR_WEDDINGCAR_CANT_IN_PET = 938,
  ERR_WEDDINGCAR_OTHER_RUNNING = 939,
  ERR_ARTIFACT_CANTRECAST = 940,
  ERR_ARTIFACT_CANTFUSE = 941,
  ERR_ARTIFACT_FUSEFAILED = 942,
  ERR_ARTIFACT_FUSE_CONDITION = 943,
  ERR_ARTIFACT_CANTINSCRIPTION = 944,
  ERR_WEDDING_ALREADY_REFUSE = 945,
  ERR_WEDDING_NEED_TWO_MARRIAGE = 946,
  ERR_SPRITE_NOTREBIRTH = 947,
  ERR_TEAM_FASTMATCH_BUFF = 948,
  ERR_TEAM_SERVER_NOT_MATCH = 949,
  ERR_DAILY_WEDDY_CANDY_OVERMAX = 950,
  ERR_MARRIAGE_NEED_TEAM = 951,
  ERR_BACKFLOW_BUYEND = 952,
  ERR_NEED_MARRIAGE_TEAM = 953,
  ERR_DOENTERSCENE_FAILED = 954,
  ERR_WEDDING_INVITE_OVERMAX = 955,
  ERR_ARTIFACT_INSCRIPTION_LEVEL = 956,
  ERR_TRANS_PASSIVE = 957,
  ERR_TRANS_NONE = 958,
  ERR_TRANS_OTHERNOTEXIST = 959,
  ERR_TRANS_ITEMNOTENOUGH = 960,
  ERR_TRANS_STATE_FAILED = 961,
  ERR_TRANS_SCENE_INVALID = 962,
  ERR_GARDEN_EXPELSPRITE_MAX = 963,
  ERR_OP_ROLE_LEAVE = 964,
  ERR_BATTLEFIELD_NOT_OPEN = 965,
  ERR_BATTLEFIELD_LEVEL = 966,
  ERR_TASK_NO_REFRESH_COUNT = 967,
  ERR_CANT_FUSE = 968,
  ERR_FUSE_MAX = 969,
  ERR_TASK_NOT_TASK_ITEM = 970,
  ERR_COMPETEDRAGON_WRONG_DNID = 971,
  ERR_CANNOT_PICK_THIS_ITEM = 972,
  ERR_NPCFL_NEED_REFRESH = 973,
  ERR_NPCFL_NPC_LEVEL_MAX = 974,
  ERR_NPCFL_ITEM_LESS = 975,
  ERR_NPCFL_EXP_LESS = 976,
  ERR_NPCFL_UNITE_LEVEL_LESS = 977,
  ERR_NPCFL_GIVE_GIFT_COUNT_LESS = 978,
  ERR_NPCFL_BUY_GG_COUNT_LESS = 979,
  ERR_NPCFL_DRAGON_COIN_LESS = 980,
  ERR_DAILY_TASK_NO_REFRESH_COUNT = 981,
  ERR_DAILY_TASK_CANNT_REFRESH = 982,
  ERR_DAILY_TASK_NO_BUY_COUNT = 983,
  ERR_DAILY_TASK_QUALITY_MAX = 984,
  ERR_DG_ALREADY_IN_DG = 985,
  ERR_DG_DGNAME_EXIST = 986,
  ERR_DG_DGUILD_NOT_EXIST = 987,
  ERR_DG_FULL = 988,
  ERR_DG_PPT_REQ = 989,
  ERR_DG_WAITAPPROVAL = 990,
  ERR_DG_NOT_IN_GUILD = 991,
  ERR_DG_NO_PERMISSION = 992,
  ERR_DG_LOCK_NAME = 993,
  ERR_DG_APPLY_FULL = 994,
  ERR_DG_IN_CD = 995,
  ERR_DG_ITEM_NOT_FOUND = 996,
  ERR_DG_OTHER_BUYING = 997,
  ERR_DG_SHOP_NO_COUNT = 998,
  ERR_DG_NOT_IN_SAME = 999,
  ERR_DG_POSITION_FULL = 1000,
  ERR_DAILY_TASK_OTHER_NO_HELPCOUNT = 1001,
  ERR_UNOPEN_FUNCTION = 1002,
  ERR_QUERYBOX_TIMELEFT = 1003,
  ERR_GUILDPARTY_ENDING = 1004,
  ERR_GUILDPARTY_HAVESUMMON = 1005,
  ERR_KINGBACK_REWARD_COUNT_LIMIT = 1006,
  ERR_DG_NOT_IN_APPROVAL = 1007,
  ERR_GUILDPARTY_SUMMONING = 1008,
  ERR_HG_FORBID = 1009,
  ERR_FASHION_NOEXIST_EFFECTS = 1010,
  ERR_BACKFLOW_ALREADYGET = 1011,
  ERR_BACKFLOW_LESSPOINT = 1012,
  ERR_TEAM_CROSS_TEAM_CHANGE_EXP = 1013,
  ERR_TEAM_CHANGE_EXP_TO_CROSS = 1014,
  ERR_INVALID_STATE = 1015,
  ERR_CHANGE_SAMESCENE = 1016,
  ERR_BACKFLOWSHOP_LESSFRESHCOUNT = 1017,
  ERR_BACKFLOWSHOP_NOTHAVEGOOD = 1018,
  ERR_BACKFLOWSHOP_LACKDIAMOND = 1019,
  ERR_BACKFLOWSHOP_LACKDRAGONCOIN = 1020,
  ERR_BACKFLOWSHOP_ALREADYBUY = 1021,
  ERR_BACKFLOWSHOP_SHOPCLOSE = 1022,
  ERR_ALREADY_CHARGE_BACK = 1023,
  ERR_FUSE_EXPMAX = 1024,
  ERR_FUSE_BREAKLACKEXP = 1025
};
bool ErrorCode_IsValid(int value);
constexpr ErrorCode ErrorCode_MIN = ERR_SUCCESS;
constexpr ErrorCode ErrorCode_MAX = ERR_FUSE_BREAKLACKEXP;
constexpr int ErrorCode_ARRAYSIZE = ErrorCode_MAX + 1;

const std::string& ErrorCode_Name(ErrorCode value);
template<typename T>
inline const std::string& ErrorCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ErrorCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ErrorCode_Name.");
  return ErrorCode_Name(static_cast<ErrorCode>(enum_t_value));
}
bool ErrorCode_Parse(
    const std::string& name, ErrorCode* value);
enum RoleType : int {
  Role_INVALID = 0,
  Role_Warrior = 1,
  Role_Archer = 2,
  Role_Sorceress = 3,
  Role_Cleric = 4,
  Role_Academic = 5,
  Role_Swordsman = 11,
  Role_Mercenary = 21,
  Role_Sharpshooter = 12,
  Role_Acrobat = 22,
  Role_Elementalist = 13,
  Role_Mystic = 23,
  Role_Paladin = 14,
  Role_Priest = 24,
  Role_Engineer = 15,
  Role_Alchemist = 25,
  Role_Gladiator = 111,
  Role_Moonlord = 211,
  Role_Destroyer = 121,
  Role_Barbarian = 221,
  Role_Sniper = 112,
  Role_Artillery = 212,
  Role_Tempest = 122,
  Role_Windwalker = 222,
  Role_Saleana = 113,
  Role_Elestra = 213,
  Role_Smasher = 123,
  Role_Majesty = 223,
  Role_Guardian = 114,
  Role_Crusader = 214,
  Role_Saint = 124,
  Role_Inquistior = 224,
  Role_Shootingstar = 115,
  Role_Gearmaster = 215,
  Role_Adept = 125,
  Role_Physician = 225,
  Role_Assassin = 6,
  Role_Shinobi = 16,
  Role_Taoist = 26,
  Role_Reaper = 116,
  Role_Raven = 216,
  Role_LightBringer = 126,
  Role_AbyssWalker = 226,
  Role_Kali = 7,
  Role_Screamer = 17,
  Role_Dancer = 27,
  Role_SoulEater = 117,
  Role_DarkSummoner = 217,
  Role_SpiritDancer = 127,
  Role_BladeDancer = 227
};
bool RoleType_IsValid(int value);
constexpr RoleType RoleType_MIN = Role_INVALID;
constexpr RoleType RoleType_MAX = Role_BladeDancer;
constexpr int RoleType_ARRAYSIZE = RoleType_MAX + 1;

const std::string& RoleType_Name(RoleType value);
template<typename T>
inline const std::string& RoleType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RoleType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RoleType_Name.");
  return RoleType_Name(static_cast<RoleType>(enum_t_value));
}
bool RoleType_Parse(
    const std::string& name, RoleType* value);
enum SceneType : int {
  SCENE_HALL = 1,
  SCENE_BATTLE = 2,
  SCENE_NEST = 3,
  SCENE_ARENA = 5,
  SCENE_WORLDBOSS = 7,
  SCENE_BOSSRUSH = 9,
  SCENE_GUILD_HALL = 10,
  SCENE_GUILD_BOSS = 11,
  SCENE_PK = 12,
  SCENE_ABYSSS = 13,
  SCENE_FAMILYGARDEN = 15,
  SCENE_TOWER = 16,
  SCENE_PVP = 17,
  SCENE_DRAGON = 18,
  SCENE_GMF = 19,
  SCENE_GODDESS = 20,
  SCENE_DRAGON_EXP = 21,
  SCENE_RISK = 22,
  SCENE_ENDLESSABYSS = 23,
  SKYCITY_WAITING = 24,
  SKYCITY_FIGHTING = 25,
  SCENE_PROF_TRIALS = 26,
  SCENE_GPR = 27,
  SCENE_RESWAR_PVP = 28,
  SCENE_RESWAR_PVE = 29,
  SCENE_GUILD_CAMP = 30,
  SCENE_AIRSHIP = 31,
  SCENE_WEEK_NEST = 32,
  SCENE_VS_CHALLENGE = 33,
  SCENE_HORSE = 34,
  SCENE_HORSE_RACE = 35,
  SCENE_HEROBATTLE = 36,
  SCENE_INVFIGHT = 37,
  SCENE_CASTLE_WAIT = 38,
  SCENE_CASTLE_FIGHT = 39,
  SCENE_LEAGUE_BATTLE = 40,
  SCENE_ACTIVITY_ONE = 41,
  SCENE_ACTIVITY_TWO = 42,
  SCENE_ACTIVITY_THREE = 43,
  SCENE_ABYSS_PARTY = 44,
  SCENE_CUSTOMPK = 45,
  SCENE_PKTWO = 46,
  SCENE_MOBA = 47,
  SCENE_WEEKEND4V4_MONSTERFIGHT = 48,
  SCENE_WEEKEND4V4_GHOSTACTION = 49,
  SCENE_WEEKEND4V4_LIVECHALLENGE = 50,
  SCENE_WEEKEND4V4_CRAZYBOMB = 51,
  SCENE_WEEKEND4V4_HORSERACING = 52,
  SCENE_CUSTOMPKTWO = 53,
  SCENE_WEEKEND4V4_DUCK = 54,
  SCENE_BIGMELEE_READY = 60,
  SCENE_BIGMELEE_FIGHT = 61,
  SCENE_CALLBACK = 62,
  SCENE_WEDDING = 63,
  SCENE_BIOHELL = 64,
  SCENE_DUCK = 65,
  SCENE_COUPLE = 66,
  SCENE_BATTLEFIELD_READY = 67,
  SCENE_BATTLEFIELD_FIGHT = 68,
  SCENE_COMPETEDRAGON = 69,
  SCENE_SURVIVE = 70,
  SCENE_LEISURE = 71,
  SCENE_LOGIN = 100
};
bool SceneType_IsValid(int value);
constexpr SceneType SceneType_MIN = SCENE_HALL;
constexpr SceneType SceneType_MAX = SCENE_LOGIN;
constexpr int SceneType_ARRAYSIZE = SceneType_MAX + 1;

const std::string& SceneType_Name(SceneType value);
template<typename T>
inline const std::string& SceneType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SceneType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SceneType_Name.");
  return SceneType_Name(static_cast<SceneType>(enum_t_value));
}
bool SceneType_Parse(
    const std::string& name, SceneType* value);
enum TableDef : int {
  AccountTable = 1,
  RoleTable = 2
};
bool TableDef_IsValid(int value);
constexpr TableDef TableDef_MIN = AccountTable;
constexpr TableDef TableDef_MAX = RoleTable;
constexpr int TableDef_ARRAYSIZE = TableDef_MAX + 1;

const std::string& TableDef_Name(TableDef value);
template<typename T>
inline const std::string& TableDef_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TableDef>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TableDef_Name.");
  return TableDef_Name(static_cast<TableDef>(enum_t_value));
}
bool TableDef_Parse(
    const std::string& name, TableDef* value);
enum EntitySpecies : int {
  Species_Boss = 1,
  Species_Opposer = 2,
  Species_Puppet = 3,
  Species_Npc = 7,
  Species_Role = 10,
  Species_Empty = 8,
  Species_Dummy = 9,
  Species_Substance = 5,
  Species_Affiliate = 11,
  Species_Elite = 6
};
bool EntitySpecies_IsValid(int value);
constexpr EntitySpecies EntitySpecies_MIN = Species_Boss;
constexpr EntitySpecies EntitySpecies_MAX = Species_Affiliate;
constexpr int EntitySpecies_ARRAYSIZE = EntitySpecies_MAX + 1;

const std::string& EntitySpecies_Name(EntitySpecies value);
template<typename T>
inline const std::string& EntitySpecies_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EntitySpecies>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EntitySpecies_Name.");
  return EntitySpecies_Name(static_cast<EntitySpecies>(enum_t_value));
}
bool EntitySpecies_Parse(
    const std::string& name, EntitySpecies* value);
enum BattleChestRewardType : int {
  GOLD_CHEST = 1,
  SILVER_CHEST = 2,
  COPPER_CHEST = 3,
  WOOD_CHEST = 4
};
bool BattleChestRewardType_IsValid(int value);
constexpr BattleChestRewardType BattleChestRewardType_MIN = GOLD_CHEST;
constexpr BattleChestRewardType BattleChestRewardType_MAX = WOOD_CHEST;
constexpr int BattleChestRewardType_ARRAYSIZE = BattleChestRewardType_MAX + 1;

const std::string& BattleChestRewardType_Name(BattleChestRewardType value);
template<typename T>
inline const std::string& BattleChestRewardType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BattleChestRewardType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BattleChestRewardType_Name.");
  return BattleChestRewardType_Name(static_cast<BattleChestRewardType>(enum_t_value));
}
bool BattleChestRewardType_Parse(
    const std::string& name, BattleChestRewardType* value);
enum TaskOPEnum : int {
  TAKE_TASK = 1,
  FINISH_TASK = 2
};
bool TaskOPEnum_IsValid(int value);
constexpr TaskOPEnum TaskOPEnum_MIN = TAKE_TASK;
constexpr TaskOPEnum TaskOPEnum_MAX = FINISH_TASK;
constexpr int TaskOPEnum_ARRAYSIZE = TaskOPEnum_MAX + 1;

const std::string& TaskOPEnum_Name(TaskOPEnum value);
template<typename T>
inline const std::string& TaskOPEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TaskOPEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TaskOPEnum_Name.");
  return TaskOPEnum_Name(static_cast<TaskOPEnum>(enum_t_value));
}
bool TaskOPEnum_Parse(
    const std::string& name, TaskOPEnum* value);
enum ResetType : int {
  RESET_SKILL = 0,
  RESET_PROFESSION = 1,
  RESET_GUILD_SKILL = 2
};
bool ResetType_IsValid(int value);
constexpr ResetType ResetType_MIN = RESET_SKILL;
constexpr ResetType ResetType_MAX = RESET_GUILD_SKILL;
constexpr int ResetType_ARRAYSIZE = ResetType_MAX + 1;

const std::string& ResetType_Name(ResetType value);
template<typename T>
inline const std::string& ResetType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResetType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResetType_Name.");
  return ResetType_Name(static_cast<ResetType>(enum_t_value));
}
bool ResetType_Parse(
    const std::string& name, ResetType* value);
enum LotteryType : int {
  Sprite_Draw_One = 1,
  Sprite_Draw_Ten = 2,
  Sprite_Draw_One_Free = 3,
  Sprite_GoldDraw_One = 4,
  Sprite_GoldDraw_Ten = 5,
  Sprite_GoldDraw_One_Free = 6
};
bool LotteryType_IsValid(int value);
constexpr LotteryType LotteryType_MIN = Sprite_Draw_One;
constexpr LotteryType LotteryType_MAX = Sprite_GoldDraw_One_Free;
constexpr int LotteryType_ARRAYSIZE = LotteryType_MAX + 1;

const std::string& LotteryType_Name(LotteryType value);
template<typename T>
inline const std::string& LotteryType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LotteryType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LotteryType_Name.");
  return LotteryType_Name(static_cast<LotteryType>(enum_t_value));
}
bool LotteryType_Parse(
    const std::string& name, LotteryType* value);
enum EntityCategory : int {
  Category_Role = 0,
  Category_Enemy = 1,
  Category_Neutral = 2,
  Category_DummyRole = 3,
  Category_Others = 4
};
bool EntityCategory_IsValid(int value);
constexpr EntityCategory EntityCategory_MIN = Category_Role;
constexpr EntityCategory EntityCategory_MAX = Category_Others;
constexpr int EntityCategory_ARRAYSIZE = EntityCategory_MAX + 1;

const std::string& EntityCategory_Name(EntityCategory value);
template<typename T>
inline const std::string& EntityCategory_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EntityCategory>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EntityCategory_Name.");
  return EntityCategory_Name(static_cast<EntityCategory>(enum_t_value));
}
bool EntityCategory_Parse(
    const std::string& name, EntityCategory* value);
enum RankeType : int {
  RealTimeArenaRank = 0,
  ArenaRank = 1,
  WorldBossGuildRank = 2,
  WorldBossDamageRank = 3,
  PowerPointRank = 4,
  LevelRank = 5,
  FlowerRank = 6,
  GuildBossRank = 7,
  GuildBossRoleRank = 8,
  PkRealTimeRank = 9,
  PkRank = 10,
  FashionPowerPointRank = 11,
  TShowVoteCountRank = 12,
  TowerRank = 13,
  FlowerYesterdayRank = 14,
  FlowerTotalRank = 15,
  FirstPassRank = 16,
  DEProgressRank = 17,
  SpritePowerPointRank = 18,
  PetPowerPointRank = 19,
  FlowerThisWeekRank = 20,
  NestWeekRank = 21,
  LeagueTeamRank = 22,
  CrossLeagueRank = 23,
  HeroBattleRank = 24,
  MilitaryRank = 25,
  LastWeek_PkRank = 26,
  LastWeek_NestWeekRank = 27,
  LastWeek_HeroBattleRank = 28,
  LastWeek_LeagueTeamRank = 29,
  SkyCraftRank = 30,
  PkRank2v2 = 31,
  FlowerActivityRank = 32,
  BigMeleeRank = 33,
  BioHelllRank = 34,
  CompeteDragonRank = 35,
  SurviveRank = 36,
  SkyCityRank = 37,
  WorldBossGuildRoleRank = 38
};
bool RankeType_IsValid(int value);
constexpr RankeType RankeType_MIN = RealTimeArenaRank;
constexpr RankeType RankeType_MAX = WorldBossGuildRoleRank;
constexpr int RankeType_ARRAYSIZE = RankeType_MAX + 1;

const std::string& RankeType_Name(RankeType value);
template<typename T>
inline const std::string& RankeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RankeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RankeType_Name.");
  return RankeType_Name(static_cast<RankeType>(enum_t_value));
}
bool RankeType_Parse(
    const std::string& name, RankeType* value);
enum MythShopOP : int {
  MythShopQuery = 1,
  MythShopBuy = 2,
  MythShopRefresh = 3
};
bool MythShopOP_IsValid(int value);
constexpr MythShopOP MythShopOP_MIN = MythShopQuery;
constexpr MythShopOP MythShopOP_MAX = MythShopRefresh;
constexpr int MythShopOP_ARRAYSIZE = MythShopOP_MAX + 1;

const std::string& MythShopOP_Name(MythShopOP value);
template<typename T>
inline const std::string& MythShopOP_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MythShopOP>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MythShopOP_Name.");
  return MythShopOP_Name(static_cast<MythShopOP>(enum_t_value));
}
bool MythShopOP_Parse(
    const std::string& name, MythShopOP* value);
enum SystemRewardType : int {
  RewardDinner = 1,
  RewardSupper = 2,
  RewardArena = 3,
  RewardWorldBoss = 4,
  RewardChargeFirst = 5,
  RewardGuildBoss = 6,
  RewardGuildBossRole = 7,
  RewardPk = 8,
  RewardVip = 101,
  RewardMonthCard = 102,
  RewardMakeUp = 103,
  RewardArenaUp = 104,
  RewardGM = 105,
  RewardDegree = 106,
  RewardFashionPowerRank = 107
};
bool SystemRewardType_IsValid(int value);
constexpr SystemRewardType SystemRewardType_MIN = RewardDinner;
constexpr SystemRewardType SystemRewardType_MAX = RewardFashionPowerRank;
constexpr int SystemRewardType_ARRAYSIZE = SystemRewardType_MAX + 1;

const std::string& SystemRewardType_Name(SystemRewardType value);
template<typename T>
inline const std::string& SystemRewardType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SystemRewardType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SystemRewardType_Name.");
  return SystemRewardType_Name(static_cast<SystemRewardType>(enum_t_value));
}
bool SystemRewardType_Parse(
    const std::string& name, SystemRewardType* value);
enum TeamState : int {
  TEAM_WAITING = 0,
  TEAM_IN_BATTLE = 1,
  TEAM_VOTE = 2,
  TEAM_MATCH = 3
};
bool TeamState_IsValid(int value);
constexpr TeamState TeamState_MIN = TEAM_WAITING;
constexpr TeamState TeamState_MAX = TEAM_MATCH;
constexpr int TeamState_ARRAYSIZE = TeamState_MAX + 1;

const std::string& TeamState_Name(TeamState value);
template<typename T>
inline const std::string& TeamState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TeamState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TeamState_Name.");
  return TeamState_Name(static_cast<TeamState>(enum_t_value));
}
bool TeamState_Parse(
    const std::string& name, TeamState* value);
enum TeamOperate : int {
  TEAM_CREATE = 1,
  TEAM_JOIN = 2,
  TEAM_LEAVE = 3,
  TEAM_TOGGLE_READY = 4,
  TEAM_QUERYCOUNT = 5,
  TEAM_KICK = 6,
  TEAM_START_BATTLE = 7,
  TEAM_START_BATTLE_AGREE = 8,
  TEAM_START_BATTLE_DISAGREE = 9,
  TEAM_CHANGE_EPXTEAMID = 10,
  TEAM_START_BATTLE_REMOVE_DISAGREE_MEMBER = 11,
  TEAM_INVITE = 12,
  TEAM_START_MATCH = 13,
  TEAM_STOP_MATCH = 14,
  TEAM_GET_FULL_DATA = 15,
  TEAM_DOWN_MATCH = 16,
  TEAM_BE_HELPER = 17,
  TEAM_QUIT_HELPER = 18,
  TEAM_PPTLIMIT = 19,
  TEAM_COSTTYPE = 20,
  TEAM_CHANGE_PASSWORD = 21,
  TEAM_TRAHS_LEADER = 22,
  TEAM_BATTLE_CONTINUE = 23,
  TEAM_USE_TICKET = 24,
  TEAM_MEMBER_TYPE = 25
};
bool TeamOperate_IsValid(int value);
constexpr TeamOperate TeamOperate_MIN = TEAM_CREATE;
constexpr TeamOperate TeamOperate_MAX = TEAM_MEMBER_TYPE;
constexpr int TeamOperate_ARRAYSIZE = TeamOperate_MAX + 1;

const std::string& TeamOperate_Name(TeamOperate value);
template<typename T>
inline const std::string& TeamOperate_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TeamOperate>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TeamOperate_Name.");
  return TeamOperate_Name(static_cast<TeamOperate>(enum_t_value));
}
bool TeamOperate_Parse(
    const std::string& name, TeamOperate* value);
enum ExpTeamMemberState : int {
  EXPTEAM_IDLE = 0,
  EXPTEAM_READY = 1,
  EXPTEAM_DISAGREE = 2,
  EXPTEAM_FINISH = 3
};
bool ExpTeamMemberState_IsValid(int value);
constexpr ExpTeamMemberState ExpTeamMemberState_MIN = EXPTEAM_IDLE;
constexpr ExpTeamMemberState ExpTeamMemberState_MAX = EXPTEAM_FINISH;
constexpr int ExpTeamMemberState_ARRAYSIZE = ExpTeamMemberState_MAX + 1;

const std::string& ExpTeamMemberState_Name(ExpTeamMemberState value);
template<typename T>
inline const std::string& ExpTeamMemberState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ExpTeamMemberState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ExpTeamMemberState_Name.");
  return ExpTeamMemberState_Name(static_cast<ExpTeamMemberState>(enum_t_value));
}
bool ExpTeamMemberState_Parse(
    const std::string& name, ExpTeamMemberState* value);
enum UnitAppearanceField : int {
  UNIT_BASIC = 15,
  UNIT_ATTR = 32,
  UNIT_FASHION = 64,
  UNIT_EQUIP = 128,
  UNIT_SKILL = 256,
  UNIT_EMBLEM = 512,
  UNIT_VIPLEVEL = 1024,
  UNIT_TIMELOGIN = 2048,
  UNIT_GUILD = 16384,
  UNIT_TITLE = 524288,
  UNIT_SPRITELEADER = 8388608,
  UNIT_SPRITE = 16777216,
  UNIT_PETS = 33554432,
  UNIT_ARTIFACT = 32768
};
bool UnitAppearanceField_IsValid(int value);
constexpr UnitAppearanceField UnitAppearanceField_MIN = UNIT_BASIC;
constexpr UnitAppearanceField UnitAppearanceField_MAX = UNIT_PETS;
constexpr int UnitAppearanceField_ARRAYSIZE = UnitAppearanceField_MAX + 1;

const std::string& UnitAppearanceField_Name(UnitAppearanceField value);
template<typename T>
inline const std::string& UnitAppearanceField_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UnitAppearanceField>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UnitAppearanceField_Name.");
  return UnitAppearanceField_Name(static_cast<UnitAppearanceField>(enum_t_value));
}
bool UnitAppearanceField_Parse(
    const std::string& name, UnitAppearanceField* value);
enum ChatChannel : int {
  WorldChannel = 1,
  GuildChannel = 2,
  PrivateChannel = 3,
  SystemChannel = 4,
  LampShortChannel = 5,
  LampLongChannel = 6,
  TeamChannel = 7,
  CampChannel = 8,
  SpectateChannel = 9,
  CurrentChannel = 10,
  PartnerChannel = 11,
  AudioChannel = 12,
  BattleChannel = 13,
  GroupChatChannel = 14
};
bool ChatChannel_IsValid(int value);
constexpr ChatChannel ChatChannel_MIN = WorldChannel;
constexpr ChatChannel ChatChannel_MAX = GroupChatChannel;
constexpr int ChatChannel_ARRAYSIZE = ChatChannel_MAX + 1;

const std::string& ChatChannel_Name(ChatChannel value);
template<typename T>
inline const std::string& ChatChannel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChatChannel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChatChannel_Name.");
  return ChatChannel_Name(static_cast<ChatChannel>(enum_t_value));
}
bool ChatChannel_Parse(
    const std::string& name, ChatChannel* value);
enum LoginType : int {
  LOGIN_PASSWORD = 0,
  LOGIN_SNDA_PF = 1,
  LOGIN_QQ_PF = 2,
  LGOIN_WECHAT_PF = 3,
  LOGIN_IOS_GUEST = 4,
  LOGIN_IOS_AUDIT = 5
};
bool LoginType_IsValid(int value);
constexpr LoginType LoginType_MIN = LOGIN_PASSWORD;
constexpr LoginType LoginType_MAX = LOGIN_IOS_AUDIT;
constexpr int LoginType_ARRAYSIZE = LoginType_MAX + 1;

const std::string& LoginType_Name(LoginType value);
template<typename T>
inline const std::string& LoginType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LoginType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LoginType_Name.");
  return LoginType_Name(static_cast<LoginType>(enum_t_value));
}
bool LoginType_Parse(
    const std::string& name, LoginType* value);
enum FashionNTFType : int {
  ADD_FASHION = 1,
  UPGRADE_FASHION = 2,
  WEAR_FASHION = 3,
  DELBODY_FASHION = 4,
  DELBAG_FASHION = 5
};
bool FashionNTFType_IsValid(int value);
constexpr FashionNTFType FashionNTFType_MIN = ADD_FASHION;
constexpr FashionNTFType FashionNTFType_MAX = DELBAG_FASHION;
constexpr int FashionNTFType_ARRAYSIZE = FashionNTFType_MAX + 1;

const std::string& FashionNTFType_Name(FashionNTFType value);
template<typename T>
inline const std::string& FashionNTFType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FashionNTFType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FashionNTFType_Name.");
  return FashionNTFType_Name(static_cast<FashionNTFType>(enum_t_value));
}
bool FashionNTFType_Parse(
    const std::string& name, FashionNTFType* value);
enum GuildSortType : int {
  GuildSortByLevel = 1,
  GuildSortByMemberCount = 2,
  GuildSortByName = 3,
  GuildSortByExp = 4,
  GuildSortByPrestige = 5
};
bool GuildSortType_IsValid(int value);
constexpr GuildSortType GuildSortType_MIN = GuildSortByLevel;
constexpr GuildSortType GuildSortType_MAX = GuildSortByPrestige;
constexpr int GuildSortType_ARRAYSIZE = GuildSortType_MAX + 1;

const std::string& GuildSortType_Name(GuildSortType value);
template<typename T>
inline const std::string& GuildSortType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GuildSortType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GuildSortType_Name.");
  return GuildSortType_Name(static_cast<GuildSortType>(enum_t_value));
}
bool GuildSortType_Parse(
    const std::string& name, GuildSortType* value);
enum GuildMemberFlag : int {
  SEND_FATIGUE = 1,
  RECV_FATIGUE = 2,
  RECVED_FATIGUE = 4,
  ONLINE = 8
};
bool GuildMemberFlag_IsValid(int value);
constexpr GuildMemberFlag GuildMemberFlag_MIN = SEND_FATIGUE;
constexpr GuildMemberFlag GuildMemberFlag_MAX = ONLINE;
constexpr int GuildMemberFlag_ARRAYSIZE = GuildMemberFlag_MAX + 1;

const std::string& GuildMemberFlag_Name(GuildMemberFlag value);
template<typename T>
inline const std::string& GuildMemberFlag_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GuildMemberFlag>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GuildMemberFlag_Name.");
  return GuildMemberFlag_Name(static_cast<GuildMemberFlag>(enum_t_value));
}
bool GuildMemberFlag_Parse(
    const std::string& name, GuildMemberFlag* value);
enum GuildLogType : int {
  GLog_Member = 1,
  GLog_CheckIn = 2,
  GLog_RedBonus = 3
};
bool GuildLogType_IsValid(int value);
constexpr GuildLogType GuildLogType_MIN = GLog_Member;
constexpr GuildLogType GuildLogType_MAX = GLog_RedBonus;
constexpr int GuildLogType_ARRAYSIZE = GuildLogType_MAX + 1;

const std::string& GuildLogType_Name(GuildLogType value);
template<typename T>
inline const std::string& GuildLogType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GuildLogType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GuildLogType_Name.");
  return GuildLogType_Name(static_cast<GuildLogType>(enum_t_value));
}
bool GuildLogType_Parse(
    const std::string& name, GuildLogType* value);
enum GuildLogEnum : int {
  GUILDLOG_MEMBER_START = 0,
  GuildLog_Join = 1,
  GuildLog_Leave = 2,
  GuildLog_ChangePosition = 3,
  GUILDLOG_MEMBER_END = 4,
  GUILDLOG_CHECKIN_START = 5,
  GUILDLOG_CHECKIN_END = 6,
  GUILDLOG_REDBONUS_START = 7,
  GUILDLOG_REDBONUS_END = 8,
  GuildLog_BossDps = 9
};
bool GuildLogEnum_IsValid(int value);
constexpr GuildLogEnum GuildLogEnum_MIN = GUILDLOG_MEMBER_START;
constexpr GuildLogEnum GuildLogEnum_MAX = GuildLog_BossDps;
constexpr int GuildLogEnum_ARRAYSIZE = GuildLogEnum_MAX + 1;

const std::string& GuildLogEnum_Name(GuildLogEnum value);
template<typename T>
inline const std::string& GuildLogEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GuildLogEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GuildLogEnum_Name.");
  return GuildLogEnum_Name(static_cast<GuildLogEnum>(enum_t_value));
}
bool GuildLogEnum_Parse(
    const std::string& name, GuildLogEnum* value);
enum GuildBonusType : int {
  GBONUS_LEVELUP = 1,
  GBONUS_CARDREWARD = 2,
  GBONUS_KILLDRAGON = 3,
  GBONUS_GUILDGOBLIN = 4,
  GBONUS_GUILDGOBLIN_LEVELUP = 5,
  GBONUS_CHECKIN = 6,
  GBONUS_TIANTIRANK = 7,
  GBONUS_KILLSTAGEDRAGON = 8,
  GBONUS_CHARGETIMES = 9,
  GBONUS_VIPLEVEL = 10,
  GBONUS_DRAWLOTTERY_TEN = 11,
  GBONUS_TITLE = 12,
  GBONUS_STRENGTHEN = 13,
  GBONUS_TOWER = 14,
  GBONUS_TIMEBONUS = 15,
  GBONUS_CHARGEPRIVILEGE = 16,
  GBONUS_PURCHASEFUND = 17,
  GBONUS_DRAGONJADEL_ALLLEVEL = 18,
  GBONUS_SKYARENA_FLOOR = 19,
  GBONUS_HORSE_QUALITY = 20,
  GBONUS_DRAGONNEST_SCENE = 21,
  GBONUS_GMF_RANK = 22,
  GBONUS_BOSSRUSH = 23,
  GBONUS_BUYIBSHOP = 24,
  GBONUS_MAYHEMRANK = 25,
  GBONUS_USETHREESUIT = 26,
  GBONUS_USEITEM = 27,
  GBONUS_MAX = 28
};
bool GuildBonusType_IsValid(int value);
constexpr GuildBonusType GuildBonusType_MIN = GBONUS_LEVELUP;
constexpr GuildBonusType GuildBonusType_MAX = GBONUS_MAX;
constexpr int GuildBonusType_ARRAYSIZE = GuildBonusType_MAX + 1;

const std::string& GuildBonusType_Name(GuildBonusType value);
template<typename T>
inline const std::string& GuildBonusType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GuildBonusType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GuildBonusType_Name.");
  return GuildBonusType_Name(static_cast<GuildBonusType>(enum_t_value));
}
bool GuildBonusType_Parse(
    const std::string& name, GuildBonusType* value);
enum BoxType : int {
  BOX_TYPE_NONE = 0,
  BOX_TYPE_GOLD = 3,
  BOX_TYPE_SILVER = 2,
  BOX_TYPE_COPPER = 1,
  BOX_TYPE_DIAMOND = 4
};
bool BoxType_IsValid(int value);
constexpr BoxType BoxType_MIN = BOX_TYPE_NONE;
constexpr BoxType BoxType_MAX = BOX_TYPE_DIAMOND;
constexpr int BoxType_ARRAYSIZE = BoxType_MAX + 1;

const std::string& BoxType_Name(BoxType value);
template<typename T>
inline const std::string& BoxType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BoxType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BoxType_Name.");
  return BoxType_Name(static_cast<BoxType>(enum_t_value));
}
bool BoxType_Parse(
    const std::string& name, BoxType* value);
enum FightGroupType : int {
  FightEnemy = 0,
  FightRole = 1,
  FightNeutral = 2,
  FightHostility = 3,
  FightDummy = 10
};
bool FightGroupType_IsValid(int value);
constexpr FightGroupType FightGroupType_MIN = FightEnemy;
constexpr FightGroupType FightGroupType_MAX = FightDummy;
constexpr int FightGroupType_ARRAYSIZE = FightGroupType_MAX + 1;

const std::string& FightGroupType_Name(FightGroupType value);
template<typename T>
inline const std::string& FightGroupType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FightGroupType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FightGroupType_Name.");
  return FightGroupType_Name(static_cast<FightGroupType>(enum_t_value));
}
bool FightGroupType_Parse(
    const std::string& name, FightGroupType* value);
enum XQTEState : int {
  QTE_None = 0,
  QTE_HitBackPresent = 1,
  QTE_HitBackStraight = 2,
  QTE_HitBackGetUp = 3,
  QTE_HitFlyPresent = 4,
  QTE_HitFlyLand = 5,
  QTE_HitFlyBounce = 6,
  QTE_HitFlyStraight = 7,
  QTE_HitFlyGetUp = 8,
  QTE_HitRollPresent = 9,
  QTE_HitRollStraight = 10,
  QTE_HitRollGetUp = 11,
  QTE_HitFreeze = 12
};
bool XQTEState_IsValid(int value);
constexpr XQTEState XQTEState_MIN = QTE_None;
constexpr XQTEState XQTEState_MAX = QTE_HitFreeze;
constexpr int XQTEState_ARRAYSIZE = XQTEState_MAX + 1;

const std::string& XQTEState_Name(XQTEState value);
template<typename T>
inline const std::string& XQTEState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, XQTEState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function XQTEState_Name.");
  return XQTEState_Name(static_cast<XQTEState>(enum_t_value));
}
bool XQTEState_Parse(
    const std::string& name, XQTEState* value);
enum SceneFinishState : int {
  SCENE_FINISH_NONE = 0,
  SCENE_FINISH_START = 1,
  SCENE_FINISH_PICK_ITEM = 2,
  SCENE_FINISH_SHOWRESULT = 3,
  SCENE_FINISH_DRAW_BOX = 4,
  SCENE_FINISH_END = 5
};
bool SceneFinishState_IsValid(int value);
constexpr SceneFinishState SceneFinishState_MIN = SCENE_FINISH_NONE;
constexpr SceneFinishState SceneFinishState_MAX = SCENE_FINISH_END;
constexpr int SceneFinishState_ARRAYSIZE = SceneFinishState_MAX + 1;

const std::string& SceneFinishState_Name(SceneFinishState value);
template<typename T>
inline const std::string& SceneFinishState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SceneFinishState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SceneFinishState_Name.");
  return SceneFinishState_Name(static_cast<SceneFinishState>(enum_t_value));
}
bool SceneFinishState_Parse(
    const std::string& name, SceneFinishState* value);
enum FishingState : int {
  LEAVE = 1,
  SITDOWN = 2,
  CAST = 3,
  WAIT = 4,
  PULL = 5
};
bool FishingState_IsValid(int value);
constexpr FishingState FishingState_MIN = LEAVE;
constexpr FishingState FishingState_MAX = PULL;
constexpr int FishingState_ARRAYSIZE = FishingState_MAX + 1;

const std::string& FishingState_Name(FishingState value);
template<typename T>
inline const std::string& FishingState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FishingState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FishingState_Name.");
  return FishingState_Name(static_cast<FishingState>(enum_t_value));
}
bool FishingState_Parse(
    const std::string& name, FishingState* value);
enum AuctionSortType : int {
  AUCTIONSORT_QUALITY_LESS = 1,
  AUCTIONSORT_QUALITY_GREATER = 2,
  AUCTIONSORT_LEVLE_LESS = 3,
  AUCTIONSORT_LEVEL_GREATER = 4,
  AUCTIONSORT_LEFTTIME_LESS = 5,
  AUCTIONSORT_LEFTTIME_GREATER = 6,
  AUCTIONSORT_BUYNOW_LESS = 7,
  AUCTIONSORT_BUYNOW_GREATER = 8,
  AUCTIONSORT_BIDDING_LESS = 9,
  AUCITONSORT_BIDDING_GREATER = 10,
  AUCTIONSORT_PERPRICE_LESS = 11,
  AUCTIONSORT_PERPRICE_GREATER = 12
};
bool AuctionSortType_IsValid(int value);
constexpr AuctionSortType AuctionSortType_MIN = AUCTIONSORT_QUALITY_LESS;
constexpr AuctionSortType AuctionSortType_MAX = AUCTIONSORT_PERPRICE_GREATER;
constexpr int AuctionSortType_ARRAYSIZE = AuctionSortType_MAX + 1;

const std::string& AuctionSortType_Name(AuctionSortType value);
template<typename T>
inline const std::string& AuctionSortType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AuctionSortType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AuctionSortType_Name.");
  return AuctionSortType_Name(static_cast<AuctionSortType>(enum_t_value));
}
bool AuctionSortType_Parse(
    const std::string& name, AuctionSortType* value);
enum AuctionAccountType : int {
  AUCTACCOUNT_SALE_FAIL = 1,
  AUCTACCOUNT_SALE_SUCCESS = 2,
  AUCTACCOUNT_BUY_FAIL = 3,
  AUCTACCOUNT_BUY_SUCCESS = 4
};
bool AuctionAccountType_IsValid(int value);
constexpr AuctionAccountType AuctionAccountType_MIN = AUCTACCOUNT_SALE_FAIL;
constexpr AuctionAccountType AuctionAccountType_MAX = AUCTACCOUNT_BUY_SUCCESS;
constexpr int AuctionAccountType_ARRAYSIZE = AuctionAccountType_MAX + 1;

const std::string& AuctionAccountType_Name(AuctionAccountType value);
template<typename T>
inline const std::string& AuctionAccountType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AuctionAccountType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AuctionAccountType_Name.");
  return AuctionAccountType_Name(static_cast<AuctionAccountType>(enum_t_value));
}
bool AuctionAccountType_Parse(
    const std::string& name, AuctionAccountType* value);
enum PetOP : int {
  PetFellow = 1,
  PetFight = 2,
  PetFeed = 3,
  PetTouch = 4,
  PetBorn = 5,
  PetUpdate = 6,
  PetRelease = 7,
  ExpandSeat = 8,
  PetExpTransfer = 9,
  useskillbook = 10,
  SetPetPairRide = 11,
  QueryPetPairRideInvite = 12,
  OffPetPairRide = 13,
  IgnorePetPairRideInvite = 14
};
bool PetOP_IsValid(int value);
constexpr PetOP PetOP_MIN = PetFellow;
constexpr PetOP PetOP_MAX = IgnorePetPairRideInvite;
constexpr int PetOP_ARRAYSIZE = PetOP_MAX + 1;

const std::string& PetOP_Name(PetOP value);
template<typename T>
inline const std::string& PetOP_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PetOP>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PetOP_Name.");
  return PetOP_Name(static_cast<PetOP>(enum_t_value));
}
bool PetOP_Parse(
    const std::string& name, PetOP* value);
enum CampID : int {
  CAMP_DRAGON = 1,
  CAMP_KNIGHT = 2,
  CAMP_ADVENTURER = 3
};
bool CampID_IsValid(int value);
constexpr CampID CampID_MIN = CAMP_DRAGON;
constexpr CampID CampID_MAX = CAMP_ADVENTURER;
constexpr int CampID_ARRAYSIZE = CampID_MAX + 1;

const std::string& CampID_Name(CampID value);
template<typename T>
inline const std::string& CampID_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CampID>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CampID_Name.");
  return CampID_Name(static_cast<CampID>(enum_t_value));
}
bool CampID_Parse(
    const std::string& name, CampID* value);
enum FortType : int {
  FORTTYPE_MAX = 1
};
bool FortType_IsValid(int value);
constexpr FortType FortType_MIN = FORTTYPE_MAX;
constexpr FortType FortType_MAX = FORTTYPE_MAX;
constexpr int FortType_ARRAYSIZE = FortType_MAX + 1;

const std::string& FortType_Name(FortType value);
template<typename T>
inline const std::string& FortType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FortType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FortType_Name.");
  return FortType_Name(static_cast<FortType>(enum_t_value));
}
bool FortType_Parse(
    const std::string& name, FortType* value);
enum FortStatus : int {
  FORTSTATUS_MAX = 1
};
bool FortStatus_IsValid(int value);
constexpr FortStatus FortStatus_MIN = FORTSTATUS_MAX;
constexpr FortStatus FortStatus_MAX = FORTSTATUS_MAX;
constexpr int FortStatus_ARRAYSIZE = FortStatus_MAX + 1;

const std::string& FortStatus_Name(FortStatus value);
template<typename T>
inline const std::string& FortStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FortStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FortStatus_Name.");
  return FortStatus_Name(static_cast<FortStatus>(enum_t_value));
}
bool FortStatus_Parse(
    const std::string& name, FortStatus* value);
enum AuctDBDataOperate : int {
  AUCTDBDATA_INSERT = 1,
  AUCTDBDATA_UPDATE = 2,
  AUCTDBDATA_DELETE = 3
};
bool AuctDBDataOperate_IsValid(int value);
constexpr AuctDBDataOperate AuctDBDataOperate_MIN = AUCTDBDATA_INSERT;
constexpr AuctDBDataOperate AuctDBDataOperate_MAX = AUCTDBDATA_DELETE;
constexpr int AuctDBDataOperate_ARRAYSIZE = AuctDBDataOperate_MAX + 1;

const std::string& AuctDBDataOperate_Name(AuctDBDataOperate value);
template<typename T>
inline const std::string& AuctDBDataOperate_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AuctDBDataOperate>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AuctDBDataOperate_Name.");
  return AuctDBDataOperate_Name(static_cast<AuctDBDataOperate>(enum_t_value));
}
bool AuctDBDataOperate_Parse(
    const std::string& name, AuctDBDataOperate* value);
enum CampTaskType : int {
  CAMPTASK_ITEM = 1,
  CAMPTASK_SCENE = 2,
  CAMPTASK_PATROL = 3,
  CAMPTASK_SPY = 4
};
bool CampTaskType_IsValid(int value);
constexpr CampTaskType CampTaskType_MIN = CAMPTASK_ITEM;
constexpr CampTaskType CampTaskType_MAX = CAMPTASK_SPY;
constexpr int CampTaskType_ARRAYSIZE = CampTaskType_MAX + 1;

const std::string& CampTaskType_Name(CampTaskType value);
template<typename T>
inline const std::string& CampTaskType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CampTaskType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CampTaskType_Name.");
  return CampTaskType_Name(static_cast<CampTaskType>(enum_t_value));
}
bool CampTaskType_Parse(
    const std::string& name, CampTaskType* value);
enum CampTaskStatus : int {
  CAMPTASK_GET = 1,
  CAMPTASK_VIEW = 2,
  CAMPTASK_FINISH = 3,
  CAMPTASK_REWARD = 4
};
bool CampTaskStatus_IsValid(int value);
constexpr CampTaskStatus CampTaskStatus_MIN = CAMPTASK_GET;
constexpr CampTaskStatus CampTaskStatus_MAX = CAMPTASK_REWARD;
constexpr int CampTaskStatus_ARRAYSIZE = CampTaskStatus_MAX + 1;

const std::string& CampTaskStatus_Name(CampTaskStatus value);
template<typename T>
inline const std::string& CampTaskStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CampTaskStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CampTaskStatus_Name.");
  return CampTaskStatus_Name(static_cast<CampTaskStatus>(enum_t_value));
}
bool CampTaskStatus_Parse(
    const std::string& name, CampTaskStatus* value);
enum AbyssFlameStage : int {
  ABYSS_NONE_FLAME = 1,
  ABYSS_ON_FLAME = 2,
  ABYSS_WIN_FLAME = 3
};
bool AbyssFlameStage_IsValid(int value);
constexpr AbyssFlameStage AbyssFlameStage_MIN = ABYSS_NONE_FLAME;
constexpr AbyssFlameStage AbyssFlameStage_MAX = ABYSS_WIN_FLAME;
constexpr int AbyssFlameStage_ARRAYSIZE = AbyssFlameStage_MAX + 1;

const std::string& AbyssFlameStage_Name(AbyssFlameStage value);
template<typename T>
inline const std::string& AbyssFlameStage_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AbyssFlameStage>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AbyssFlameStage_Name.");
  return AbyssFlameStage_Name(static_cast<AbyssFlameStage>(enum_t_value));
}
bool AbyssFlameStage_Parse(
    const std::string& name, AbyssFlameStage* value);
enum ExpBackType : int {
  EXPBACK_ABYSSS = 1,
  EXPBACK_NEST = 2,
  EXPBACK_CAMPTASK = 3
};
bool ExpBackType_IsValid(int value);
constexpr ExpBackType ExpBackType_MIN = EXPBACK_ABYSSS;
constexpr ExpBackType ExpBackType_MAX = EXPBACK_CAMPTASK;
constexpr int ExpBackType_ARRAYSIZE = ExpBackType_MAX + 1;

const std::string& ExpBackType_Name(ExpBackType value);
template<typename T>
inline const std::string& ExpBackType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ExpBackType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ExpBackType_Name.");
  return ExpBackType_Name(static_cast<ExpBackType>(enum_t_value));
}
bool ExpBackType_Parse(
    const std::string& name, ExpBackType* value);
enum LogDBType : int {
  LOG_DB_NORMAL = 0,
  LOG_DB_TENCENT = 1
};
bool LogDBType_IsValid(int value);
constexpr LogDBType LogDBType_MIN = LOG_DB_NORMAL;
constexpr LogDBType LogDBType_MAX = LOG_DB_TENCENT;
constexpr int LogDBType_ARRAYSIZE = LogDBType_MAX + 1;

const std::string& LogDBType_Name(LogDBType value);
template<typename T>
inline const std::string& LogDBType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LogDBType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LogDBType_Name.");
  return LogDBType_Name(static_cast<LogDBType>(enum_t_value));
}
bool LogDBType_Parse(
    const std::string& name, LogDBType* value);
enum buyextype : int {
  DIAMONE_BUY_DRAGONCOIN = 1,
  DIAMONE_BUY_GOLD = 2,
  DRAGONCOIN_BUY_GOLD = 3,
  DRAGON_BUY_FATIGUE = 4,
  DIAMOND_BUY_FATIGUE = 5,
  DRAGONCOIN_BUY_BLUEBIRD = 6,
  DIAMOND_EXCHANGE_DRAGONCOIN = 7
};
bool buyextype_IsValid(int value);
constexpr buyextype buyextype_MIN = DIAMONE_BUY_DRAGONCOIN;
constexpr buyextype buyextype_MAX = DIAMOND_EXCHANGE_DRAGONCOIN;
constexpr int buyextype_ARRAYSIZE = buyextype_MAX + 1;

const std::string& buyextype_Name(buyextype value);
template<typename T>
inline const std::string& buyextype_Name(T enum_t_value) {
  static_assert(::std::is_same<T, buyextype>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function buyextype_Name.");
  return buyextype_Name(static_cast<buyextype>(enum_t_value));
}
bool buyextype_Parse(
    const std::string& name, buyextype* value);
enum DesignationType : int {
  DESIGNATION_TYPE_COMMON = 1,
  DESIGNATION_TYPE_RAID = 2,
  DESIGNATION_TYPE_NEST = 3,
  DESIGNATION_TYPE_BATTLE = 4,
  DESIGNATION_TYPE_ACTIVITY = 5
};
bool DesignationType_IsValid(int value);
constexpr DesignationType DesignationType_MIN = DESIGNATION_TYPE_COMMON;
constexpr DesignationType DesignationType_MAX = DESIGNATION_TYPE_ACTIVITY;
constexpr int DesignationType_ARRAYSIZE = DesignationType_MAX + 1;

const std::string& DesignationType_Name(DesignationType value);
template<typename T>
inline const std::string& DesignationType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DesignationType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DesignationType_Name.");
  return DesignationType_Name(static_cast<DesignationType>(enum_t_value));
}
bool DesignationType_Parse(
    const std::string& name, DesignationType* value);
enum AchieveType : int {
  ACHIEVE_TYPE_COMMON = 1,
  ACHIEVE_TYPE_RAID = 2,
  ACHIEVE_TYPE_NEST = 3,
  ACHIEVE_TYPE_BATTLE = 4,
  ACHIEVE_TYPE_ACTIVITY = 5
};
bool AchieveType_IsValid(int value);
constexpr AchieveType AchieveType_MIN = ACHIEVE_TYPE_COMMON;
constexpr AchieveType AchieveType_MAX = ACHIEVE_TYPE_ACTIVITY;
constexpr int AchieveType_ARRAYSIZE = AchieveType_MAX + 1;

const std::string& AchieveType_Name(AchieveType value);
template<typename T>
inline const std::string& AchieveType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AchieveType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AchieveType_Name.");
  return AchieveType_Name(static_cast<AchieveType>(enum_t_value));
}
bool AchieveType_Parse(
    const std::string& name, AchieveType* value);
enum RewardStatus : int {
  REWARD_STATUS_CANNOT = 0,
  REWARD_STATUS_CAN = 1,
  REWARD_STATUS_GOT = 2
};
bool RewardStatus_IsValid(int value);
constexpr RewardStatus RewardStatus_MIN = REWARD_STATUS_CANNOT;
constexpr RewardStatus RewardStatus_MAX = REWARD_STATUS_GOT;
constexpr int RewardStatus_ARRAYSIZE = RewardStatus_MAX + 1;

const std::string& RewardStatus_Name(RewardStatus value);
template<typename T>
inline const std::string& RewardStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RewardStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RewardStatus_Name.");
  return RewardStatus_Name(static_cast<RewardStatus>(enum_t_value));
}
bool RewardStatus_Parse(
    const std::string& name, RewardStatus* value);
enum LevelSealButtonType : int {
  BUTTON_STATUS_NONE = 0,
  BUTTON_STATUS_LOCKED = 1,
  BUTTON_STATUS_UNLOCKED = 2
};
bool LevelSealButtonType_IsValid(int value);
constexpr LevelSealButtonType LevelSealButtonType_MIN = BUTTON_STATUS_NONE;
constexpr LevelSealButtonType LevelSealButtonType_MAX = BUTTON_STATUS_UNLOCKED;
constexpr int LevelSealButtonType_ARRAYSIZE = LevelSealButtonType_MAX + 1;

const std::string& LevelSealButtonType_Name(LevelSealButtonType value);
template<typename T>
inline const std::string& LevelSealButtonType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LevelSealButtonType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LevelSealButtonType_Name.");
  return LevelSealButtonType_Name(static_cast<LevelSealButtonType>(enum_t_value));
}
bool LevelSealButtonType_Parse(
    const std::string& name, LevelSealButtonType* value);
enum PlatType : int {
  PLAT_IOS = 0,
  PLAT_ANDROID = 1
};
bool PlatType_IsValid(int value);
constexpr PlatType PlatType_MIN = PLAT_IOS;
constexpr PlatType PlatType_MAX = PLAT_ANDROID;
constexpr int PlatType_ARRAYSIZE = PlatType_MAX + 1;

const std::string& PlatType_Name(PlatType value);
template<typename T>
inline const std::string& PlatType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlatType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlatType_Name.");
  return PlatType_Name(static_cast<PlatType>(enum_t_value));
}
bool PlatType_Parse(
    const std::string& name, PlatType* value);
enum GameAppType : int {
  GAME_APP_WECHAT = 1,
  GAME_APP_QQ = 2
};
bool GameAppType_IsValid(int value);
constexpr GameAppType GameAppType_MIN = GAME_APP_WECHAT;
constexpr GameAppType GameAppType_MAX = GAME_APP_QQ;
constexpr int GameAppType_ARRAYSIZE = GameAppType_MAX + 1;

const std::string& GameAppType_Name(GameAppType value);
template<typename T>
inline const std::string& GameAppType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GameAppType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GameAppType_Name.");
  return GameAppType_Name(static_cast<GameAppType>(enum_t_value));
}
bool GameAppType_Parse(
    const std::string& name, GameAppType* value);
enum LoginRewardState : int {
  LOGINRS_CANNOT = 1,
  LOGINRS_HAVEHOT = 2,
  LOGINRS_HAVE = 3
};
bool LoginRewardState_IsValid(int value);
constexpr LoginRewardState LoginRewardState_MIN = LOGINRS_CANNOT;
constexpr LoginRewardState LoginRewardState_MAX = LOGINRS_HAVE;
constexpr int LoginRewardState_ARRAYSIZE = LoginRewardState_MAX + 1;

const std::string& LoginRewardState_Name(LoginRewardState value);
template<typename T>
inline const std::string& LoginRewardState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LoginRewardState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LoginRewardState_Name.");
  return LoginRewardState_Name(static_cast<LoginRewardState>(enum_t_value));
}
bool LoginRewardState_Parse(
    const std::string& name, LoginRewardState* value);
enum PvpReqType : int {
  PVP_REQ_IN_MATCH = 1,
  PVP_REQ_OUT_MATCH = 2,
  PVP_REQ_BASE_DATA = 3,
  PVP_REQ_HISTORY_REC = 4,
  PVP_REQ_GET_WEEKREWARD = 5
};
bool PvpReqType_IsValid(int value);
constexpr PvpReqType PvpReqType_MIN = PVP_REQ_IN_MATCH;
constexpr PvpReqType PvpReqType_MAX = PVP_REQ_GET_WEEKREWARD;
constexpr int PvpReqType_ARRAYSIZE = PvpReqType_MAX + 1;

const std::string& PvpReqType_Name(PvpReqType value);
template<typename T>
inline const std::string& PvpReqType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PvpReqType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PvpReqType_Name.");
  return PvpReqType_Name(static_cast<PvpReqType>(enum_t_value));
}
bool PvpReqType_Parse(
    const std::string& name, PvpReqType* value);
enum FriendOpType : int {
  Friend_AgreeApply = 1,
  Friend_IgnoreApply = 2,
  Friend_FriendAll = 3,
  Friend_ApplyAll = 4,
  Friend_FriendAdd = 5,
  Friend_FriendDelete = 6,
  Friend_ApplyAdd = 7,
  Friend_ApplyDelete = 8,
  Friend_ReveiveGift = 9,
  Friend_SendGift = 10,
  Friend_TakeGift = 11,
  Friend_GiftInfo = 12
};
bool FriendOpType_IsValid(int value);
constexpr FriendOpType FriendOpType_MIN = Friend_AgreeApply;
constexpr FriendOpType FriendOpType_MAX = Friend_GiftInfo;
constexpr int FriendOpType_ARRAYSIZE = FriendOpType_MAX + 1;

const std::string& FriendOpType_Name(FriendOpType value);
template<typename T>
inline const std::string& FriendOpType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FriendOpType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FriendOpType_Name.");
  return FriendOpType_Name(static_cast<FriendOpType>(enum_t_value));
}
bool FriendOpType_Parse(
    const std::string& name, FriendOpType* value);
enum FriendGiftSend : int {
  FriendGift_SendNone = 0,
  FriendGift_Sended = 1
};
bool FriendGiftSend_IsValid(int value);
constexpr FriendGiftSend FriendGiftSend_MIN = FriendGift_SendNone;
constexpr FriendGiftSend FriendGiftSend_MAX = FriendGift_Sended;
constexpr int FriendGiftSend_ARRAYSIZE = FriendGiftSend_MAX + 1;

const std::string& FriendGiftSend_Name(FriendGiftSend value);
template<typename T>
inline const std::string& FriendGiftSend_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FriendGiftSend>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FriendGiftSend_Name.");
  return FriendGiftSend_Name(static_cast<FriendGiftSend>(enum_t_value));
}
bool FriendGiftSend_Parse(
    const std::string& name, FriendGiftSend* value);
enum FriendGiftReceive : int {
  FriendGift_ReceiveNone = 0,
  FriendGift_Received = 1,
  FriendGift_ReceiveTaken = 2
};
bool FriendGiftReceive_IsValid(int value);
constexpr FriendGiftReceive FriendGiftReceive_MIN = FriendGift_ReceiveNone;
constexpr FriendGiftReceive FriendGiftReceive_MAX = FriendGift_ReceiveTaken;
constexpr int FriendGiftReceive_ARRAYSIZE = FriendGiftReceive_MAX + 1;

const std::string& FriendGiftReceive_Name(FriendGiftReceive value);
template<typename T>
inline const std::string& FriendGiftReceive_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FriendGiftReceive>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FriendGiftReceive_Name.");
  return FriendGiftReceive_Name(static_cast<FriendGiftReceive>(enum_t_value));
}
bool FriendGiftReceive_Parse(
    const std::string& name, FriendGiftReceive* value);
enum EnterSceneType : int {
  ENTER_SCENE_SELECT_ROLE = 1,
  ENTER_SCENE_SWITCH = 2
};
bool EnterSceneType_IsValid(int value);
constexpr EnterSceneType EnterSceneType_MIN = ENTER_SCENE_SELECT_ROLE;
constexpr EnterSceneType EnterSceneType_MAX = ENTER_SCENE_SWITCH;
constexpr int EnterSceneType_ARRAYSIZE = EnterSceneType_MAX + 1;

const std::string& EnterSceneType_Name(EnterSceneType value);
template<typename T>
inline const std::string& EnterSceneType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EnterSceneType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EnterSceneType_Name.");
  return EnterSceneType_Name(static_cast<EnterSceneType>(enum_t_value));
}
bool EnterSceneType_Parse(
    const std::string& name, EnterSceneType* value);
enum RoleDataReadType : int {
  ROLE_DATA_READ_SELECT_ROLE = 1,
  ROLE_DATA_READ_IDIP = 2
};
bool RoleDataReadType_IsValid(int value);
constexpr RoleDataReadType RoleDataReadType_MIN = ROLE_DATA_READ_SELECT_ROLE;
constexpr RoleDataReadType RoleDataReadType_MAX = ROLE_DATA_READ_IDIP;
constexpr int RoleDataReadType_ARRAYSIZE = RoleDataReadType_MAX + 1;

const std::string& RoleDataReadType_Name(RoleDataReadType value);
template<typename T>
inline const std::string& RoleDataReadType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RoleDataReadType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RoleDataReadType_Name.");
  return RoleDataReadType_Name(static_cast<RoleDataReadType>(enum_t_value));
}
bool RoleDataReadType_Parse(
    const std::string& name, RoleDataReadType* value);
enum LeaveSceneType : int {
  LEAVE_SCENE_LOGOUT = 1,
  LEAVE_SCENE_SWITCH = 2
};
bool LeaveSceneType_IsValid(int value);
constexpr LeaveSceneType LeaveSceneType_MIN = LEAVE_SCENE_LOGOUT;
constexpr LeaveSceneType LeaveSceneType_MAX = LEAVE_SCENE_SWITCH;
constexpr int LeaveSceneType_ARRAYSIZE = LeaveSceneType_MAX + 1;

const std::string& LeaveSceneType_Name(LeaveSceneType value);
template<typename T>
inline const std::string& LeaveSceneType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LeaveSceneType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LeaveSceneType_Name.");
  return LeaveSceneType_Name(static_cast<LeaveSceneType>(enum_t_value));
}
bool LeaveSceneType_Parse(
    const std::string& name, LeaveSceneType* value);
enum InvHReqType : int {
  INVH_REQ_UNF_LIST = 1,
  INVH_UNF_IGNORE_ALL = 2,
  INVH_REFUSE_FORNOW = 3
};
bool InvHReqType_IsValid(int value);
constexpr InvHReqType InvHReqType_MIN = INVH_REQ_UNF_LIST;
constexpr InvHReqType InvHReqType_MAX = INVH_REFUSE_FORNOW;
constexpr int InvHReqType_ARRAYSIZE = InvHReqType_MAX + 1;

const std::string& InvHReqType_Name(InvHReqType value);
template<typename T>
inline const std::string& InvHReqType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, InvHReqType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function InvHReqType_Name.");
  return InvHReqType_Name(static_cast<InvHReqType>(enum_t_value));
}
bool InvHReqType_Parse(
    const std::string& name, InvHReqType* value);
enum MulActivityTimeState : int {
  MULACTIVITY_BEfOREOPEN = 1,
  MULACTIVITY_RUNNING = 2,
  MULACTIVITY_END = 3,
  MULACTIVITY_UNOPEN_TODAY = 4
};
bool MulActivityTimeState_IsValid(int value);
constexpr MulActivityTimeState MulActivityTimeState_MIN = MULACTIVITY_BEfOREOPEN;
constexpr MulActivityTimeState MulActivityTimeState_MAX = MULACTIVITY_UNOPEN_TODAY;
constexpr int MulActivityTimeState_ARRAYSIZE = MulActivityTimeState_MAX + 1;

const std::string& MulActivityTimeState_Name(MulActivityTimeState value);
template<typename T>
inline const std::string& MulActivityTimeState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MulActivityTimeState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MulActivityTimeState_Name.");
  return MulActivityTimeState_Name(static_cast<MulActivityTimeState>(enum_t_value));
}
bool MulActivityTimeState_Parse(
    const std::string& name, MulActivityTimeState* value);
enum XSkillSlot : int {
  Normal_Attack = 0,
  Dash_Attack = 1,
  Skill_1_Attack = 2,
  Skill_2_Attack = 3,
  Skill_3_Attack = 4,
  Skill_4_Attack = 5,
  Skill_5_Attack = 6,
  Skill_1_Buff = 7,
  Skill_2_Buff = 8,
  Ultra_Attack = 9,
  Attack_Max = 10
};
bool XSkillSlot_IsValid(int value);
constexpr XSkillSlot XSkillSlot_MIN = Normal_Attack;
constexpr XSkillSlot XSkillSlot_MAX = Attack_Max;
constexpr int XSkillSlot_ARRAYSIZE = XSkillSlot_MAX + 1;

const std::string& XSkillSlot_Name(XSkillSlot value);
template<typename T>
inline const std::string& XSkillSlot_Name(T enum_t_value) {
  static_assert(::std::is_same<T, XSkillSlot>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function XSkillSlot_Name.");
  return XSkillSlot_Name(static_cast<XSkillSlot>(enum_t_value));
}
bool XSkillSlot_Parse(
    const std::string& name, XSkillSlot* value);
enum LiveType : int {
  LIVE_RECOMMEND = 1,
  LIVE_PVP = 2,
  LIVE_NEST = 3,
  LIVE_PROTECTCAPTAIN = 4,
  LIVE_GUILDBATTLE = 5,
  LIVE_DRAGON = 6,
  LIVE_FRIEND = 7,
  LIVE_GUILD = 8,
  LIVE_FRIENDANDGUILD = 9,
  LIVE_HEROBATTLE = 10,
  LIVE_LEAGUEBATTLE = 11,
  LIVE_PVP2 = 12,
  LIVE_CUSTOMPK = 13,
  LIVE_MAX = 14
};
bool LiveType_IsValid(int value);
constexpr LiveType LiveType_MIN = LIVE_RECOMMEND;
constexpr LiveType LiveType_MAX = LIVE_MAX;
constexpr int LiveType_ARRAYSIZE = LiveType_MAX + 1;

const std::string& LiveType_Name(LiveType value);
template<typename T>
inline const std::string& LiveType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LiveType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LiveType_Name.");
  return LiveType_Name(static_cast<LiveType>(enum_t_value));
}
bool LiveType_Parse(
    const std::string& name, LiveType* value);
enum BossRushReqStatus : int {
  BOSSRUSH_RESULT_WIN = 1,
  BOSSRUSH_RESULT_FAILED = 2,
  BOSSRUSH_REQ_BASEDATA = 3,
  BOSSRUSH_REQ_REFRESH = 4,
  BOSSRUSH_REQ_APPEARANCE = 5,
  BOSSRUSH_REQ_LEFTCOUNT = 6,
  BOSSRUSH_REQ_CONTINUE = 7
};
bool BossRushReqStatus_IsValid(int value);
constexpr BossRushReqStatus BossRushReqStatus_MIN = BOSSRUSH_RESULT_WIN;
constexpr BossRushReqStatus BossRushReqStatus_MAX = BOSSRUSH_REQ_CONTINUE;
constexpr int BossRushReqStatus_ARRAYSIZE = BossRushReqStatus_MAX + 1;

const std::string& BossRushReqStatus_Name(BossRushReqStatus value);
template<typename T>
inline const std::string& BossRushReqStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BossRushReqStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BossRushReqStatus_Name.");
  return BossRushReqStatus_Name(static_cast<BossRushReqStatus>(enum_t_value));
}
bool BossRushReqStatus_Parse(
    const std::string& name, BossRushReqStatus* value);
enum StopMatchReason : int {
  STOPMATCH_NONE = 1,
  STOPMATCH_LEAVESCENE = 2,
  STOPMATCH_ENTER_TIANTI = 3,
  STOPMATCH_ENTER_BOWEIDUIZ = 4
};
bool StopMatchReason_IsValid(int value);
constexpr StopMatchReason StopMatchReason_MIN = STOPMATCH_NONE;
constexpr StopMatchReason StopMatchReason_MAX = STOPMATCH_ENTER_BOWEIDUIZ;
constexpr int StopMatchReason_ARRAYSIZE = StopMatchReason_MAX + 1;

const std::string& StopMatchReason_Name(StopMatchReason value);
template<typename T>
inline const std::string& StopMatchReason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StopMatchReason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StopMatchReason_Name.");
  return StopMatchReason_Name(static_cast<StopMatchReason>(enum_t_value));
}
bool StopMatchReason_Parse(
    const std::string& name, StopMatchReason* value);
enum GuildMatchFightState : int {
  GUILD_MF_NONE = 1,
  GUILD_MF_WAITING = 2,
  GUILD_MF_REFUSE = 3,
  GUILD_MF_LEAVE = 4,
  GUILD_MF_FIGHTING = 5,
  GUILD_MF_FAILED = 6,
  GUILD_MF_WIN = 7,
  GUILD_MF_ERR = 100
};
bool GuildMatchFightState_IsValid(int value);
constexpr GuildMatchFightState GuildMatchFightState_MIN = GUILD_MF_NONE;
constexpr GuildMatchFightState GuildMatchFightState_MAX = GUILD_MF_ERR;
constexpr int GuildMatchFightState_ARRAYSIZE = GuildMatchFightState_MAX + 1;

const std::string& GuildMatchFightState_Name(GuildMatchFightState value);
template<typename T>
inline const std::string& GuildMatchFightState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GuildMatchFightState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GuildMatchFightState_Name.");
  return GuildMatchFightState_Name(static_cast<GuildMatchFightState>(enum_t_value));
}
bool GuildMatchFightState_Parse(
    const std::string& name, GuildMatchFightState* value);
enum TeamInvRoleState : int {
  TIRS_IN_OTHER_TEAM = 1,
  TIRS_IN_MY_TEAM = 2,
  TIRS_IN_BATTLE = 3,
  TIRS_NORMAL = 4,
  TIRS_NOT_OPEN = 5,
  TIRS_COUNT_LESS = 6,
  TIRS_FATIGUE_LESS = 7
};
bool TeamInvRoleState_IsValid(int value);
constexpr TeamInvRoleState TeamInvRoleState_MIN = TIRS_IN_OTHER_TEAM;
constexpr TeamInvRoleState TeamInvRoleState_MAX = TIRS_FATIGUE_LESS;
constexpr int TeamInvRoleState_ARRAYSIZE = TeamInvRoleState_MAX + 1;

const std::string& TeamInvRoleState_Name(TeamInvRoleState value);
template<typename T>
inline const std::string& TeamInvRoleState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TeamInvRoleState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TeamInvRoleState_Name.");
  return TeamInvRoleState_Name(static_cast<TeamInvRoleState>(enum_t_value));
}
bool TeamInvRoleState_Parse(
    const std::string& name, TeamInvRoleState* value);
enum ReadAccountDataType : int {
  READ_ACCOUNT_DATA_LOGIN = 1,
  READ_ACCOUNT_DATA_RETURN_SELECT_ROLE = 2,
  READ_ACCOUNT_DATA_IDIP = 3
};
bool ReadAccountDataType_IsValid(int value);
constexpr ReadAccountDataType ReadAccountDataType_MIN = READ_ACCOUNT_DATA_LOGIN;
constexpr ReadAccountDataType ReadAccountDataType_MAX = READ_ACCOUNT_DATA_IDIP;
constexpr int ReadAccountDataType_ARRAYSIZE = ReadAccountDataType_MAX + 1;

const std::string& ReadAccountDataType_Name(ReadAccountDataType value);
template<typename T>
inline const std::string& ReadAccountDataType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ReadAccountDataType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ReadAccountDataType_Name.");
  return ReadAccountDataType_Name(static_cast<ReadAccountDataType>(enum_t_value));
}
bool ReadAccountDataType_Parse(
    const std::string& name, ReadAccountDataType* value);
enum LogoutType : int {
  LOGOUT_ACCOUNT_NORMAL = 1,
  LOGOUT_RELOGIN_KICK_ACCOUNT = 2,
  LOGOUT_IDIP_KICK_ACCOUNT = 3,
  LOGOUT_RETURN_SELECT_ROLE = 4,
  LOGOUT_CHANGEPROFESSION = 5
};
bool LogoutType_IsValid(int value);
constexpr LogoutType LogoutType_MIN = LOGOUT_ACCOUNT_NORMAL;
constexpr LogoutType LogoutType_MAX = LOGOUT_CHANGEPROFESSION;
constexpr int LogoutType_ARRAYSIZE = LogoutType_MAX + 1;

const std::string& LogoutType_Name(LogoutType value);
template<typename T>
inline const std::string& LogoutType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LogoutType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LogoutType_Name.");
  return LogoutType_Name(static_cast<LogoutType>(enum_t_value));
}
bool LogoutType_Parse(
    const std::string& name, LogoutType* value);
enum MailOpType : int {
  MAIL_OP_ADD = 1,
  MAIL_OP_UPDATE = 2,
  MAIL_OP_DELETE = 3,
  MAIL_OP_DELETE_ALL = 4
};
bool MailOpType_IsValid(int value);
constexpr MailOpType MailOpType_MIN = MAIL_OP_ADD;
constexpr MailOpType MailOpType_MAX = MAIL_OP_DELETE_ALL;
constexpr int MailOpType_ARRAYSIZE = MailOpType_MAX + 1;

const std::string& MailOpType_Name(MailOpType value);
template<typename T>
inline const std::string& MailOpType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MailOpType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MailOpType_Name.");
  return MailOpType_Name(static_cast<MailOpType>(enum_t_value));
}
bool MailOpType_Parse(
    const std::string& name, MailOpType* value);
enum WorldBossState : int {
  WorldBoss_BeginPre = 0,
  WorldBoss_Begin = 1,
  WorldBoss_Going = 2,
  WorldBoss_WaitEnd = 3,
  WorldBoss_End = 4
};
bool WorldBossState_IsValid(int value);
constexpr WorldBossState WorldBossState_MIN = WorldBoss_BeginPre;
constexpr WorldBossState WorldBossState_MAX = WorldBoss_End;
constexpr int WorldBossState_ARRAYSIZE = WorldBossState_MAX + 1;

const std::string& WorldBossState_Name(WorldBossState value);
template<typename T>
inline const std::string& WorldBossState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WorldBossState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WorldBossState_Name.");
  return WorldBossState_Name(static_cast<WorldBossState>(enum_t_value));
}
bool WorldBossState_Parse(
    const std::string& name, WorldBossState* value);
enum GuildArenaState : int {
  GUILD_ARENA_NOT_BEGIN = 1,
  GUILD_ARENA_BEGIN = 2,
  GUILD_ARENA_BATTLE_ONE = 3,
  GUILD_ARENA_BATTLE_TWO = 4,
  GUILD_ARENA_BATTLE_FINAL = 5,
  GUILD_ARENA_END = 6
};
bool GuildArenaState_IsValid(int value);
constexpr GuildArenaState GuildArenaState_MIN = GUILD_ARENA_NOT_BEGIN;
constexpr GuildArenaState GuildArenaState_MAX = GUILD_ARENA_END;
constexpr int GuildArenaState_ARRAYSIZE = GuildArenaState_MAX + 1;

const std::string& GuildArenaState_Name(GuildArenaState value);
template<typename T>
inline const std::string& GuildArenaState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GuildArenaState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GuildArenaState_Name.");
  return GuildArenaState_Name(static_cast<GuildArenaState>(enum_t_value));
}
bool GuildArenaState_Parse(
    const std::string& name, GuildArenaState* value);
enum GMFFailReason : int {
  GMF_FAIL_NONE = 0,
  GMF_FAIL_DIE = 1,
  GMF_FAIL_TIMEOVER = 2,
  GMF_FAIL_QUIT = 3,
  GMF_FAIL_REFRESE = 4
};
bool GMFFailReason_IsValid(int value);
constexpr GMFFailReason GMFFailReason_MIN = GMF_FAIL_NONE;
constexpr GMFFailReason GMFFailReason_MAX = GMF_FAIL_REFRESE;
constexpr int GMFFailReason_ARRAYSIZE = GMFFailReason_MAX + 1;

const std::string& GMFFailReason_Name(GMFFailReason value);
template<typename T>
inline const std::string& GMFFailReason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GMFFailReason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GMFFailReason_Name.");
  return GMFFailReason_Name(static_cast<GMFFailReason>(enum_t_value));
}
bool GMFFailReason_Parse(
    const std::string& name, GMFFailReason* value);
enum PVP_ONEGAMEEND_REASON : int {
  PVP_OGE_LEADER_DIE = 1,
  PVP_OGE_LEADER_QUIT = 2,
  PVP_OGE_TIMELIMIT = 3,
  PVP_OGE_ROLE_QUIT = 4
};
bool PVP_ONEGAMEEND_REASON_IsValid(int value);
constexpr PVP_ONEGAMEEND_REASON PVP_ONEGAMEEND_REASON_MIN = PVP_OGE_LEADER_DIE;
constexpr PVP_ONEGAMEEND_REASON PVP_ONEGAMEEND_REASON_MAX = PVP_OGE_ROLE_QUIT;
constexpr int PVP_ONEGAMEEND_REASON_ARRAYSIZE = PVP_ONEGAMEEND_REASON_MAX + 1;

const std::string& PVP_ONEGAMEEND_REASON_Name(PVP_ONEGAMEEND_REASON value);
template<typename T>
inline const std::string& PVP_ONEGAMEEND_REASON_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PVP_ONEGAMEEND_REASON>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PVP_ONEGAMEEND_REASON_Name.");
  return PVP_ONEGAMEEND_REASON_Name(static_cast<PVP_ONEGAMEEND_REASON>(enum_t_value));
}
bool PVP_ONEGAMEEND_REASON_Parse(
    const std::string& name, PVP_ONEGAMEEND_REASON* value);
enum SynsMsType : int {
  SynsGuild = 1,
  SynsTeam = 2
};
bool SynsMsType_IsValid(int value);
constexpr SynsMsType SynsMsType_MIN = SynsGuild;
constexpr SynsMsType SynsMsType_MAX = SynsTeam;
constexpr int SynsMsType_ARRAYSIZE = SynsMsType_MAX + 1;

const std::string& SynsMsType_Name(SynsMsType value);
template<typename T>
inline const std::string& SynsMsType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SynsMsType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SynsMsType_Name.");
  return SynsMsType_Name(static_cast<SynsMsType>(enum_t_value));
}
bool SynsMsType_Parse(
    const std::string& name, SynsMsType* value);
enum SynsMsSubType : int {
  SynsCreate = 1,
  SynsDestory = 2,
  SynsAdd = 3,
  SynsDel = 4,
  SynsLead = 5,
  SynsLevel = 6,
  SynsIcon = 7,
  SynAddExp = 8,
  SynSetTime = 9
};
bool SynsMsSubType_IsValid(int value);
constexpr SynsMsSubType SynsMsSubType_MIN = SynsCreate;
constexpr SynsMsSubType SynsMsSubType_MAX = SynSetTime;
constexpr int SynsMsSubType_ARRAYSIZE = SynsMsSubType_MAX + 1;

const std::string& SynsMsSubType_Name(SynsMsSubType value);
template<typename T>
inline const std::string& SynsMsSubType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SynsMsSubType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SynsMsSubType_Name.");
  return SynsMsSubType_Name(static_cast<SynsMsSubType>(enum_t_value));
}
bool SynsMsSubType_Parse(
    const std::string& name, SynsMsSubType* value);
enum NoticeType : int {
  Notice_Role = 1,
  Notice_Team = 2,
  Notice_Guild = 3,
  Notice_World = 4,
  Notice_Partner = 5,
  Notice_Server = 6
};
bool NoticeType_IsValid(int value);
constexpr NoticeType NoticeType_MIN = Notice_Role;
constexpr NoticeType NoticeType_MAX = Notice_Server;
constexpr int NoticeType_ARRAYSIZE = NoticeType_MAX + 1;

const std::string& NoticeType_Name(NoticeType value);
template<typename T>
inline const std::string& NoticeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NoticeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NoticeType_Name.");
  return NoticeType_Name(static_cast<NoticeType>(enum_t_value));
}
bool NoticeType_Parse(
    const std::string& name, NoticeType* value);
enum MSGiveItemType : int {
  MSItem_FriendGift = 1
};
bool MSGiveItemType_IsValid(int value);
constexpr MSGiveItemType MSGiveItemType_MIN = MSItem_FriendGift;
constexpr MSGiveItemType MSGiveItemType_MAX = MSItem_FriendGift;
constexpr int MSGiveItemType_ARRAYSIZE = MSGiveItemType_MAX + 1;

const std::string& MSGiveItemType_Name(MSGiveItemType value);
template<typename T>
inline const std::string& MSGiveItemType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MSGiveItemType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MSGiveItemType_Name.");
  return MSGiveItemType_Name(static_cast<MSGiveItemType>(enum_t_value));
}
bool MSGiveItemType_Parse(
    const std::string& name, MSGiveItemType* value);
enum RoleState : int {
  Logoff = 0,
  LoadScene = 1,
  InHall = 2,
  InBattle = 3
};
bool RoleState_IsValid(int value);
constexpr RoleState RoleState_MIN = Logoff;
constexpr RoleState RoleState_MAX = InBattle;
constexpr int RoleState_ARRAYSIZE = RoleState_MAX + 1;

const std::string& RoleState_Name(RoleState value);
template<typename T>
inline const std::string& RoleState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RoleState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RoleState_Name.");
  return RoleState_Name(static_cast<RoleState>(enum_t_value));
}
bool RoleState_Parse(
    const std::string& name, RoleState* value);
enum SyncTeamM2C : int {
  STM2C_CREATE_TEAM = 1,
  STM2C_ADD_MEMBER = 2,
  STM2C_DEL_MEMBER = 3,
  STM2C_ALL_DATA = 4,
  STM2C_TEAM_LIST = 5,
  STM2C_DESTROY = 6,
  STM2C_GETEXTRADATA = 7,
  STM2C_RESETCOST = 8,
  STM2C_TS_DISCONNECTED = 9
};
bool SyncTeamM2C_IsValid(int value);
constexpr SyncTeamM2C SyncTeamM2C_MIN = STM2C_CREATE_TEAM;
constexpr SyncTeamM2C SyncTeamM2C_MAX = STM2C_TS_DISCONNECTED;
constexpr int SyncTeamM2C_ARRAYSIZE = SyncTeamM2C_MAX + 1;

const std::string& SyncTeamM2C_Name(SyncTeamM2C value);
template<typename T>
inline const std::string& SyncTeamM2C_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SyncTeamM2C>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SyncTeamM2C_Name.");
  return SyncTeamM2C_Name(static_cast<SyncTeamM2C>(enum_t_value));
}
bool SyncTeamM2C_Parse(
    const std::string& name, SyncTeamM2C* value);
enum PayCardType : int {
  WEEK_CARD = 1,
  MONTH_CARD = 2
};
bool PayCardType_IsValid(int value);
constexpr PayCardType PayCardType_MIN = WEEK_CARD;
constexpr PayCardType PayCardType_MAX = MONTH_CARD;
constexpr int PayCardType_ARRAYSIZE = PayCardType_MAX + 1;

const std::string& PayCardType_Name(PayCardType value);
template<typename T>
inline const std::string& PayCardType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PayCardType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PayCardType_Name.");
  return PayCardType_Name(static_cast<PayCardType>(enum_t_value));
}
bool PayCardType_Parse(
    const std::string& name, PayCardType* value);
enum PayParamType : int {
  PAY_PARAM_NONE = 0,
  PAY_PARAM_LIST = 1,
  PAY_PARAM_AILEEN = 2,
  PAY_PARAM_CARD = 3,
  PAY_PARAM_FIRSTAWARD = 4,
  PAY_PARAM_GROWTH_FUND = 5,
  PAY_PARAM_MEMBER = 6
};
bool PayParamType_IsValid(int value);
constexpr PayParamType PayParamType_MIN = PAY_PARAM_NONE;
constexpr PayParamType PayParamType_MAX = PAY_PARAM_MEMBER;
constexpr int PayParamType_ARRAYSIZE = PayParamType_MAX + 1;

const std::string& PayParamType_Name(PayParamType value);
template<typename T>
inline const std::string& PayParamType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PayParamType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PayParamType_Name.");
  return PayParamType_Name(static_cast<PayParamType>(enum_t_value));
}
bool PayParamType_Parse(
    const std::string& name, PayParamType* value);
enum PayButtonStatus : int {
  PAY_BUTTON_NONE = 0,
  PAY_BUTTON_OPEN = 1,
  PAY_BUTTON_CLICK = 2
};
bool PayButtonStatus_IsValid(int value);
constexpr PayButtonStatus PayButtonStatus_MIN = PAY_BUTTON_NONE;
constexpr PayButtonStatus PayButtonStatus_MAX = PAY_BUTTON_CLICK;
constexpr int PayButtonStatus_ARRAYSIZE = PayButtonStatus_MAX + 1;

const std::string& PayButtonStatus_Name(PayButtonStatus value);
template<typename T>
inline const std::string& PayButtonStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PayButtonStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PayButtonStatus_Name.");
  return PayButtonStatus_Name(static_cast<PayButtonStatus>(enum_t_value));
}
bool PayButtonStatus_Parse(
    const std::string& name, PayButtonStatus* value);
enum MSUseSumamryType : int {
  MSUS_GET = 1,
  MSUS_FREE = 2
};
bool MSUseSumamryType_IsValid(int value);
constexpr MSUseSumamryType MSUseSumamryType_MIN = MSUS_GET;
constexpr MSUseSumamryType MSUseSumamryType_MAX = MSUS_FREE;
constexpr int MSUseSumamryType_ARRAYSIZE = MSUseSumamryType_MAX + 1;

const std::string& MSUseSumamryType_Name(MSUseSumamryType value);
template<typename T>
inline const std::string& MSUseSumamryType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MSUseSumamryType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MSUseSumamryType_Name.");
  return MSUseSumamryType_Name(static_cast<MSUseSumamryType>(enum_t_value));
}
bool MSUseSumamryType_Parse(
    const std::string& name, MSUseSumamryType* value);
enum TeamEventG2M : int {
  TEAM_EVENT_BUYCOUNT = 1
};
bool TeamEventG2M_IsValid(int value);
constexpr TeamEventG2M TeamEventG2M_MIN = TEAM_EVENT_BUYCOUNT;
constexpr TeamEventG2M TeamEventG2M_MAX = TEAM_EVENT_BUYCOUNT;
constexpr int TeamEventG2M_ARRAYSIZE = TeamEventG2M_MAX + 1;

const std::string& TeamEventG2M_Name(TeamEventG2M value);
template<typename T>
inline const std::string& TeamEventG2M_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TeamEventG2M>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TeamEventG2M_Name.");
  return TeamEventG2M_Name(static_cast<TeamEventG2M>(enum_t_value));
}
bool TeamEventG2M_Parse(
    const std::string& name, TeamEventG2M* value);
enum PkReqType : int {
  PKREQ_ADDPK = 1,
  PKREQ_REMOVEPK = 2,
  PKREQ_ALLINFO = 3,
  PKREQ_FETCHPOINTREWARD = 4
};
bool PkReqType_IsValid(int value);
constexpr PkReqType PkReqType_MIN = PKREQ_ADDPK;
constexpr PkReqType PkReqType_MAX = PKREQ_FETCHPOINTREWARD;
constexpr int PkReqType_ARRAYSIZE = PkReqType_MAX + 1;

const std::string& PkReqType_Name(PkReqType value);
template<typename T>
inline const std::string& PkReqType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PkReqType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PkReqType_Name.");
  return PkReqType_Name(static_cast<PkReqType>(enum_t_value));
}
bool PkReqType_Parse(
    const std::string& name, PkReqType* value);
enum AuctionReqType : int {
  AUCTION_ONSALE = 1,
  AUCTION_OUTSALE = 2,
  AUCTION_BUYNOW = 3
};
bool AuctionReqType_IsValid(int value);
constexpr AuctionReqType AuctionReqType_MIN = AUCTION_ONSALE;
constexpr AuctionReqType AuctionReqType_MAX = AUCTION_BUYNOW;
constexpr int AuctionReqType_ARRAYSIZE = AuctionReqType_MAX + 1;

const std::string& AuctionReqType_Name(AuctionReqType value);
template<typename T>
inline const std::string& AuctionReqType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AuctionReqType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AuctionReqType_Name.");
  return AuctionReqType_Name(static_cast<AuctionReqType>(enum_t_value));
}
bool AuctionReqType_Parse(
    const std::string& name, AuctionReqType* value);
enum PunishType : int {
  PUNISH_NONE = 0,
  PUNISH_USER_LOGIN = 1,
  PUNISH_USER_CHAT = 2,
  PUNISH_USER_TEMP = 3,
  PUNISH_USER_WORLDBOSS_RANK = 4,
  PUNISH_USER_ROLE_GUILDBOSS = 5,
  PUNISH_USER_PK_RANK = 6,
  PUNISH_USER_ARENA_RANK = 7,
  PUNISH_USER_TOWER = 8,
  PUNISH_USER_FLOWER_RANK = 9,
  PUNISH_USER_GUILD_RANK = 10,
  PUNISH_USER_GUILDBOSS_RANK = 11,
  PUNISH_USER_ZERO_PROFIT = 12,
  PUNISH_USER_DAILY_PLAY = 13,
  PUNISH_USER_MULTI_ACTIVITY = 14,
  PUNISH_USER_HG = 15
};
bool PunishType_IsValid(int value);
constexpr PunishType PunishType_MIN = PUNISH_NONE;
constexpr PunishType PunishType_MAX = PUNISH_USER_HG;
constexpr int PunishType_ARRAYSIZE = PunishType_MAX + 1;

const std::string& PunishType_Name(PunishType value);
template<typename T>
inline const std::string& PunishType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PunishType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PunishType_Name.");
  return PunishType_Name(static_cast<PunishType>(enum_t_value));
}
bool PunishType_Parse(
    const std::string& name, PunishType* value);
enum PunishDataType : int {
  PUNISH_DATA_UPATE = 1,
  PUNISH_DATA_DELETE = 2
};
bool PunishDataType_IsValid(int value);
constexpr PunishDataType PunishDataType_MIN = PUNISH_DATA_UPATE;
constexpr PunishDataType PunishDataType_MAX = PUNISH_DATA_DELETE;
constexpr int PunishDataType_ARRAYSIZE = PunishDataType_MAX + 1;

const std::string& PunishDataType_Name(PunishDataType value);
template<typename T>
inline const std::string& PunishDataType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PunishDataType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PunishDataType_Name.");
  return PunishDataType_Name(static_cast<PunishDataType>(enum_t_value));
}
bool PunishDataType_Parse(
    const std::string& name, PunishDataType* value);
enum ServerTag : int {
  SERVER_TAG_NORMAL = 1,
  SERVER_TAG_IOS_AUDIT = 2
};
bool ServerTag_IsValid(int value);
constexpr ServerTag ServerTag_MIN = SERVER_TAG_NORMAL;
constexpr ServerTag ServerTag_MAX = SERVER_TAG_IOS_AUDIT;
constexpr int ServerTag_ARRAYSIZE = ServerTag_MAX + 1;

const std::string& ServerTag_Name(ServerTag value);
template<typename T>
inline const std::string& ServerTag_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ServerTag>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ServerTag_Name.");
  return ServerTag_Name(static_cast<ServerTag>(enum_t_value));
}
bool ServerTag_Parse(
    const std::string& name, ServerTag* value);
enum ItemFindBackType : int {
  TOWER = 1,
  NVSHENSHILIAN = 2,
  GUILDACTIVITY = 3,
  FATIGUE_RECOVER = 4,
  FATIGUE_GET = 5,
  FATIGUE_BUY = 6,
  DICE_BACK = 7,
  WUJINSHENYUAN_BACK = 8,
  DRAGONEXP_BACK = 9,
  QAMULTI_BACK = 10,
  GUILDCHECKIN_BACK = 11,
  GUILD_VOICE = 12,
  COMMERCETASK_BACK = 13,
  DayActiveBack = 14,
  NestBack = 15,
  FINDBACK_MAX = 16
};
bool ItemFindBackType_IsValid(int value);
constexpr ItemFindBackType ItemFindBackType_MIN = TOWER;
constexpr ItemFindBackType ItemFindBackType_MAX = FINDBACK_MAX;
constexpr int ItemFindBackType_ARRAYSIZE = ItemFindBackType_MAX + 1;

const std::string& ItemFindBackType_Name(ItemFindBackType value);
template<typename T>
inline const std::string& ItemFindBackType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ItemFindBackType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ItemFindBackType_Name.");
  return ItemFindBackType_Name(static_cast<ItemFindBackType>(enum_t_value));
}
bool ItemFindBackType_Parse(
    const std::string& name, ItemFindBackType* value);
enum OutLookType : int {
  OutLook_Fashion = 0,
  OutLook_Equip = 1
};
bool OutLookType_IsValid(int value);
constexpr OutLookType OutLookType_MIN = OutLook_Fashion;
constexpr OutLookType OutLookType_MAX = OutLook_Equip;
constexpr int OutLookType_ARRAYSIZE = OutLookType_MAX + 1;

const std::string& OutLookType_Name(OutLookType value);
template<typename T>
inline const std::string& OutLookType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OutLookType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OutLookType_Name.");
  return OutLookType_Name(static_cast<OutLookType>(enum_t_value));
}
bool OutLookType_Parse(
    const std::string& name, OutLookType* value);
enum SpriteType : int {
  Sprite_Feed = 1,
  Sprite_Evolution = 2,
  Sprite_Awake = 3,
  Sprite_Awake_Retain = 4,
  Sprite_Awake_Replace = 5,
  Sprite_InFight = 6,
  Sprite_OutFight = 7,
  Sprite_Decompose = 8,
  Sprite_SwapLeader = 9,
  Sprite_QueryEvolutionPPT = 10,
  Sprite_Train = 11,
  Sprite_ResetTrain = 12,
  Sprite_Rebirth = 13
};
bool SpriteType_IsValid(int value);
constexpr SpriteType SpriteType_MIN = Sprite_Feed;
constexpr SpriteType SpriteType_MAX = Sprite_Rebirth;
constexpr int SpriteType_ARRAYSIZE = SpriteType_MAX + 1;

const std::string& SpriteType_Name(SpriteType value);
template<typename T>
inline const std::string& SpriteType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SpriteType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SpriteType_Name.");
  return SpriteType_Name(static_cast<SpriteType>(enum_t_value));
}
bool SpriteType_Parse(
    const std::string& name, SpriteType* value);
enum RiskGridType : int {
  RISK_GRID_EMPTY = 1,
  RISK_GRID_NORMALREWARD = 2,
  RISK_GRID_REWARDBOX = 3,
  RISK_GRID_ADVENTURE = 4,
  RISK_GRID_DICE = 5,
  RISK_GRID_MAX = 6
};
bool RiskGridType_IsValid(int value);
constexpr RiskGridType RiskGridType_MIN = RISK_GRID_EMPTY;
constexpr RiskGridType RiskGridType_MAX = RISK_GRID_MAX;
constexpr int RiskGridType_ARRAYSIZE = RiskGridType_MAX + 1;

const std::string& RiskGridType_Name(RiskGridType value);
template<typename T>
inline const std::string& RiskGridType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RiskGridType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RiskGridType_Name.");
  return RiskGridType_Name(static_cast<RiskGridType>(enum_t_value));
}
bool RiskGridType_Parse(
    const std::string& name, RiskGridType* value);
enum RiskBoxState : int {
  RISK_BOX_LOCKED = 1,
  RISK_BOX_UNLOCKED = 2,
  RISK_BOX_CANGETREWARD = 3,
  RISK_BOX_GETREWARD = 4,
  RISK_BOX_DELETE = 5
};
bool RiskBoxState_IsValid(int value);
constexpr RiskBoxState RiskBoxState_MIN = RISK_BOX_LOCKED;
constexpr RiskBoxState RiskBoxState_MAX = RISK_BOX_DELETE;
constexpr int RiskBoxState_ARRAYSIZE = RiskBoxState_MAX + 1;

const std::string& RiskBoxState_Name(RiskBoxState value);
template<typename T>
inline const std::string& RiskBoxState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RiskBoxState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RiskBoxState_Name.");
  return RiskBoxState_Name(static_cast<RiskBoxState>(enum_t_value));
}
bool RiskBoxState_Parse(
    const std::string& name, RiskBoxState* value);
enum DEProgressState : int {
  DEPS_FINISH = 1,
  DEPS_FIGHT = 2,
  DEPS_NOTOPEN = 3
};
bool DEProgressState_IsValid(int value);
constexpr DEProgressState DEProgressState_MIN = DEPS_FINISH;
constexpr DEProgressState DEProgressState_MAX = DEPS_NOTOPEN;
constexpr int DEProgressState_ARRAYSIZE = DEProgressState_MAX + 1;

const std::string& DEProgressState_Name(DEProgressState value);
template<typename T>
inline const std::string& DEProgressState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DEProgressState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DEProgressState_Name.");
  return DEProgressState_Name(static_cast<DEProgressState>(enum_t_value));
}
bool DEProgressState_Parse(
    const std::string& name, DEProgressState* value);
enum ReviveType : int {
  ReviveNone = 0,
  ReviveFree = 1,
  ReviveItem = 2,
  ReviveMoney = 3,
  ReviveSprite = 4,
  ReviveVIP = 5,
  ReviveMax = 6
};
bool ReviveType_IsValid(int value);
constexpr ReviveType ReviveType_MIN = ReviveNone;
constexpr ReviveType ReviveType_MAX = ReviveMax;
constexpr int ReviveType_ARRAYSIZE = ReviveType_MAX + 1;

const std::string& ReviveType_Name(ReviveType value);
template<typename T>
inline const std::string& ReviveType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ReviveType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ReviveType_Name.");
  return ReviveType_Name(static_cast<ReviveType>(enum_t_value));
}
bool ReviveType_Parse(
    const std::string& name, ReviveType* value);
enum GuildOpType : int {
  STUDY_SKILL = 1,
  GUILD_DARE_INFO = 2
};
bool GuildOpType_IsValid(int value);
constexpr GuildOpType GuildOpType_MIN = STUDY_SKILL;
constexpr GuildOpType GuildOpType_MAX = GUILD_DARE_INFO;
constexpr int GuildOpType_ARRAYSIZE = GuildOpType_MAX + 1;

const std::string& GuildOpType_Name(GuildOpType value);
template<typename T>
inline const std::string& GuildOpType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GuildOpType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GuildOpType_Name.");
  return GuildOpType_Name(static_cast<GuildOpType>(enum_t_value));
}
bool GuildOpType_Parse(
    const std::string& name, GuildOpType* value);
enum AuctionAllReqType : int {
  ART_REQSALE = 1,
  ART_QUITSALE = 2,
  ART_RESALE = 3,
  ART_ALLITEMBRIEF = 4,
  ART_ITEMDATA = 5,
  ART_MYSALE = 6,
  ART_BUY = 7,
  ART_REFRESH_FREE = 8,
  ART_REFRESH_PAY = 9,
  ART_TRADE_PRICE = 10,
  ART_REFRESH_AUTO = 11
};
bool AuctionAllReqType_IsValid(int value);
constexpr AuctionAllReqType AuctionAllReqType_MIN = ART_REQSALE;
constexpr AuctionAllReqType AuctionAllReqType_MAX = ART_REFRESH_AUTO;
constexpr int AuctionAllReqType_ARRAYSIZE = AuctionAllReqType_MAX + 1;

const std::string& AuctionAllReqType_Name(AuctionAllReqType value);
template<typename T>
inline const std::string& AuctionAllReqType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AuctionAllReqType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AuctionAllReqType_Name.");
  return AuctionAllReqType_Name(static_cast<AuctionAllReqType>(enum_t_value));
}
bool AuctionAllReqType_Parse(
    const std::string& name, AuctionAllReqType* value);
enum ItemEnum : int {
  Virtual_Max = 50
};
bool ItemEnum_IsValid(int value);
constexpr ItemEnum ItemEnum_MIN = Virtual_Max;
constexpr ItemEnum ItemEnum_MAX = Virtual_Max;
constexpr int ItemEnum_ARRAYSIZE = ItemEnum_MAX + 1;

const std::string& ItemEnum_Name(ItemEnum value);
template<typename T>
inline const std::string& ItemEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ItemEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ItemEnum_Name.");
  return ItemEnum_Name(static_cast<ItemEnum>(enum_t_value));
}
bool ItemEnum_Parse(
    const std::string& name, ItemEnum* value);
enum GuildCardOp : int {
  GuildCard_Query = 1,
  GuildCard_Start = 2,
  GuildCard_Change = 3,
  GuildCard_End = 4
};
bool GuildCardOp_IsValid(int value);
constexpr GuildCardOp GuildCardOp_MIN = GuildCard_Query;
constexpr GuildCardOp GuildCardOp_MAX = GuildCard_End;
constexpr int GuildCardOp_ARRAYSIZE = GuildCardOp_MAX + 1;

const std::string& GuildCardOp_Name(GuildCardOp value);
template<typename T>
inline const std::string& GuildCardOp_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GuildCardOp>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GuildCardOp_Name.");
  return GuildCardOp_Name(static_cast<GuildCardOp>(enum_t_value));
}
bool GuildCardOp_Parse(
    const std::string& name, GuildCardOp* value);
enum PkResultType : int {
  PkResult_Win = 1,
  PkResult_Lose = 2,
  PkResult_Draw = 3
};
bool PkResultType_IsValid(int value);
constexpr PkResultType PkResultType_MIN = PkResult_Win;
constexpr PkResultType PkResultType_MAX = PkResult_Draw;
constexpr int PkResultType_ARRAYSIZE = PkResultType_MAX + 1;

const std::string& PkResultType_Name(PkResultType value);
template<typename T>
inline const std::string& PkResultType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PkResultType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PkResultType_Name.");
  return PkResultType_Name(static_cast<PkResultType>(enum_t_value));
}
bool PkResultType_Parse(
    const std::string& name, PkResultType* value);
enum HallIconState : int {
  HICONS_BEGIN = 1,
  HICONS_END = 2
};
bool HallIconState_IsValid(int value);
constexpr HallIconState HallIconState_MIN = HICONS_BEGIN;
constexpr HallIconState HallIconState_MAX = HICONS_END;
constexpr int HallIconState_ARRAYSIZE = HallIconState_MAX + 1;

const std::string& HallIconState_Name(HallIconState value);
template<typename T>
inline const std::string& HallIconState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HallIconState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HallIconState_Name.");
  return HallIconState_Name(static_cast<HallIconState>(enum_t_value));
}
bool HallIconState_Parse(
    const std::string& name, HallIconState* value);
enum TaskStatus : int {
  TaskStatus_CanTake = 1,
  TaskStatus_Taked = 2,
  TaskStatus_Finish = 3,
  TaskStatus_Over = 4
};
bool TaskStatus_IsValid(int value);
constexpr TaskStatus TaskStatus_MIN = TaskStatus_CanTake;
constexpr TaskStatus TaskStatus_MAX = TaskStatus_Over;
constexpr int TaskStatus_ARRAYSIZE = TaskStatus_MAX + 1;

const std::string& TaskStatus_Name(TaskStatus value);
template<typename T>
inline const std::string& TaskStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TaskStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TaskStatus_Name.");
  return TaskStatus_Name(static_cast<TaskStatus>(enum_t_value));
}
bool TaskStatus_Parse(
    const std::string& name, TaskStatus* value);
enum SkyCityTimeType : int {
  Waiting = 1,
  Race = 2,
  MidleEndInRest = 3,
  FirstWaiting = 4,
  SecondWaiting = 5,
  SC_NONE = 6
};
bool SkyCityTimeType_IsValid(int value);
constexpr SkyCityTimeType SkyCityTimeType_MIN = Waiting;
constexpr SkyCityTimeType SkyCityTimeType_MAX = SC_NONE;
constexpr int SkyCityTimeType_ARRAYSIZE = SkyCityTimeType_MAX + 1;

const std::string& SkyCityTimeType_Name(SkyCityTimeType value);
template<typename T>
inline const std::string& SkyCityTimeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SkyCityTimeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SkyCityTimeType_Name.");
  return SkyCityTimeType_Name(static_cast<SkyCityTimeType>(enum_t_value));
}
bool SkyCityTimeType_Parse(
    const std::string& name, SkyCityTimeType* value);
enum GMFReadyType : int {
  GMF_READY_UP = 1,
  GMF_READY_DOWN = 2,
  GMF_READY_KICK = 3
};
bool GMFReadyType_IsValid(int value);
constexpr GMFReadyType GMFReadyType_MIN = GMF_READY_UP;
constexpr GMFReadyType GMFReadyType_MAX = GMF_READY_KICK;
constexpr int GMFReadyType_ARRAYSIZE = GMFReadyType_MAX + 1;

const std::string& GMFReadyType_Name(GMFReadyType value);
template<typename T>
inline const std::string& GMFReadyType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GMFReadyType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GMFReadyType_Name.");
  return GMFReadyType_Name(static_cast<GMFReadyType>(enum_t_value));
}
bool GMFReadyType_Parse(
    const std::string& name, GMFReadyType* value);
enum CardMatchOp : int {
  CardMatch_Begin = 0,
  CardMatch_Add = 2,
  CardMatch_Del = 3,
  CardMatch_RoundBegin = 4,
  CardMatch_RoundChange = 5,
  CardMatch_RoundEnd = 6,
  CardMatch_End = 7,
  CardMatch_Query = 8,
  CardMatch_RoundWaiting = 9,
  CardMatch_SignUp = 10
};
bool CardMatchOp_IsValid(int value);
constexpr CardMatchOp CardMatchOp_MIN = CardMatch_Begin;
constexpr CardMatchOp CardMatchOp_MAX = CardMatch_SignUp;
constexpr int CardMatchOp_ARRAYSIZE = CardMatchOp_MAX + 1;

const std::string& CardMatchOp_Name(CardMatchOp value);
template<typename T>
inline const std::string& CardMatchOp_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CardMatchOp>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CardMatchOp_Name.");
  return CardMatchOp_Name(static_cast<CardMatchOp>(enum_t_value));
}
bool CardMatchOp_Parse(
    const std::string& name, CardMatchOp* value);
enum CardMatchState : int {
  CardMatch_StateBegin = 0,
  CardMatch_StateWaiting = 1,
  CardMatch_StateRoundWaiting = 2,
  CardMatch_StateRoundBegin = 3,
  CardMatch_StateRounding = 4,
  CardMatch_StateRoundEnd = 5,
  CardMatch_StateEnd = 6,
  CardMatch_StateDummy = 7
};
bool CardMatchState_IsValid(int value);
constexpr CardMatchState CardMatchState_MIN = CardMatch_StateBegin;
constexpr CardMatchState CardMatchState_MAX = CardMatch_StateDummy;
constexpr int CardMatchState_ARRAYSIZE = CardMatchState_MAX + 1;

const std::string& CardMatchState_Name(CardMatchState value);
template<typename T>
inline const std::string& CardMatchState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CardMatchState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CardMatchState_Name.");
  return CardMatchState_Name(static_cast<CardMatchState>(enum_t_value));
}
bool CardMatchState_Parse(
    const std::string& name, CardMatchState* value);
enum GuildBindStatus : int {
  GBS_NotBind = 1,
  GBS_Owner = 2,
  GBS_Admin = 3,
  GBS_Member = 4,
  GBS_NotMember = 5
};
bool GuildBindStatus_IsValid(int value);
constexpr GuildBindStatus GuildBindStatus_MIN = GBS_NotBind;
constexpr GuildBindStatus GuildBindStatus_MAX = GBS_NotMember;
constexpr int GuildBindStatus_ARRAYSIZE = GuildBindStatus_MAX + 1;

const std::string& GuildBindStatus_Name(GuildBindStatus value);
template<typename T>
inline const std::string& GuildBindStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GuildBindStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GuildBindStatus_Name.");
  return GuildBindStatus_Name(static_cast<GuildBindStatus>(enum_t_value));
}
bool GuildBindStatus_Parse(
    const std::string& name, GuildBindStatus* value);
enum GmfBattleState : int {
  GMF_BS_NONE = 4,
  GMF_BS_WAIT = 1,
  GMF_BS_FIGHT = 2,
  GMF_BS_RESULT = 3
};
bool GmfBattleState_IsValid(int value);
constexpr GmfBattleState GmfBattleState_MIN = GMF_BS_WAIT;
constexpr GmfBattleState GmfBattleState_MAX = GMF_BS_NONE;
constexpr int GmfBattleState_ARRAYSIZE = GmfBattleState_MAX + 1;

const std::string& GmfBattleState_Name(GmfBattleState value);
template<typename T>
inline const std::string& GmfBattleState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GmfBattleState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GmfBattleState_Name.");
  return GmfBattleState_Name(static_cast<GmfBattleState>(enum_t_value));
}
bool GmfBattleState_Parse(
    const std::string& name, GmfBattleState* value);
enum BroadCastType : int {
  BroadCastToAll = 1,
  BroadCastMax = 2
};
bool BroadCastType_IsValid(int value);
constexpr BroadCastType BroadCastType_MIN = BroadCastToAll;
constexpr BroadCastType BroadCastType_MAX = BroadCastMax;
constexpr int BroadCastType_ARRAYSIZE = BroadCastType_MAX + 1;

const std::string& BroadCastType_Name(BroadCastType value);
template<typename T>
inline const std::string& BroadCastType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BroadCastType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BroadCastType_Name.");
  return BroadCastType_Name(static_cast<BroadCastType>(enum_t_value));
}
bool BroadCastType_Parse(
    const std::string& name, BroadCastType* value);
enum ActOpenState : int {
  ActOpenState_NotOpen = 1,
  ActOpenState_Prepare = 2,
  ActOpenState_Running = 3,
  ActOpenState_Over = 4
};
bool ActOpenState_IsValid(int value);
constexpr ActOpenState ActOpenState_MIN = ActOpenState_NotOpen;
constexpr ActOpenState ActOpenState_MAX = ActOpenState_Over;
constexpr int ActOpenState_ARRAYSIZE = ActOpenState_MAX + 1;

const std::string& ActOpenState_Name(ActOpenState value);
template<typename T>
inline const std::string& ActOpenState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ActOpenState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ActOpenState_Name.");
  return ActOpenState_Name(static_cast<ActOpenState>(enum_t_value));
}
bool ActOpenState_Parse(
    const std::string& name, ActOpenState* value);
enum PlantGrowState : int {
  growDrought = 1,
  growPest = 2,
  growSluggish = 3,
  growCD = 4,
  growMature = 5,
  growCorrect = 6
};
bool PlantGrowState_IsValid(int value);
constexpr PlantGrowState PlantGrowState_MIN = growDrought;
constexpr PlantGrowState PlantGrowState_MAX = growCorrect;
constexpr int PlantGrowState_ARRAYSIZE = PlantGrowState_MAX + 1;

const std::string& PlantGrowState_Name(PlantGrowState value);
template<typename T>
inline const std::string& PlantGrowState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlantGrowState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlantGrowState_Name.");
  return PlantGrowState_Name(static_cast<PlantGrowState>(enum_t_value));
}
bool PlantGrowState_Parse(
    const std::string& name, PlantGrowState* value);
enum GardenPlayEventType : int {
  PLANT = 1,
  PLANT_STAGE = 2,
  PLANT_STATE_CHANGE = 3,
  BANQUET = 4,
  BANQUET_STAGE = 5,
  PLANT_DELETE = 6,
  PLANT_SPRITE = 7,
  PLANT_MATURE = 8,
  FISH_FACE = 9,
  FISH_RESULT = 10,
  FISH_STOP = 11
};
bool GardenPlayEventType_IsValid(int value);
constexpr GardenPlayEventType GardenPlayEventType_MIN = PLANT;
constexpr GardenPlayEventType GardenPlayEventType_MAX = FISH_STOP;
constexpr int GardenPlayEventType_ARRAYSIZE = GardenPlayEventType_MAX + 1;

const std::string& GardenPlayEventType_Name(GardenPlayEventType value);
template<typename T>
inline const std::string& GardenPlayEventType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GardenPlayEventType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GardenPlayEventType_Name.");
  return GardenPlayEventType_Name(static_cast<GardenPlayEventType>(enum_t_value));
}
bool GardenPlayEventType_Parse(
    const std::string& name, GardenPlayEventType* value);
enum GMF_FINAL_WIN_TYPE : int {
  GMF_FWY_NORMAL = 1,
  GMF_FWY_OPNONE = 2,
  GMF_FWY_RANK = 3
};
bool GMF_FINAL_WIN_TYPE_IsValid(int value);
constexpr GMF_FINAL_WIN_TYPE GMF_FINAL_WIN_TYPE_MIN = GMF_FWY_NORMAL;
constexpr GMF_FINAL_WIN_TYPE GMF_FINAL_WIN_TYPE_MAX = GMF_FWY_RANK;
constexpr int GMF_FINAL_WIN_TYPE_ARRAYSIZE = GMF_FINAL_WIN_TYPE_MAX + 1;

const std::string& GMF_FINAL_WIN_TYPE_Name(GMF_FINAL_WIN_TYPE value);
template<typename T>
inline const std::string& GMF_FINAL_WIN_TYPE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GMF_FINAL_WIN_TYPE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GMF_FINAL_WIN_TYPE_Name.");
  return GMF_FINAL_WIN_TYPE_Name(static_cast<GMF_FINAL_WIN_TYPE>(enum_t_value));
}
bool GMF_FINAL_WIN_TYPE_Parse(
    const std::string& name, GMF_FINAL_WIN_TYPE* value);
enum RoleEventType : int {
  OnSendFriendGift = 1
};
bool RoleEventType_IsValid(int value);
constexpr RoleEventType RoleEventType_MIN = OnSendFriendGift;
constexpr RoleEventType RoleEventType_MAX = OnSendFriendGift;
constexpr int RoleEventType_ARRAYSIZE = RoleEventType_MAX + 1;

const std::string& RoleEventType_Name(RoleEventType value);
template<typename T>
inline const std::string& RoleEventType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RoleEventType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RoleEventType_Name.");
  return RoleEventType_Name(static_cast<RoleEventType>(enum_t_value));
}
bool RoleEventType_Parse(
    const std::string& name, RoleEventType* value);
enum WageRewardState : int {
  cannot = 1,
  rewarded = 2,
  notreward = 3
};
bool WageRewardState_IsValid(int value);
constexpr WageRewardState WageRewardState_MIN = cannot;
constexpr WageRewardState WageRewardState_MAX = notreward;
constexpr int WageRewardState_ARRAYSIZE = WageRewardState_MAX + 1;

const std::string& WageRewardState_Name(WageRewardState value);
template<typename T>
inline const std::string& WageRewardState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WageRewardState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WageRewardState_Name.");
  return WageRewardState_Name(static_cast<WageRewardState>(enum_t_value));
}
bool WageRewardState_Parse(
    const std::string& name, WageRewardState* value);
enum ItemUseOp : int {
  BagFind = 0,
  BodyFind = 1,
  FashionWear = 2,
  FashionOff = 3,
  Composite = 4,
  FashionSuitWear = 5,
  FashionSuitOff = 6,
  ItemBuffAdd = 7,
  FashionDisplayWear = 8,
  FashionDisplayOff = 9,
  FashionSuitDisplayWear = 10,
  FashionSuitDisplayOff = 11,
  ActivationFashion = 12,
  ActivationHairColor = 13,
  UseHairColor = 14
};
bool ItemUseOp_IsValid(int value);
constexpr ItemUseOp ItemUseOp_MIN = BagFind;
constexpr ItemUseOp ItemUseOp_MAX = UseHairColor;
constexpr int ItemUseOp_ARRAYSIZE = ItemUseOp_MAX + 1;

const std::string& ItemUseOp_Name(ItemUseOp value);
template<typename T>
inline const std::string& ItemUseOp_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ItemUseOp>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ItemUseOp_Name.");
  return ItemUseOp_Name(static_cast<ItemUseOp>(enum_t_value));
}
bool ItemUseOp_Parse(
    const std::string& name, ItemUseOp* value);
enum ResWarTimeType : int {
  RealyTime = 1,
  RaceTime = 2,
  EndTime = 3,
  ResWarNone = 4
};
bool ResWarTimeType_IsValid(int value);
constexpr ResWarTimeType ResWarTimeType_MIN = RealyTime;
constexpr ResWarTimeType ResWarTimeType_MAX = ResWarNone;
constexpr int ResWarTimeType_ARRAYSIZE = ResWarTimeType_MAX + 1;

const std::string& ResWarTimeType_Name(ResWarTimeType value);
template<typename T>
inline const std::string& ResWarTimeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResWarTimeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResWarTimeType_Name.");
  return ResWarTimeType_Name(static_cast<ResWarTimeType>(enum_t_value));
}
bool ResWarTimeType_Parse(
    const std::string& name, ResWarTimeType* value);
enum ResWarResult : int {
  RESWAR_SUCESS = 1,
  RESWAR_FAIL = 2,
  RESWAR_FLAT = 3
};
bool ResWarResult_IsValid(int value);
constexpr ResWarResult ResWarResult_MIN = RESWAR_SUCESS;
constexpr ResWarResult ResWarResult_MAX = RESWAR_FLAT;
constexpr int ResWarResult_ARRAYSIZE = ResWarResult_MAX + 1;

const std::string& ResWarResult_Name(ResWarResult value);
template<typename T>
inline const std::string& ResWarResult_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResWarResult>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResWarResult_Name.");
  return ResWarResult_Name(static_cast<ResWarResult>(enum_t_value));
}
bool ResWarResult_Parse(
    const std::string& name, ResWarResult* value);
enum GuildAuctReqType : int {
  GART_ACT_TYPE = 1,
  GART_ITEM_TYPE = 2,
  GART_BUY_AUCT = 5,
  GART_BUY_NOW = 6,
  GART_AUCT_GUILD_HISTORY = 7,
  GART_AUCT_WORLD_HISTORY = 8
};
bool GuildAuctReqType_IsValid(int value);
constexpr GuildAuctReqType GuildAuctReqType_MIN = GART_ACT_TYPE;
constexpr GuildAuctReqType GuildAuctReqType_MAX = GART_AUCT_WORLD_HISTORY;
constexpr int GuildAuctReqType_ARRAYSIZE = GuildAuctReqType_MAX + 1;

const std::string& GuildAuctReqType_Name(GuildAuctReqType value);
template<typename T>
inline const std::string& GuildAuctReqType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GuildAuctReqType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GuildAuctReqType_Name.");
  return GuildAuctReqType_Name(static_cast<GuildAuctReqType>(enum_t_value));
}
bool GuildAuctReqType_Parse(
    const std::string& name, GuildAuctReqType* value);
enum GardenQuestType : int {
  MYSELF = 1,
  FRIEND = 2,
  GUILD = 3
};
bool GardenQuestType_IsValid(int value);
constexpr GardenQuestType GardenQuestType_MIN = MYSELF;
constexpr GardenQuestType GardenQuestType_MAX = GUILD;
constexpr int GardenQuestType_ARRAYSIZE = GardenQuestType_MAX + 1;

const std::string& GardenQuestType_Name(GardenQuestType value);
template<typename T>
inline const std::string& GardenQuestType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GardenQuestType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GardenQuestType_Name.");
  return GardenQuestType_Name(static_cast<GardenQuestType>(enum_t_value));
}
bool GardenQuestType_Parse(
    const std::string& name, GardenQuestType* value);
enum GuildArenaType : int {
  battleone = 1,
  battletwo = 2,
  battlethree = 3,
  battlefour = 4,
  battlefinal = 5,
  apply = 6,
  resttime = 0,
  notopen = 7
};
bool GuildArenaType_IsValid(int value);
constexpr GuildArenaType GuildArenaType_MIN = resttime;
constexpr GuildArenaType GuildArenaType_MAX = notopen;
constexpr int GuildArenaType_ARRAYSIZE = GuildArenaType_MAX + 1;

const std::string& GuildArenaType_Name(GuildArenaType value);
template<typename T>
inline const std::string& GuildArenaType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GuildArenaType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GuildArenaType_Name.");
  return GuildArenaType_Name(static_cast<GuildArenaType>(enum_t_value));
}
bool GuildArenaType_Parse(
    const std::string& name, GuildArenaType* value);
enum StageRankCond : int {
  StageRankCond_Time = 1,
  StageRankCond_Hppercent = 2,
  StageRankCond_Found = 3,
  StageRankCond_Behit = 4,
  StageRankCond_NpcHp = 5,
  StageRankCond_Combo = 6,
  StageRankCond_KillEnemyScore = 7,
  StageRankCond_AliveTime = 8,
  StageRankCond_TotalKillEnemyScore = 9
};
bool StageRankCond_IsValid(int value);
constexpr StageRankCond StageRankCond_MIN = StageRankCond_Time;
constexpr StageRankCond StageRankCond_MAX = StageRankCond_TotalKillEnemyScore;
constexpr int StageRankCond_ARRAYSIZE = StageRankCond_MAX + 1;

const std::string& StageRankCond_Name(StageRankCond value);
template<typename T>
inline const std::string& StageRankCond_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StageRankCond>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StageRankCond_Name.");
  return StageRankCond_Name(static_cast<StageRankCond>(enum_t_value));
}
bool StageRankCond_Parse(
    const std::string& name, StageRankCond* value);
enum GuildAuctResultType : int {
  GA_RESULT_BUY_NOW = 1,
  GA_RESULT_BUY_AUCT = 2,
  GA_RESULT_TO_WORLD = 3
};
bool GuildAuctResultType_IsValid(int value);
constexpr GuildAuctResultType GuildAuctResultType_MIN = GA_RESULT_BUY_NOW;
constexpr GuildAuctResultType GuildAuctResultType_MAX = GA_RESULT_TO_WORLD;
constexpr int GuildAuctResultType_ARRAYSIZE = GuildAuctResultType_MAX + 1;

const std::string& GuildAuctResultType_Name(GuildAuctResultType value);
template<typename T>
inline const std::string& GuildAuctResultType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GuildAuctResultType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GuildAuctResultType_Name.");
  return GuildAuctResultType_Name(static_cast<GuildAuctResultType>(enum_t_value));
}
bool GuildAuctResultType_Parse(
    const std::string& name, GuildAuctResultType* value);
enum IntegralState : int {
  integralready = 1,
  integralenterscene = 2,
  integralwatch = 3,
  integralend = 4
};
bool IntegralState_IsValid(int value);
constexpr IntegralState IntegralState_MIN = integralready;
constexpr IntegralState IntegralState_MAX = integralend;
constexpr int IntegralState_ARRAYSIZE = IntegralState_MAX + 1;

const std::string& IntegralState_Name(IntegralState value);
template<typename T>
inline const std::string& IntegralState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, IntegralState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function IntegralState_Name.");
  return IntegralState_Name(static_cast<IntegralState>(enum_t_value));
}
bool IntegralState_Parse(
    const std::string& name, IntegralState* value);
enum ResWarState : int {
  ResWarExploreState = 1,
  ResWarCancelState = 2
};
bool ResWarState_IsValid(int value);
constexpr ResWarState ResWarState_MIN = ResWarExploreState;
constexpr ResWarState ResWarState_MAX = ResWarCancelState;
constexpr int ResWarState_ARRAYSIZE = ResWarState_MAX + 1;

const std::string& ResWarState_Name(ResWarState value);
template<typename T>
inline const std::string& ResWarState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResWarState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResWarState_Name.");
  return ResWarState_Name(static_cast<ResWarState>(enum_t_value));
}
bool ResWarState_Parse(
    const std::string& name, ResWarState* value);
enum ServerFlag : int {
  ServerFlag_Maintain = 0,
  ServerFlag_New = 1,
  ServerFlag_Hot = 2,
  ServerFlag_Full = 3,
  ServerFlag_Recommend = 4,
  ServerFlag_Dummy = 5,
  ServerFlag_Smooth = 7
};
bool ServerFlag_IsValid(int value);
constexpr ServerFlag ServerFlag_MIN = ServerFlag_Maintain;
constexpr ServerFlag ServerFlag_MAX = ServerFlag_Smooth;
constexpr int ServerFlag_ARRAYSIZE = ServerFlag_MAX + 1;

const std::string& ServerFlag_Name(ServerFlag value);
template<typename T>
inline const std::string& ServerFlag_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ServerFlag>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ServerFlag_Name.");
  return ServerFlag_Name(static_cast<ServerFlag>(enum_t_value));
}
bool ServerFlag_Parse(
    const std::string& name, ServerFlag* value);
enum EnumServerState : int {
  ServerState_Maintain = 0,
  ServerState_Smooth = 1,
  ServerState_Hot = 2,
  ServerState_Full = 3,
  ServerState_Recommend = 4,
  ServerState_Auto = 5
};
bool EnumServerState_IsValid(int value);
constexpr EnumServerState EnumServerState_MIN = ServerState_Maintain;
constexpr EnumServerState EnumServerState_MAX = ServerState_Auto;
constexpr int EnumServerState_ARRAYSIZE = EnumServerState_MAX + 1;

const std::string& EnumServerState_Name(EnumServerState value);
template<typename T>
inline const std::string& EnumServerState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EnumServerState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EnumServerState_Name.");
  return EnumServerState_Name(static_cast<EnumServerState>(enum_t_value));
}
bool EnumServerState_Parse(
    const std::string& name, EnumServerState* value);
enum OutLookStateType : int {
  OutLook_Normal = 0,
  OutLook_Sit = 1,
  OutLook_Dance = 2,
  OutLook_RidePet = 3,
  OutLook_Inherit = 4,
  OutLook_Fish = 5,
  OutLook_RidePetCopilot = 6,
  OutLook_Trans = 7
};
bool OutLookStateType_IsValid(int value);
constexpr OutLookStateType OutLookStateType_MIN = OutLook_Normal;
constexpr OutLookStateType OutLookStateType_MAX = OutLook_Trans;
constexpr int OutLookStateType_ARRAYSIZE = OutLookStateType_MAX + 1;

const std::string& OutLookStateType_Name(OutLookStateType value);
template<typename T>
inline const std::string& OutLookStateType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OutLookStateType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OutLookStateType_Name.");
  return OutLookStateType_Name(static_cast<OutLookStateType>(enum_t_value));
}
bool OutLookStateType_Parse(
    const std::string& name, OutLookStateType* value);
enum FunctionId : int {
  FunctionId_QQVip = 0,
  FunctionId_IOSCheck = 1,
  FunctionId_StartPrivilege = 2
};
bool FunctionId_IsValid(int value);
constexpr FunctionId FunctionId_MIN = FunctionId_QQVip;
constexpr FunctionId FunctionId_MAX = FunctionId_StartPrivilege;
constexpr int FunctionId_ARRAYSIZE = FunctionId_MAX + 1;

const std::string& FunctionId_Name(FunctionId value);
template<typename T>
inline const std::string& FunctionId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FunctionId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FunctionId_Name.");
  return FunctionId_Name(static_cast<FunctionId>(enum_t_value));
}
bool FunctionId_Parse(
    const std::string& name, FunctionId* value);
enum LeaveTeamType : int {
  LTT_BY_SELF = 0,
  LTT_KICK = 1,
  LTT_DEL_ROBOT = 2,
  LTT_MS_CRASH = 3,
  LLT_LEADER_TIMEOVER = 4
};
bool LeaveTeamType_IsValid(int value);
constexpr LeaveTeamType LeaveTeamType_MIN = LTT_BY_SELF;
constexpr LeaveTeamType LeaveTeamType_MAX = LLT_LEADER_TIMEOVER;
constexpr int LeaveTeamType_ARRAYSIZE = LeaveTeamType_MAX + 1;

const std::string& LeaveTeamType_Name(LeaveTeamType value);
template<typename T>
inline const std::string& LeaveTeamType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LeaveTeamType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LeaveTeamType_Name.");
  return LeaveTeamType_Name(static_cast<LeaveTeamType>(enum_t_value));
}
bool LeaveTeamType_Parse(
    const std::string& name, LeaveTeamType* value);
enum StartUpType : int {
  StartUp_Normal = 1,
  StartUp_QQ = 2,
  StartUp_WX = 3
};
bool StartUpType_IsValid(int value);
constexpr StartUpType StartUpType_MIN = StartUp_Normal;
constexpr StartUpType StartUpType_MAX = StartUp_WX;
constexpr int StartUpType_ARRAYSIZE = StartUpType_MAX + 1;

const std::string& StartUpType_Name(StartUpType value);
template<typename T>
inline const std::string& StartUpType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StartUpType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StartUpType_Name.");
  return StartUpType_Name(static_cast<StartUpType>(enum_t_value));
}
bool StartUpType_Parse(
    const std::string& name, StartUpType* value);
enum AntiAddictionReportType : int {
  ReportTypeSingle = 1,
  ReportTypeTotal = 2
};
bool AntiAddictionReportType_IsValid(int value);
constexpr AntiAddictionReportType AntiAddictionReportType_MIN = ReportTypeSingle;
constexpr AntiAddictionReportType AntiAddictionReportType_MAX = ReportTypeTotal;
constexpr int AntiAddictionReportType_ARRAYSIZE = AntiAddictionReportType_MAX + 1;

const std::string& AntiAddictionReportType_Name(AntiAddictionReportType value);
template<typename T>
inline const std::string& AntiAddictionReportType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AntiAddictionReportType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AntiAddictionReportType_Name.");
  return AntiAddictionReportType_Name(static_cast<AntiAddictionReportType>(enum_t_value));
}
bool AntiAddictionReportType_Parse(
    const std::string& name, AntiAddictionReportType* value);
enum DBOperType : int {
  DBOper_Insert = 1,
  DBOper_Update = 2,
  DBOper_Del = 3,
  DBOper_DelAll = 4,
  DBOper_ReplaceId = 5
};
bool DBOperType_IsValid(int value);
constexpr DBOperType DBOperType_MIN = DBOper_Insert;
constexpr DBOperType DBOperType_MAX = DBOper_ReplaceId;
constexpr int DBOperType_ARRAYSIZE = DBOperType_MAX + 1;

const std::string& DBOperType_Name(DBOperType value);
template<typename T>
inline const std::string& DBOperType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DBOperType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DBOperType_Name.");
  return DBOperType_Name(static_cast<DBOperType>(enum_t_value));
}
bool DBOperType_Parse(
    const std::string& name, DBOperType* value);
enum MentorApplyStatus : int {
  MentorApplyMaster = 1,
  MentorApplyStudent = 2,
  MentorApplyHas = 3,
  MentorApplyStatusMax = 4
};
bool MentorApplyStatus_IsValid(int value);
constexpr MentorApplyStatus MentorApplyStatus_MIN = MentorApplyMaster;
constexpr MentorApplyStatus MentorApplyStatus_MAX = MentorApplyStatusMax;
constexpr int MentorApplyStatus_ARRAYSIZE = MentorApplyStatus_MAX + 1;

const std::string& MentorApplyStatus_Name(MentorApplyStatus value);
template<typename T>
inline const std::string& MentorApplyStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MentorApplyStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MentorApplyStatus_Name.");
  return MentorApplyStatus_Name(static_cast<MentorApplyStatus>(enum_t_value));
}
bool MentorApplyStatus_Parse(
    const std::string& name, MentorApplyStatus* value);
enum MentorRelationStatus : int {
  MentorRelationIn = 1,
  MentorRelationComplete = 2,
  MentorRelationBreakApply = 3,
  MentorRelationBreak = 4,
  MentorRelationMax = 5
};
bool MentorRelationStatus_IsValid(int value);
constexpr MentorRelationStatus MentorRelationStatus_MIN = MentorRelationIn;
constexpr MentorRelationStatus MentorRelationStatus_MAX = MentorRelationMax;
constexpr int MentorRelationStatus_ARRAYSIZE = MentorRelationStatus_MAX + 1;

const std::string& MentorRelationStatus_Name(MentorRelationStatus value);
template<typename T>
inline const std::string& MentorRelationStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MentorRelationStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MentorRelationStatus_Name.");
  return MentorRelationStatus_Name(static_cast<MentorRelationStatus>(enum_t_value));
}
bool MentorRelationStatus_Parse(
    const std::string& name, MentorRelationStatus* value);
enum MentorMsgApplyType : int {
  MentorMsgApplyMaster = 1,
  MentorMsgApplyStudent = 2,
  MentorMsgApplyInherit = 3,
  MentorMsgApplyReportTask = 4,
  MentorMsgApplyBreak = 5,
  MentorMsgApplyMax = 6
};
bool MentorMsgApplyType_IsValid(int value);
constexpr MentorMsgApplyType MentorMsgApplyType_MIN = MentorMsgApplyMaster;
constexpr MentorMsgApplyType MentorMsgApplyType_MAX = MentorMsgApplyMax;
constexpr int MentorMsgApplyType_ARRAYSIZE = MentorMsgApplyType_MAX + 1;

const std::string& MentorMsgApplyType_Name(MentorMsgApplyType value);
template<typename T>
inline const std::string& MentorMsgApplyType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MentorMsgApplyType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MentorMsgApplyType_Name.");
  return MentorMsgApplyType_Name(static_cast<MentorMsgApplyType>(enum_t_value));
}
bool MentorMsgApplyType_Parse(
    const std::string& name, MentorMsgApplyType* value);
enum MentorRelationOpType : int {
  MentorRelationOp_ApplyMaster = 1,
  MentorRelationOp_ApplyStudent = 2,
  MentorRelationOp_Inherit = 3,
  MentorRelationOp_ReportTask = 4,
  MentorRelationOp_ReportAllTask = 5,
  MentorRelationOp_Break = 6,
  MentorRelationOp_BreakCancel = 7,
  MentorRelationOp_NormalComplete = 8,
  MentorRelationOp_ForceComplete = 9,
  MentorRelationOp_Max = 10
};
bool MentorRelationOpType_IsValid(int value);
constexpr MentorRelationOpType MentorRelationOpType_MIN = MentorRelationOp_ApplyMaster;
constexpr MentorRelationOpType MentorRelationOpType_MAX = MentorRelationOp_Max;
constexpr int MentorRelationOpType_ARRAYSIZE = MentorRelationOpType_MAX + 1;

const std::string& MentorRelationOpType_Name(MentorRelationOpType value);
template<typename T>
inline const std::string& MentorRelationOpType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MentorRelationOpType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MentorRelationOpType_Name.");
  return MentorRelationOpType_Name(static_cast<MentorRelationOpType>(enum_t_value));
}
bool MentorRelationOpType_Parse(
    const std::string& name, MentorRelationOpType* value);
enum EMentorRelationPosition : int {
  EMentorPosMaster = 1,
  EMentorPosStudent = 2,
  EMentorPosMax = 3
};
bool EMentorRelationPosition_IsValid(int value);
constexpr EMentorRelationPosition EMentorRelationPosition_MIN = EMentorPosMaster;
constexpr EMentorRelationPosition EMentorRelationPosition_MAX = EMentorPosMax;
constexpr int EMentorRelationPosition_ARRAYSIZE = EMentorRelationPosition_MAX + 1;

const std::string& EMentorRelationPosition_Name(EMentorRelationPosition value);
template<typename T>
inline const std::string& EMentorRelationPosition_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EMentorRelationPosition>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EMentorRelationPosition_Name.");
  return EMentorRelationPosition_Name(static_cast<EMentorRelationPosition>(enum_t_value));
}
bool EMentorRelationPosition_Parse(
    const std::string& name, EMentorRelationPosition* value);
enum EMentorTaskStatus : int {
  EMentorTask_UnComplete = 1,
  EMentorTask_CanReport = 2,
  EMentorTask_AlreadyReport = 3,
  EMentorTask_ConfirmReport = 4,
  EMentorTask_CompleteBefore = 5,
  EMentorTask_Max = 6
};
bool EMentorTaskStatus_IsValid(int value);
constexpr EMentorTaskStatus EMentorTaskStatus_MIN = EMentorTask_UnComplete;
constexpr EMentorTaskStatus EMentorTaskStatus_MAX = EMentorTask_Max;
constexpr int EMentorTaskStatus_ARRAYSIZE = EMentorTaskStatus_MAX + 1;

const std::string& EMentorTaskStatus_Name(EMentorTaskStatus value);
template<typename T>
inline const std::string& EMentorTaskStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EMentorTaskStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EMentorTaskStatus_Name.");
  return EMentorTaskStatus_Name(static_cast<EMentorTaskStatus>(enum_t_value));
}
bool EMentorTaskStatus_Parse(
    const std::string& name, EMentorTaskStatus* value);
enum EMentorMsgOpType : int {
  EMentorMsgOp_Get = 1,
  EMentorMsgOpType_Clear = 2,
  EMentorMsgOpType_Agree = 3,
  EMentorMsgOpType_Reject = 4,
  EMentorMsgOpType_Max = 5
};
bool EMentorMsgOpType_IsValid(int value);
constexpr EMentorMsgOpType EMentorMsgOpType_MIN = EMentorMsgOp_Get;
constexpr EMentorMsgOpType EMentorMsgOpType_MAX = EMentorMsgOpType_Max;
constexpr int EMentorMsgOpType_ARRAYSIZE = EMentorMsgOpType_MAX + 1;

const std::string& EMentorMsgOpType_Name(EMentorMsgOpType value);
template<typename T>
inline const std::string& EMentorMsgOpType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EMentorMsgOpType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EMentorMsgOpType_Name.");
  return EMentorMsgOpType_Name(static_cast<EMentorMsgOpType>(enum_t_value));
}
bool EMentorMsgOpType_Parse(
    const std::string& name, EMentorMsgOpType* value);
enum PartnerUpdateType : int {
  PUType_Normal = 1,
  PUType_Leave = 2,
  PUType_Dissolve = 3,
  PUType_Shop = 4
};
bool PartnerUpdateType_IsValid(int value);
constexpr PartnerUpdateType PartnerUpdateType_MIN = PUType_Normal;
constexpr PartnerUpdateType PartnerUpdateType_MAX = PUType_Shop;
constexpr int PartnerUpdateType_ARRAYSIZE = PartnerUpdateType_MAX + 1;

const std::string& PartnerUpdateType_Name(PartnerUpdateType value);
template<typename T>
inline const std::string& PartnerUpdateType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PartnerUpdateType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PartnerUpdateType_Name.");
  return PartnerUpdateType_Name(static_cast<PartnerUpdateType>(enum_t_value));
}
bool PartnerUpdateType_Parse(
    const std::string& name, PartnerUpdateType* value);
enum PartnerOperType : int {
  POT_Normal = 1,
  POT_Liveness = 2,
  POT_Leave = 3,
  POT_ApplyLeave = 4,
  POT_CancelLeave = 5,
  POT_Dissolve = 6
};
bool PartnerOperType_IsValid(int value);
constexpr PartnerOperType PartnerOperType_MIN = POT_Normal;
constexpr PartnerOperType PartnerOperType_MAX = POT_Dissolve;
constexpr int PartnerOperType_ARRAYSIZE = PartnerOperType_MAX + 1;

const std::string& PartnerOperType_Name(PartnerOperType value);
template<typename T>
inline const std::string& PartnerOperType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PartnerOperType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PartnerOperType_Name.");
  return PartnerOperType_Name(static_cast<PartnerOperType>(enum_t_value));
}
bool PartnerOperType_Parse(
    const std::string& name, PartnerOperType* value);
enum InvFightReqType : int {
  IFRT_INV_ONE = 1,
  IFRT_REFUSH_ONE = 2,
  IFRT_IGNORE_ALL = 3,
  IFRT_REQ_LIST = 4,
  IFRT_ACCEPT_ONE = 5
};
bool InvFightReqType_IsValid(int value);
constexpr InvFightReqType InvFightReqType_MIN = IFRT_INV_ONE;
constexpr InvFightReqType InvFightReqType_MAX = IFRT_ACCEPT_ONE;
constexpr int InvFightReqType_ARRAYSIZE = InvFightReqType_MAX + 1;

const std::string& InvFightReqType_Name(InvFightReqType value);
template<typename T>
inline const std::string& InvFightReqType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, InvFightReqType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function InvFightReqType_Name.");
  return InvFightReqType_Name(static_cast<InvFightReqType>(enum_t_value));
}
bool InvFightReqType_Parse(
    const std::string& name, InvFightReqType* value);
enum InvFightNotifyType : int {
  IFNT_REFUSE_ME = 1,
  IFNT_INVITE_ME = 2
};
bool InvFightNotifyType_IsValid(int value);
constexpr InvFightNotifyType InvFightNotifyType_MIN = IFNT_REFUSE_ME;
constexpr InvFightNotifyType InvFightNotifyType_MAX = IFNT_INVITE_ME;
constexpr int InvFightNotifyType_ARRAYSIZE = InvFightNotifyType_MAX + 1;

const std::string& InvFightNotifyType_Name(InvFightNotifyType value);
template<typename T>
inline const std::string& InvFightNotifyType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, InvFightNotifyType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function InvFightNotifyType_Name.");
  return InvFightNotifyType_Name(static_cast<InvFightNotifyType>(enum_t_value));
}
bool InvFightNotifyType_Parse(
    const std::string& name, InvFightNotifyType* value);
enum GCFReqType : int {
  GCF_JOIN_READY_SCENE = 1,
  GCF_FIGHT_REPORT = 2,
  GCF_FIGHT_RESULT = 3,
  GCF_JOIN_FIGHT_SCENE = 4
};
bool GCFReqType_IsValid(int value);
constexpr GCFReqType GCFReqType_MIN = GCF_JOIN_READY_SCENE;
constexpr GCFReqType GCFReqType_MAX = GCF_JOIN_FIGHT_SCENE;
constexpr int GCFReqType_ARRAYSIZE = GCFReqType_MAX + 1;

const std::string& GCFReqType_Name(GCFReqType value);
template<typename T>
inline const std::string& GCFReqType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GCFReqType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GCFReqType_Name.");
  return GCFReqType_Name(static_cast<GCFReqType>(enum_t_value));
}
bool GCFReqType_Parse(
    const std::string& name, GCFReqType* value);
enum GCFJvDianType : int {
  GCF_JUDIAN_UP = 1,
  GCF_JUDIAN_MID = 2,
  GCF_JUDIAN_DOWN = 3
};
bool GCFJvDianType_IsValid(int value);
constexpr GCFJvDianType GCFJvDianType_MIN = GCF_JUDIAN_UP;
constexpr GCFJvDianType GCFJvDianType_MAX = GCF_JUDIAN_DOWN;
constexpr int GCFJvDianType_ARRAYSIZE = GCFJvDianType_MAX + 1;

const std::string& GCFJvDianType_Name(GCFJvDianType value);
template<typename T>
inline const std::string& GCFJvDianType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GCFJvDianType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GCFJvDianType_Name.");
  return GCFJvDianType_Name(static_cast<GCFJvDianType>(enum_t_value));
}
bool GCFJvDianType_Parse(
    const std::string& name, GCFJvDianType* value);
enum GCFZhanLingType : int {
  GCFZL_BEGIN = 1,
  GCFZL_BREAK = 2,
  GCFZL_END = 3
};
bool GCFZhanLingType_IsValid(int value);
constexpr GCFZhanLingType GCFZhanLingType_MIN = GCFZL_BEGIN;
constexpr GCFZhanLingType GCFZhanLingType_MAX = GCFZL_END;
constexpr int GCFZhanLingType_ARRAYSIZE = GCFZhanLingType_MAX + 1;

const std::string& GCFZhanLingType_Name(GCFZhanLingType value);
template<typename T>
inline const std::string& GCFZhanLingType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GCFZhanLingType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GCFZhanLingType_Name.");
  return GCFZhanLingType_Name(static_cast<GCFZhanLingType>(enum_t_value));
}
bool GCFZhanLingType_Parse(
    const std::string& name, GCFZhanLingType* value);
enum GCFsynType : int {
  GCF_SYN_KILL = 1,
  GCF_SYN_LEAVE_BATTLE = 2,
  GCF_SYN_OCCUPY = 3,
  GCF_SYN_MUL_POINT = 4,
  GCF_SYN_FIGHT_END = 5,
  GCF_SYN_BACK_TO_READY = 6
};
bool GCFsynType_IsValid(int value);
constexpr GCFsynType GCFsynType_MIN = GCF_SYN_KILL;
constexpr GCFsynType GCFsynType_MAX = GCF_SYN_BACK_TO_READY;
constexpr int GCFsynType_ARRAYSIZE = GCFsynType_MAX + 1;

const std::string& GCFsynType_Name(GCFsynType value);
template<typename T>
inline const std::string& GCFsynType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GCFsynType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GCFsynType_Name.");
  return GCFsynType_Name(static_cast<GCFsynType>(enum_t_value));
}
bool GCFsynType_Parse(
    const std::string& name, GCFsynType* value);
enum GUILDTERRTYPE : int {
  TERR_NOT_OPEN = 1,
  ALLIANCE = 2,
  TERR_WARING = 3,
  TERR_END = 4,
  WAITING = 5
};
bool GUILDTERRTYPE_IsValid(int value);
constexpr GUILDTERRTYPE GUILDTERRTYPE_MIN = TERR_NOT_OPEN;
constexpr GUILDTERRTYPE GUILDTERRTYPE_MAX = WAITING;
constexpr int GUILDTERRTYPE_ARRAYSIZE = GUILDTERRTYPE_MAX + 1;

const std::string& GUILDTERRTYPE_Name(GUILDTERRTYPE value);
template<typename T>
inline const std::string& GUILDTERRTYPE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GUILDTERRTYPE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GUILDTERRTYPE_Name.");
  return GUILDTERRTYPE_Name(static_cast<GUILDTERRTYPE>(enum_t_value));
}
bool GUILDTERRTYPE_Parse(
    const std::string& name, GUILDTERRTYPE* value);
enum GCFG2CSynType : int {
  GCF_G2C_SYN_KILL_ONE = 1,
  GCF_G2C_SYN_MUL_POINT = 2,
  GCF_G2C_SYN_OCCUPY = 3,
  GCF_G2C_SYN_KILL_COUNT = 4
};
bool GCFG2CSynType_IsValid(int value);
constexpr GCFG2CSynType GCFG2CSynType_MIN = GCF_G2C_SYN_KILL_ONE;
constexpr GCFG2CSynType GCFG2CSynType_MAX = GCF_G2C_SYN_KILL_COUNT;
constexpr int GCFG2CSynType_ARRAYSIZE = GCFG2CSynType_MAX + 1;

const std::string& GCFG2CSynType_Name(GCFG2CSynType value);
template<typename T>
inline const std::string& GCFG2CSynType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GCFG2CSynType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GCFG2CSynType_Name.");
  return GCFG2CSynType_Name(static_cast<GCFG2CSynType>(enum_t_value));
}
bool GCFG2CSynType_Parse(
    const std::string& name, GCFG2CSynType* value);
enum UnitSpecialState : int {
  Unit_Puppet = 1,
  Unit_Invisible = 2
};
bool UnitSpecialState_IsValid(int value);
constexpr UnitSpecialState UnitSpecialState_MIN = Unit_Puppet;
constexpr UnitSpecialState UnitSpecialState_MAX = Unit_Invisible;
constexpr int UnitSpecialState_ARRAYSIZE = UnitSpecialState_MAX + 1;

const std::string& UnitSpecialState_Name(UnitSpecialState value);
template<typename T>
inline const std::string& UnitSpecialState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UnitSpecialState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UnitSpecialState_Name.");
  return UnitSpecialState_Name(static_cast<UnitSpecialState>(enum_t_value));
}
bool UnitSpecialState_Parse(
    const std::string& name, UnitSpecialState* value);
enum PayAccessDataType : int {
  PayAccess_SaveAmt = 1,
  PayAccess_Other = 2,
  PayAccess_Send = 3,
  PayAccess_Consume = 4,
  PayAccess_ALL = 5
};
bool PayAccessDataType_IsValid(int value);
constexpr PayAccessDataType PayAccessDataType_MIN = PayAccess_SaveAmt;
constexpr PayAccessDataType PayAccessDataType_MAX = PayAccess_ALL;
constexpr int PayAccessDataType_ARRAYSIZE = PayAccessDataType_MAX + 1;

const std::string& PayAccessDataType_Name(PayAccessDataType value);
template<typename T>
inline const std::string& PayAccessDataType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PayAccessDataType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PayAccessDataType_Name.");
  return PayAccessDataType_Name(static_cast<PayAccessDataType>(enum_t_value));
}
bool PayAccessDataType_Parse(
    const std::string& name, PayAccessDataType* value);
enum BroadCastG2RType : int {
  BroadCastG2RType_MS = 1,
  BroadCastG2RType_NS = 2,
  BroadCastG2RType_DB = 3
};
bool BroadCastG2RType_IsValid(int value);
constexpr BroadCastG2RType BroadCastG2RType_MIN = BroadCastG2RType_MS;
constexpr BroadCastG2RType BroadCastG2RType_MAX = BroadCastG2RType_DB;
constexpr int BroadCastG2RType_ARRAYSIZE = BroadCastG2RType_MAX + 1;

const std::string& BroadCastG2RType_Name(BroadCastG2RType value);
template<typename T>
inline const std::string& BroadCastG2RType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BroadCastG2RType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BroadCastG2RType_Name.");
  return BroadCastG2RType_Name(static_cast<BroadCastG2RType>(enum_t_value));
}
bool BroadCastG2RType_Parse(
    const std::string& name, BroadCastG2RType* value);
enum HeroBattleOver : int {
  HeroBattleOver_Win = 1,
  HeroBattleOver_Lose = 2,
  HeroBattleOver_Draw = 3
};
bool HeroBattleOver_IsValid(int value);
constexpr HeroBattleOver HeroBattleOver_MIN = HeroBattleOver_Win;
constexpr HeroBattleOver HeroBattleOver_MAX = HeroBattleOver_Draw;
constexpr int HeroBattleOver_ARRAYSIZE = HeroBattleOver_MAX + 1;

const std::string& HeroBattleOver_Name(HeroBattleOver value);
template<typename T>
inline const std::string& HeroBattleOver_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HeroBattleOver>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HeroBattleOver_Name.");
  return HeroBattleOver_Name(static_cast<HeroBattleOver>(enum_t_value));
}
bool HeroBattleOver_Parse(
    const std::string& name, HeroBattleOver* value);
enum LeagueBattleTimeState : int {
  LBTS_BeforeOpen = 1,
  LBTS_Apply = 2,
  LBTS_Idle = 3,
  LBTS_PointRace = 4,
  LBTS_Elimination = 5,
  LBTS_CrossIdle = 6,
  LBTS_CrossPointRace = 7,
  LBTS_CrossElimination = 8,
  LBTS_SeasonEnd = 9
};
bool LeagueBattleTimeState_IsValid(int value);
constexpr LeagueBattleTimeState LeagueBattleTimeState_MIN = LBTS_BeforeOpen;
constexpr LeagueBattleTimeState LeagueBattleTimeState_MAX = LBTS_SeasonEnd;
constexpr int LeagueBattleTimeState_ARRAYSIZE = LeagueBattleTimeState_MAX + 1;

const std::string& LeagueBattleTimeState_Name(LeagueBattleTimeState value);
template<typename T>
inline const std::string& LeagueBattleTimeState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LeagueBattleTimeState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LeagueBattleTimeState_Name.");
  return LeagueBattleTimeState_Name(static_cast<LeagueBattleTimeState>(enum_t_value));
}
bool LeagueBattleTimeState_Parse(
    const std::string& name, LeagueBattleTimeState* value);
enum LeagueBattleReqType : int {
  LBReqType_Match = 1,
  LBReqType_CancelMatch = 2
};
bool LeagueBattleReqType_IsValid(int value);
constexpr LeagueBattleReqType LeagueBattleReqType_MIN = LBReqType_Match;
constexpr LeagueBattleReqType LeagueBattleReqType_MAX = LBReqType_CancelMatch;
constexpr int LeagueBattleReqType_ARRAYSIZE = LeagueBattleReqType_MAX + 1;

const std::string& LeagueBattleReqType_Name(LeagueBattleReqType value);
template<typename T>
inline const std::string& LeagueBattleReqType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LeagueBattleReqType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LeagueBattleReqType_Name.");
  return LeagueBattleReqType_Name(static_cast<LeagueBattleReqType>(enum_t_value));
}
bool LeagueBattleReqType_Parse(
    const std::string& name, LeagueBattleReqType* value);
enum LeagueTeamState : int {
  LeagueTeamState_Idle = 1,
  LeagueTeamState_Match = 2,
  LeagueTeamState_Battle = 3
};
bool LeagueTeamState_IsValid(int value);
constexpr LeagueTeamState LeagueTeamState_MIN = LeagueTeamState_Idle;
constexpr LeagueTeamState LeagueTeamState_MAX = LeagueTeamState_Battle;
constexpr int LeagueTeamState_ARRAYSIZE = LeagueTeamState_MAX + 1;

const std::string& LeagueTeamState_Name(LeagueTeamState value);
template<typename T>
inline const std::string& LeagueTeamState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LeagueTeamState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LeagueTeamState_Name.");
  return LeagueTeamState_Name(static_cast<LeagueTeamState>(enum_t_value));
}
bool LeagueTeamState_Parse(
    const std::string& name, LeagueTeamState* value);
enum LeagueBattleRoleState : int {
  LBRoleState_None = 1,
  LBRoleState_Waiting = 2,
  LBRoleState_Leave = 3,
  LBRoleState_Fighting = 4,
  LBRoleState_Win = 5,
  LBRoleState_Failed = 6
};
bool LeagueBattleRoleState_IsValid(int value);
constexpr LeagueBattleRoleState LeagueBattleRoleState_MIN = LBRoleState_None;
constexpr LeagueBattleRoleState LeagueBattleRoleState_MAX = LBRoleState_Failed;
constexpr int LeagueBattleRoleState_ARRAYSIZE = LeagueBattleRoleState_MAX + 1;

const std::string& LeagueBattleRoleState_Name(LeagueBattleRoleState value);
template<typename T>
inline const std::string& LeagueBattleRoleState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LeagueBattleRoleState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LeagueBattleRoleState_Name.");
  return LeagueBattleRoleState_Name(static_cast<LeagueBattleRoleState>(enum_t_value));
}
bool LeagueBattleRoleState_Parse(
    const std::string& name, LeagueBattleRoleState* value);
enum LeagueBattleReadyOper : int {
  LBReady_Up = 1,
  LBReady_Down = 2
};
bool LeagueBattleReadyOper_IsValid(int value);
constexpr LeagueBattleReadyOper LeagueBattleReadyOper_MIN = LBReady_Up;
constexpr LeagueBattleReadyOper LeagueBattleReadyOper_MAX = LBReady_Down;
constexpr int LeagueBattleReadyOper_ARRAYSIZE = LeagueBattleReadyOper_MAX + 1;

const std::string& LeagueBattleReadyOper_Name(LeagueBattleReadyOper value);
template<typename T>
inline const std::string& LeagueBattleReadyOper_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LeagueBattleReadyOper>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LeagueBattleReadyOper_Name.");
  return LeagueBattleReadyOper_Name(static_cast<LeagueBattleReadyOper>(enum_t_value));
}
bool LeagueBattleReadyOper_Parse(
    const std::string& name, LeagueBattleReadyOper* value);
enum LeagueBattleType : int {
  LeagueBattleType_RacePoint = 1,
  LeagueBattleType_Eliminate = 2,
  LeagueBattleType_CrossRacePoint = 3,
  LeagueBattleType_CrossEliminate = 4
};
bool LeagueBattleType_IsValid(int value);
constexpr LeagueBattleType LeagueBattleType_MIN = LeagueBattleType_RacePoint;
constexpr LeagueBattleType LeagueBattleType_MAX = LeagueBattleType_CrossEliminate;
constexpr int LeagueBattleType_ARRAYSIZE = LeagueBattleType_MAX + 1;

const std::string& LeagueBattleType_Name(LeagueBattleType value);
template<typename T>
inline const std::string& LeagueBattleType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LeagueBattleType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LeagueBattleType_Name.");
  return LeagueBattleType_Name(static_cast<LeagueBattleType>(enum_t_value));
}
bool LeagueBattleType_Parse(
    const std::string& name, LeagueBattleType* value);
enum SkillTypeEnum : int {
  Skill_None = 0,
  Skill_Normal = 1,
  Skill_Big = 2,
  Skill_UnUsed = 3,
  Skill_SceneBuff = 4,
  Skill_Help = 5,
  Skill_Buff = 6
};
bool SkillTypeEnum_IsValid(int value);
constexpr SkillTypeEnum SkillTypeEnum_MIN = Skill_None;
constexpr SkillTypeEnum SkillTypeEnum_MAX = Skill_Buff;
constexpr int SkillTypeEnum_ARRAYSIZE = SkillTypeEnum_MAX + 1;

const std::string& SkillTypeEnum_Name(SkillTypeEnum value);
template<typename T>
inline const std::string& SkillTypeEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SkillTypeEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SkillTypeEnum_Name.");
  return SkillTypeEnum_Name(static_cast<SkillTypeEnum>(enum_t_value));
}
bool SkillTypeEnum_Parse(
    const std::string& name, SkillTypeEnum* value);
enum LeagueBattleFightState : int {
  LBFight_None = 1,
  LBFight_Wait = 2,
  LBFight_Fight = 3,
  LBFight_Result = 4
};
bool LeagueBattleFightState_IsValid(int value);
constexpr LeagueBattleFightState LeagueBattleFightState_MIN = LBFight_None;
constexpr LeagueBattleFightState LeagueBattleFightState_MAX = LBFight_Result;
constexpr int LeagueBattleFightState_ARRAYSIZE = LeagueBattleFightState_MAX + 1;

const std::string& LeagueBattleFightState_Name(LeagueBattleFightState value);
template<typename T>
inline const std::string& LeagueBattleFightState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LeagueBattleFightState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LeagueBattleFightState_Name.");
  return LeagueBattleFightState_Name(static_cast<LeagueBattleFightState>(enum_t_value));
}
bool LeagueBattleFightState_Parse(
    const std::string& name, LeagueBattleFightState* value);
enum LBEleRoomState : int {
  LBEleRoomState_Idle = 1,
  LBEleRoomState_Fighting = 2,
  LBEleRoomState_Finish = 3
};
bool LBEleRoomState_IsValid(int value);
constexpr LBEleRoomState LBEleRoomState_MIN = LBEleRoomState_Idle;
constexpr LBEleRoomState LBEleRoomState_MAX = LBEleRoomState_Finish;
constexpr int LBEleRoomState_ARRAYSIZE = LBEleRoomState_MAX + 1;

const std::string& LBEleRoomState_Name(LBEleRoomState value);
template<typename T>
inline const std::string& LBEleRoomState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LBEleRoomState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LBEleRoomState_Name.");
  return LBEleRoomState_Name(static_cast<LBEleRoomState>(enum_t_value));
}
bool LBEleRoomState_Parse(
    const std::string& name, LBEleRoomState* value);
enum GuildQAType : int {
  NO_GUILD = 0,
  BEFORE_OPEN = 1,
  IN_TIME_NOT_OPEN = 2,
  IN_TIME_OPENING = 3,
  AFTER_OPEN = 4,
  NOT_OPEN_DAY = 5
};
bool GuildQAType_IsValid(int value);
constexpr GuildQAType GuildQAType_MIN = NO_GUILD;
constexpr GuildQAType GuildQAType_MAX = NOT_OPEN_DAY;
constexpr int GuildQAType_ARRAYSIZE = GuildQAType_MAX + 1;

const std::string& GuildQAType_Name(GuildQAType value);
template<typename T>
inline const std::string& GuildQAType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GuildQAType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GuildQAType_Name.");
  return GuildQAType_Name(static_cast<GuildQAType>(enum_t_value));
}
bool GuildQAType_Parse(
    const std::string& name, GuildQAType* value);
enum CommentType : int {
  COMMENT_NEST = 1,
  COMMENT_DRAGON = 2,
  COMMENT_LADDER = 3,
  COMMENT_ATLAS = 4,
  COMMENT_PANDORA = 5,
  COMMENT_SPRITE = 6
};
bool CommentType_IsValid(int value);
constexpr CommentType CommentType_MIN = COMMENT_NEST;
constexpr CommentType CommentType_MAX = COMMENT_SPRITE;
constexpr int CommentType_ARRAYSIZE = CommentType_MAX + 1;

const std::string& CommentType_Name(CommentType value);
template<typename T>
inline const std::string& CommentType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CommentType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CommentType_Name.");
  return CommentType_Name(static_cast<CommentType>(enum_t_value));
}
bool CommentType_Parse(
    const std::string& name, CommentType* value);
enum PersonalCarrerReqType : int {
  PCRT_HOME_PAGE = 1,
  PCRT_PVP_PKINFO = 2,
  PCRT_TROPHY = 3
};
bool PersonalCarrerReqType_IsValid(int value);
constexpr PersonalCarrerReqType PersonalCarrerReqType_MIN = PCRT_HOME_PAGE;
constexpr PersonalCarrerReqType PersonalCarrerReqType_MAX = PCRT_TROPHY;
constexpr int PersonalCarrerReqType_ARRAYSIZE = PersonalCarrerReqType_MAX + 1;

const std::string& PersonalCarrerReqType_Name(PersonalCarrerReqType value);
template<typename T>
inline const std::string& PersonalCarrerReqType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PersonalCarrerReqType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PersonalCarrerReqType_Name.");
  return PersonalCarrerReqType_Name(static_cast<PersonalCarrerReqType>(enum_t_value));
}
bool PersonalCarrerReqType_Parse(
    const std::string& name, PersonalCarrerReqType* value);
enum CarrerDataType : int {
  CARRER_DATA_LEVEL = 1,
  CARRER_DATA_NEST = 2,
  CARRER_DATA_DRAGON = 3,
  CARRER_DATA_CREATEROLE = 4
};
bool CarrerDataType_IsValid(int value);
constexpr CarrerDataType CarrerDataType_MIN = CARRER_DATA_LEVEL;
constexpr CarrerDataType CarrerDataType_MAX = CARRER_DATA_CREATEROLE;
constexpr int CarrerDataType_ARRAYSIZE = CarrerDataType_MAX + 1;

const std::string& CarrerDataType_Name(CarrerDataType value);
template<typename T>
inline const std::string& CarrerDataType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CarrerDataType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CarrerDataType_Name.");
  return CarrerDataType_Name(static_cast<CarrerDataType>(enum_t_value));
}
bool CarrerDataType_Parse(
    const std::string& name, CarrerDataType* value);
enum MatchToWorldType : int {
  MTWT_ADD = 1,
  MTWT_DEL = 2,
  MTWT_MATCH_INWORLD = 3
};
bool MatchToWorldType_IsValid(int value);
constexpr MatchToWorldType MatchToWorldType_MIN = MTWT_ADD;
constexpr MatchToWorldType MatchToWorldType_MAX = MTWT_MATCH_INWORLD;
constexpr int MatchToWorldType_ARRAYSIZE = MatchToWorldType_MAX + 1;

const std::string& MatchToWorldType_Name(MatchToWorldType value);
template<typename T>
inline const std::string& MatchToWorldType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MatchToWorldType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MatchToWorldType_Name.");
  return MatchToWorldType_Name(static_cast<MatchToWorldType>(enum_t_value));
}
bool MatchToWorldType_Parse(
    const std::string& name, MatchToWorldType* value);
enum MentorTaskType : int {
  MentorTask_JoinGuild = 1,
  MentorTask_Jade = 2,
  MentorTask_Title = 3,
  MentorTask_Pandora = 4,
  MentorTask_StageTypeCount = 5,
  MentorTask_GuildCheckIn = 6,
  MentorTask_GuildAuctBenefit = 7,
  MentorTask_RiskStage = 8,
  MentorTask_ProtectCaptain = 9,
  MentorTask_TianTi = 10,
  MentorTask_Emblem = 11,
  MentorTask_DailyActive = 12,
  MentorTask_WorldBossCount = 13,
  MentorTask_BossRush = 14,
  MentorTask_StageStar = 15,
  MentorTask_SkyFloor = 16,
  MentorTask_TowerFloor = 17,
  MentorTask_WorldBossRank = 18,
  MentorTask_GuildBossCount = 19,
  MentorTask_DailyTask = 20,
  MentorTask_SkyCount = 21,
  MentorTask_AllEquipStengthen = 22,
  MentorTask_GuildTianTiCount = 23,
  MentorTask_MentorIntimacy = 24,
  MentorTask_IBShopBuy = 25,
  MentorTask_BuyPrivilege = 26,
  MentorTask_BuyFund = 27,
  MentorTask_BuyGift = 28,
  MentorTask_AllEquipQuality = 29,
  MentorTask_AuctBuy = 30,
  MentorTask_AuctSale = 31
};
bool MentorTaskType_IsValid(int value);
constexpr MentorTaskType MentorTaskType_MIN = MentorTask_JoinGuild;
constexpr MentorTaskType MentorTaskType_MAX = MentorTask_AuctSale;
constexpr int MentorTaskType_ARRAYSIZE = MentorTaskType_MAX + 1;

const std::string& MentorTaskType_Name(MentorTaskType value);
template<typename T>
inline const std::string& MentorTaskType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MentorTaskType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MentorTaskType_Name.");
  return MentorTaskType_Name(static_cast<MentorTaskType>(enum_t_value));
}
bool MentorTaskType_Parse(
    const std::string& name, MentorTaskType* value);
enum KKVsRoleState : int {
  KK_VS_ROLE_UNLOAD = 1,
  KK_VS_ROLE_NORMAL = 2,
  KK_VS_ROLE_DIE = 3,
  KK_VS_ROLE_QUIT = 4
};
bool KKVsRoleState_IsValid(int value);
constexpr KKVsRoleState KKVsRoleState_MIN = KK_VS_ROLE_UNLOAD;
constexpr KKVsRoleState KKVsRoleState_MAX = KK_VS_ROLE_QUIT;
constexpr int KKVsRoleState_ARRAYSIZE = KKVsRoleState_MAX + 1;

const std::string& KKVsRoleState_Name(KKVsRoleState value);
template<typename T>
inline const std::string& KKVsRoleState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, KKVsRoleState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function KKVsRoleState_Name.");
  return KKVsRoleState_Name(static_cast<KKVsRoleState>(enum_t_value));
}
bool KKVsRoleState_Parse(
    const std::string& name, KKVsRoleState* value);
enum KMatchType : int {
  KMT_NONE = 0,
  KMT_EXP = 1,
  KMT_PVP = 2,
  KMT_HERO = 3,
  KMT_PK = 4,
  KMT_LEAGUE = 5,
  KMT_SKYCRAFT = 6,
  KMT_PKTWO = 7,
  KMT_MOBA = 8,
  KMT_WEEKEND_ACT = 9,
  KMT_CUSTOM_PKTWO = 10,
  KMT_SURVIVE = 11
};
bool KMatchType_IsValid(int value);
constexpr KMatchType KMatchType_MIN = KMT_NONE;
constexpr KMatchType KMatchType_MAX = KMT_SURVIVE;
constexpr int KMatchType_ARRAYSIZE = KMatchType_MAX + 1;

const std::string& KMatchType_Name(KMatchType value);
template<typename T>
inline const std::string& KMatchType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, KMatchType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function KMatchType_Name.");
  return KMatchType_Name(static_cast<KMatchType>(enum_t_value));
}
bool KMatchType_Parse(
    const std::string& name, KMatchType* value);
enum GiftIbItemState : int {
  GiftIbWaitingReceipt = 1,
  GiftIbReply = 2
};
bool GiftIbItemState_IsValid(int value);
constexpr GiftIbItemState GiftIbItemState_MIN = GiftIbWaitingReceipt;
constexpr GiftIbItemState GiftIbItemState_MAX = GiftIbReply;
constexpr int GiftIbItemState_ARRAYSIZE = GiftIbItemState_MAX + 1;

const std::string& GiftIbItemState_Name(GiftIbItemState value);
template<typename T>
inline const std::string& GiftIbItemState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GiftIbItemState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GiftIbItemState_Name.");
  return GiftIbItemState_Name(static_cast<GiftIbItemState>(enum_t_value));
}
bool GiftIbItemState_Parse(
    const std::string& name, GiftIbItemState* value);
enum PayGiftIbStatus : int {
  PayGiftIbStatus_CreateBill = 1,
  PayGiftIbStatus_Fail = 2,
  PayGiftIbStatus_Success = 3,
  PayGiftIbStatus_SuccessNotAddItem = 4
};
bool PayGiftIbStatus_IsValid(int value);
constexpr PayGiftIbStatus PayGiftIbStatus_MIN = PayGiftIbStatus_CreateBill;
constexpr PayGiftIbStatus PayGiftIbStatus_MAX = PayGiftIbStatus_SuccessNotAddItem;
constexpr int PayGiftIbStatus_ARRAYSIZE = PayGiftIbStatus_MAX + 1;

const std::string& PayGiftIbStatus_Name(PayGiftIbStatus value);
template<typename T>
inline const std::string& PayGiftIbStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PayGiftIbStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PayGiftIbStatus_Name.");
  return PayGiftIbStatus_Name(static_cast<PayGiftIbStatus>(enum_t_value));
}
bool PayGiftIbStatus_Parse(
    const std::string& name, PayGiftIbStatus* value);
enum MysqlOpType : int {
  MYSQL_OP_ADD = 1,
  MYSQL_OP_UPDATE = 2,
  MYSQL_OP_DELETE = 3
};
bool MysqlOpType_IsValid(int value);
constexpr MysqlOpType MysqlOpType_MIN = MYSQL_OP_ADD;
constexpr MysqlOpType MysqlOpType_MAX = MYSQL_OP_DELETE;
constexpr int MysqlOpType_ARRAYSIZE = MysqlOpType_MAX + 1;

const std::string& MysqlOpType_Name(MysqlOpType value);
template<typename T>
inline const std::string& MysqlOpType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MysqlOpType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MysqlOpType_Name.");
  return MysqlOpType_Name(static_cast<MysqlOpType>(enum_t_value));
}
bool MysqlOpType_Parse(
    const std::string& name, MysqlOpType* value);
enum ArenaStarType : int {
  AST_PK = 1,
  AST_HEROBATTLE = 2,
  AST_WEEKNEST = 3,
  AST_LEAGUE = 4
};
bool ArenaStarType_IsValid(int value);
constexpr ArenaStarType ArenaStarType_MIN = AST_PK;
constexpr ArenaStarType ArenaStarType_MAX = AST_LEAGUE;
constexpr int ArenaStarType_ARRAYSIZE = ArenaStarType_MAX + 1;

const std::string& ArenaStarType_Name(ArenaStarType value);
template<typename T>
inline const std::string& ArenaStarType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ArenaStarType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ArenaStarType_Name.");
  return ArenaStarType_Name(static_cast<ArenaStarType>(enum_t_value));
}
bool ArenaStarType_Parse(
    const std::string& name, ArenaStarType* value);
enum ArenaStarReqType : int {
  ASRT_ROLEDATA = 1,
  ASRT_DIANZAN = 2
};
bool ArenaStarReqType_IsValid(int value);
constexpr ArenaStarReqType ArenaStarReqType_MIN = ASRT_ROLEDATA;
constexpr ArenaStarReqType ArenaStarReqType_MAX = ASRT_DIANZAN;
constexpr int ArenaStarReqType_ARRAYSIZE = ArenaStarReqType_MAX + 1;

const std::string& ArenaStarReqType_Name(ArenaStarReqType value);
template<typename T>
inline const std::string& ArenaStarReqType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ArenaStarReqType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ArenaStarReqType_Name.");
  return ArenaStarReqType_Name(static_cast<ArenaStarReqType>(enum_t_value));
}
bool ArenaStarReqType_Parse(
    const std::string& name, ArenaStarReqType* value);
enum SkyTeamState : int {
  SkyTeamState_Idle = 1,
  SkyTeamState_Match = 2,
  SkyTeamState_Battle = 3
};
bool SkyTeamState_IsValid(int value);
constexpr SkyTeamState SkyTeamState_MIN = SkyTeamState_Idle;
constexpr SkyTeamState SkyTeamState_MAX = SkyTeamState_Battle;
constexpr int SkyTeamState_ARRAYSIZE = SkyTeamState_MAX + 1;

const std::string& SkyTeamState_Name(SkyTeamState value);
template<typename T>
inline const std::string& SkyTeamState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SkyTeamState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SkyTeamState_Name.");
  return SkyTeamState_Name(static_cast<SkyTeamState>(enum_t_value));
}
bool SkyTeamState_Parse(
    const std::string& name, SkyTeamState* value);
enum SkyCraftMatchReqTpe : int {
  SCMR_Match = 1,
  SCMR_CancelMatch = 2
};
bool SkyCraftMatchReqTpe_IsValid(int value);
constexpr SkyCraftMatchReqTpe SkyCraftMatchReqTpe_MIN = SCMR_Match;
constexpr SkyCraftMatchReqTpe SkyCraftMatchReqTpe_MAX = SCMR_CancelMatch;
constexpr int SkyCraftMatchReqTpe_ARRAYSIZE = SkyCraftMatchReqTpe_MAX + 1;

const std::string& SkyCraftMatchReqTpe_Name(SkyCraftMatchReqTpe value);
template<typename T>
inline const std::string& SkyCraftMatchReqTpe_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SkyCraftMatchReqTpe>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SkyCraftMatchReqTpe_Name.");
  return SkyCraftMatchReqTpe_Name(static_cast<SkyCraftMatchReqTpe>(enum_t_value));
}
bool SkyCraftMatchReqTpe_Parse(
    const std::string& name, SkyCraftMatchReqTpe* value);
enum SkyCraftMatchNtfType : int {
  SCMN_Start = 1,
  SCMN_Stop = 2,
  SCMN_Timeout = 3
};
bool SkyCraftMatchNtfType_IsValid(int value);
constexpr SkyCraftMatchNtfType SkyCraftMatchNtfType_MIN = SCMN_Start;
constexpr SkyCraftMatchNtfType SkyCraftMatchNtfType_MAX = SCMN_Timeout;
constexpr int SkyCraftMatchNtfType_ARRAYSIZE = SkyCraftMatchNtfType_MAX + 1;

const std::string& SkyCraftMatchNtfType_Name(SkyCraftMatchNtfType value);
template<typename T>
inline const std::string& SkyCraftMatchNtfType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SkyCraftMatchNtfType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SkyCraftMatchNtfType_Name.");
  return SkyCraftMatchNtfType_Name(static_cast<SkyCraftMatchNtfType>(enum_t_value));
}
bool SkyCraftMatchNtfType_Parse(
    const std::string& name, SkyCraftMatchNtfType* value);
enum SkyCraftType : int {
  SCT_RacePoint = 1,
  SCT_Eliminate = 2
};
bool SkyCraftType_IsValid(int value);
constexpr SkyCraftType SkyCraftType_MIN = SCT_RacePoint;
constexpr SkyCraftType SkyCraftType_MAX = SCT_Eliminate;
constexpr int SkyCraftType_ARRAYSIZE = SkyCraftType_MAX + 1;

const std::string& SkyCraftType_Name(SkyCraftType value);
template<typename T>
inline const std::string& SkyCraftType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SkyCraftType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SkyCraftType_Name.");
  return SkyCraftType_Name(static_cast<SkyCraftType>(enum_t_value));
}
bool SkyCraftType_Parse(
    const std::string& name, SkyCraftType* value);
enum SCEliRoundType : int {
  SCEliRound_None = 0,
  SCEliRound_8to4 = 1,
  SCEliRound_4to2 = 2,
  SCEliRound_2to1 = 3
};
bool SCEliRoundType_IsValid(int value);
constexpr SCEliRoundType SCEliRoundType_MIN = SCEliRound_None;
constexpr SCEliRoundType SCEliRoundType_MAX = SCEliRound_2to1;
constexpr int SCEliRoundType_ARRAYSIZE = SCEliRoundType_MAX + 1;

const std::string& SCEliRoundType_Name(SCEliRoundType value);
template<typename T>
inline const std::string& SCEliRoundType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SCEliRoundType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SCEliRoundType_Name.");
  return SCEliRoundType_Name(static_cast<SCEliRoundType>(enum_t_value));
}
bool SCEliRoundType_Parse(
    const std::string& name, SCEliRoundType* value);
enum TeamMemberType : int {
  TMT_NORMAL = 1,
  TMT_HELPER = 2,
  TMT_USETICKET = 3
};
bool TeamMemberType_IsValid(int value);
constexpr TeamMemberType TeamMemberType_MIN = TMT_NORMAL;
constexpr TeamMemberType TeamMemberType_MAX = TMT_USETICKET;
constexpr int TeamMemberType_ARRAYSIZE = TeamMemberType_MAX + 1;

const std::string& TeamMemberType_Name(TeamMemberType value);
template<typename T>
inline const std::string& TeamMemberType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TeamMemberType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TeamMemberType_Name.");
  return TeamMemberType_Name(static_cast<TeamMemberType>(enum_t_value));
}
bool TeamMemberType_Parse(
    const std::string& name, TeamMemberType* value);
enum WeekReportDataType : int {
  WeekReportData_GuildSign = 1,
  WeekReportData_WorldBoss = 2,
  WeekReportData_GuildRisk = 3,
  WeekReportData_GuildArena = 4,
  WeekReportData_GuildBoss = 5,
  WeekReportData_GuildTerryitory = 6
};
bool WeekReportDataType_IsValid(int value);
constexpr WeekReportDataType WeekReportDataType_MIN = WeekReportData_GuildSign;
constexpr WeekReportDataType WeekReportDataType_MAX = WeekReportData_GuildTerryitory;
constexpr int WeekReportDataType_ARRAYSIZE = WeekReportDataType_MAX + 1;

const std::string& WeekReportDataType_Name(WeekReportDataType value);
template<typename T>
inline const std::string& WeekReportDataType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WeekReportDataType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WeekReportDataType_Name.");
  return WeekReportDataType_Name(static_cast<WeekReportDataType>(enum_t_value));
}
bool WeekReportDataType_Parse(
    const std::string& name, WeekReportDataType* value);
enum LeagueEliType : int {
  LeagueEliType_None = 1,
  LeagueEliType_Self = 2,
  LeagueEliType_Cross = 3
};
bool LeagueEliType_IsValid(int value);
constexpr LeagueEliType LeagueEliType_MIN = LeagueEliType_None;
constexpr LeagueEliType LeagueEliType_MAX = LeagueEliType_Cross;
constexpr int LeagueEliType_ARRAYSIZE = LeagueEliType_MAX + 1;

const std::string& LeagueEliType_Name(LeagueEliType value);
template<typename T>
inline const std::string& LeagueEliType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LeagueEliType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LeagueEliType_Name.");
  return LeagueEliType_Name(static_cast<LeagueEliType>(enum_t_value));
}
bool LeagueEliType_Parse(
    const std::string& name, LeagueEliType* value);
enum QueryResWarEnum : int {
  RESWAR_FLOWAWARD = 1,
  RESWAR_BATTLE = 2
};
bool QueryResWarEnum_IsValid(int value);
constexpr QueryResWarEnum QueryResWarEnum_MIN = RESWAR_FLOWAWARD;
constexpr QueryResWarEnum QueryResWarEnum_MAX = RESWAR_BATTLE;
constexpr int QueryResWarEnum_ARRAYSIZE = QueryResWarEnum_MAX + 1;

const std::string& QueryResWarEnum_Name(QueryResWarEnum value);
template<typename T>
inline const std::string& QueryResWarEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, QueryResWarEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function QueryResWarEnum_Name.");
  return QueryResWarEnum_Name(static_cast<QueryResWarEnum>(enum_t_value));
}
bool QueryResWarEnum_Parse(
    const std::string& name, QueryResWarEnum* value);
enum CustomBattleOp : int {
  CustomBattle_Query = 1,
  CustomBattle_Create = 2,
  CustomBattle_Join = 3,
  CustomBattle_Match = 4,
  CustomBattle_Reward = 5,
  CustomBattle_ClearCD = 6,
  CustomBattle_QueryRandom = 7,
  CustomBattle_QueryOne = 8,
  CustomBattle_DoCreate = 9,
  CustomBattle_DoJoin = 10,
  CustomBattle_UnJoin = 11,
  CustomBattle_UnMatch = 12,
  CustomBattle_Modify = 13,
  CustomBattle_QuerySelf = 14,
  CustomBattle_StartNow = 15,
  CustomBattle_DoClearCD = 16,
  CustomBattle_Drop = 17,
  CustomBattle_Search = 18
};
bool CustomBattleOp_IsValid(int value);
constexpr CustomBattleOp CustomBattleOp_MIN = CustomBattle_Query;
constexpr CustomBattleOp CustomBattleOp_MAX = CustomBattle_Search;
constexpr int CustomBattleOp_ARRAYSIZE = CustomBattleOp_MAX + 1;

const std::string& CustomBattleOp_Name(CustomBattleOp value);
template<typename T>
inline const std::string& CustomBattleOp_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CustomBattleOp>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CustomBattleOp_Name.");
  return CustomBattleOp_Name(static_cast<CustomBattleOp>(enum_t_value));
}
bool CustomBattleOp_Parse(
    const std::string& name, CustomBattleOp* value);
enum CustomBattleScale : int {
  CustomBattle_Scale_Friend = 1,
  CustomBattle_Scale_Guild = 2,
  CustomBattle_Scale_Server = 3,
  CustomBattle_Scale_All = 4
};
bool CustomBattleScale_IsValid(int value);
constexpr CustomBattleScale CustomBattleScale_MIN = CustomBattle_Scale_Friend;
constexpr CustomBattleScale CustomBattleScale_MAX = CustomBattle_Scale_All;
constexpr int CustomBattleScale_ARRAYSIZE = CustomBattleScale_MAX + 1;

const std::string& CustomBattleScale_Name(CustomBattleScale value);
template<typename T>
inline const std::string& CustomBattleScale_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CustomBattleScale>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CustomBattleScale_Name.");
  return CustomBattleScale_Name(static_cast<CustomBattleScale>(enum_t_value));
}
bool CustomBattleScale_Parse(
    const std::string& name, CustomBattleScale* value);
enum CustomBattleType : int {
  CustomBattle_PK_Normal = 1,
  CustomBattle_PKTwo_Normal = 2
};
bool CustomBattleType_IsValid(int value);
constexpr CustomBattleType CustomBattleType_MIN = CustomBattle_PK_Normal;
constexpr CustomBattleType CustomBattleType_MAX = CustomBattle_PKTwo_Normal;
constexpr int CustomBattleType_ARRAYSIZE = CustomBattleType_MAX + 1;

const std::string& CustomBattleType_Name(CustomBattleType value);
template<typename T>
inline const std::string& CustomBattleType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CustomBattleType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CustomBattleType_Name.");
  return CustomBattleType_Name(static_cast<CustomBattleType>(enum_t_value));
}
bool CustomBattleType_Parse(
    const std::string& name, CustomBattleType* value);
enum CustomBattleState : int {
  CustomBattle_Ready = 1,
  CustomBattle_Going = 2,
  CustomBattle_End = 3,
  CustomBattle_Destory = 4
};
bool CustomBattleState_IsValid(int value);
constexpr CustomBattleState CustomBattleState_MIN = CustomBattle_Ready;
constexpr CustomBattleState CustomBattleState_MAX = CustomBattle_Destory;
constexpr int CustomBattleState_ARRAYSIZE = CustomBattleState_MAX + 1;

const std::string& CustomBattleState_Name(CustomBattleState value);
template<typename T>
inline const std::string& CustomBattleState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CustomBattleState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CustomBattleState_Name.");
  return CustomBattleState_Name(static_cast<CustomBattleState>(enum_t_value));
}
bool CustomBattleState_Parse(
    const std::string& name, CustomBattleState* value);
enum CustomBattleRoleState : int {
  CustomBattle_RoleState_Ready = 1,
  CustomBattle_RoleState_Join = 2,
  CustomBattle_RoleState_Reward = 3,
  Custombattle_RoleState_Taken = 4
};
bool CustomBattleRoleState_IsValid(int value);
constexpr CustomBattleRoleState CustomBattleRoleState_MIN = CustomBattle_RoleState_Ready;
constexpr CustomBattleRoleState CustomBattleRoleState_MAX = Custombattle_RoleState_Taken;
constexpr int CustomBattleRoleState_ARRAYSIZE = CustomBattleRoleState_MAX + 1;

const std::string& CustomBattleRoleState_Name(CustomBattleRoleState value);
template<typename T>
inline const std::string& CustomBattleRoleState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CustomBattleRoleState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CustomBattleRoleState_Name.");
  return CustomBattleRoleState_Name(static_cast<CustomBattleRoleState>(enum_t_value));
}
bool CustomBattleRoleState_Parse(
    const std::string& name, CustomBattleRoleState* value);
enum SaveHistIbGiftEnum : int {
  SaveIbGift_All = 1,
  SaveIbGift_Self = 2,
  SaveIbGift_Target = 3
};
bool SaveHistIbGiftEnum_IsValid(int value);
constexpr SaveHistIbGiftEnum SaveHistIbGiftEnum_MIN = SaveIbGift_All;
constexpr SaveHistIbGiftEnum SaveHistIbGiftEnum_MAX = SaveIbGift_Target;
constexpr int SaveHistIbGiftEnum_ARRAYSIZE = SaveHistIbGiftEnum_MAX + 1;

const std::string& SaveHistIbGiftEnum_Name(SaveHistIbGiftEnum value);
template<typename T>
inline const std::string& SaveHistIbGiftEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SaveHistIbGiftEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SaveHistIbGiftEnum_Name.");
  return SaveHistIbGiftEnum_Name(static_cast<SaveHistIbGiftEnum>(enum_t_value));
}
bool SaveHistIbGiftEnum_Parse(
    const std::string& name, SaveHistIbGiftEnum* value);
enum GuildCampItemOperate : int {
  SWINGUPITEM = 1,
  SWINGDOWNITEM = 2,
  CANCEL = 3,
  CONFIRM = 4,
  AUDIOCHAT = 5,
  TEXTCHAT = 6
};
bool GuildCampItemOperate_IsValid(int value);
constexpr GuildCampItemOperate GuildCampItemOperate_MIN = SWINGUPITEM;
constexpr GuildCampItemOperate GuildCampItemOperate_MAX = TEXTCHAT;
constexpr int GuildCampItemOperate_ARRAYSIZE = GuildCampItemOperate_MAX + 1;

const std::string& GuildCampItemOperate_Name(GuildCampItemOperate value);
template<typename T>
inline const std::string& GuildCampItemOperate_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GuildCampItemOperate>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GuildCampItemOperate_Name.");
  return GuildCampItemOperate_Name(static_cast<GuildCampItemOperate>(enum_t_value));
}
bool GuildCampItemOperate_Parse(
    const std::string& name, GuildCampItemOperate* value);
enum GuildCampPartyTradeType : int {
  TRADE_INVITATION = 1,
  UPDATA_TRADE_STATUS = 2
};
bool GuildCampPartyTradeType_IsValid(int value);
constexpr GuildCampPartyTradeType GuildCampPartyTradeType_MIN = TRADE_INVITATION;
constexpr GuildCampPartyTradeType GuildCampPartyTradeType_MAX = UPDATA_TRADE_STATUS;
constexpr int GuildCampPartyTradeType_ARRAYSIZE = GuildCampPartyTradeType_MAX + 1;

const std::string& GuildCampPartyTradeType_Name(GuildCampPartyTradeType value);
template<typename T>
inline const std::string& GuildCampPartyTradeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GuildCampPartyTradeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GuildCampPartyTradeType_Name.");
  return GuildCampPartyTradeType_Name(static_cast<GuildCampPartyTradeType>(enum_t_value));
}
bool GuildCampPartyTradeType_Parse(
    const std::string& name, GuildCampPartyTradeType* value);
enum GiftIbShipStatus : int {
  GIFTIB_NOT_SHIPPED = 0,
  GIFTIB_BEING_SHIPPED = 1,
  GIFTIB_FINISH_SHIPPED = 2
};
bool GiftIbShipStatus_IsValid(int value);
constexpr GiftIbShipStatus GiftIbShipStatus_MIN = GIFTIB_NOT_SHIPPED;
constexpr GiftIbShipStatus GiftIbShipStatus_MAX = GIFTIB_FINISH_SHIPPED;
constexpr int GiftIbShipStatus_ARRAYSIZE = GiftIbShipStatus_MAX + 1;

const std::string& GiftIbShipStatus_Name(GiftIbShipStatus value);
template<typename T>
inline const std::string& GiftIbShipStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GiftIbShipStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GiftIbShipStatus_Name.");
  return GiftIbShipStatus_Name(static_cast<GiftIbShipStatus>(enum_t_value));
}
bool GiftIbShipStatus_Parse(
    const std::string& name, GiftIbShipStatus* value);
enum EmblemSlotType : int {
  EmblemSlotType_None = 0,
  EmblemSlotType_Attri = 1,
  EmblemSlotType_Skill = 2,
  EmblemSlotType_ExtraSkill = 3
};
bool EmblemSlotType_IsValid(int value);
constexpr EmblemSlotType EmblemSlotType_MIN = EmblemSlotType_None;
constexpr EmblemSlotType EmblemSlotType_MAX = EmblemSlotType_ExtraSkill;
constexpr int EmblemSlotType_ARRAYSIZE = EmblemSlotType_MAX + 1;

const std::string& EmblemSlotType_Name(EmblemSlotType value);
template<typename T>
inline const std::string& EmblemSlotType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EmblemSlotType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EmblemSlotType_Name.");
  return EmblemSlotType_Name(static_cast<EmblemSlotType>(enum_t_value));
}
bool EmblemSlotType_Parse(
    const std::string& name, EmblemSlotType* value);
enum KMatchOp : int {
  KMATCH_OP_START = 1,
  KMATCH_OP_STOP = 2
};
bool KMatchOp_IsValid(int value);
constexpr KMatchOp KMatchOp_MIN = KMATCH_OP_START;
constexpr KMatchOp KMatchOp_MAX = KMATCH_OP_STOP;
constexpr int KMatchOp_ARRAYSIZE = KMatchOp_MAX + 1;

const std::string& KMatchOp_Name(KMatchOp value);
template<typename T>
inline const std::string& KMatchOp_Name(T enum_t_value) {
  static_assert(::std::is_same<T, KMatchOp>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function KMatchOp_Name.");
  return KMatchOp_Name(static_cast<KMatchOp>(enum_t_value));
}
bool KMatchOp_Parse(
    const std::string& name, KMatchOp* value);
enum BagType : int {
  EquipBag = 1,
  EmblemBag = 2,
  ArtifactBag = 3,
  ItemBag = 4
};
bool BagType_IsValid(int value);
constexpr BagType BagType_MIN = EquipBag;
constexpr BagType BagType_MAX = ItemBag;
constexpr int BagType_ARRAYSIZE = BagType_MAX + 1;

const std::string& BagType_Name(BagType value);
template<typename T>
inline const std::string& BagType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BagType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BagType_Name.");
  return BagType_Name(static_cast<BagType>(enum_t_value));
}
bool BagType_Parse(
    const std::string& name, BagType* value);
enum CustomBattleTag : int {
  CustomBattle_Tag_Friend = 1,
  CustomBattle_Tag_Guild = 2,
  CustomBattle_Tag_Cross = 3,
  CustomBattle_Tag_GM = 4
};
bool CustomBattleTag_IsValid(int value);
constexpr CustomBattleTag CustomBattleTag_MIN = CustomBattle_Tag_Friend;
constexpr CustomBattleTag CustomBattleTag_MAX = CustomBattle_Tag_GM;
constexpr int CustomBattleTag_ARRAYSIZE = CustomBattleTag_MAX + 1;

const std::string& CustomBattleTag_Name(CustomBattleTag value);
template<typename T>
inline const std::string& CustomBattleTag_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CustomBattleTag>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CustomBattleTag_Name.");
  return CustomBattleTag_Name(static_cast<CustomBattleTag>(enum_t_value));
}
bool CustomBattleTag_Parse(
    const std::string& name, CustomBattleTag* value);
enum PkNVNType : int {
  PK_1v1 = 1,
  PK_2v2 = 2
};
bool PkNVNType_IsValid(int value);
constexpr PkNVNType PkNVNType_MIN = PK_1v1;
constexpr PkNVNType PkNVNType_MAX = PK_2v2;
constexpr int PkNVNType_ARRAYSIZE = PkNVNType_MAX + 1;

const std::string& PkNVNType_Name(PkNVNType value);
template<typename T>
inline const std::string& PkNVNType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PkNVNType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PkNVNType_Name.");
  return PkNVNType_Name(static_cast<PkNVNType>(enum_t_value));
}
bool PkNVNType_Parse(
    const std::string& name, PkNVNType* value);
enum ForgeOpType : int {
  Forge_Equip = 1,
  Forge_Replace = 2,
  Forge_Retain = 3
};
bool ForgeOpType_IsValid(int value);
constexpr ForgeOpType ForgeOpType_MIN = Forge_Equip;
constexpr ForgeOpType ForgeOpType_MAX = Forge_Retain;
constexpr int ForgeOpType_ARRAYSIZE = ForgeOpType_MAX + 1;

const std::string& ForgeOpType_Name(ForgeOpType value);
template<typename T>
inline const std::string& ForgeOpType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ForgeOpType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ForgeOpType_Name.");
  return ForgeOpType_Name(static_cast<ForgeOpType>(enum_t_value));
}
bool ForgeOpType_Parse(
    const std::string& name, ForgeOpType* value);
enum HeroKillUnitType : int {
  HeroKillUnit_Hero = 1,
  HeroKillUnit_Enemy = 2
};
bool HeroKillUnitType_IsValid(int value);
constexpr HeroKillUnitType HeroKillUnitType_MIN = HeroKillUnit_Hero;
constexpr HeroKillUnitType HeroKillUnitType_MAX = HeroKillUnit_Enemy;
constexpr int HeroKillUnitType_ARRAYSIZE = HeroKillUnitType_MAX + 1;

const std::string& HeroKillUnitType_Name(HeroKillUnitType value);
template<typename T>
inline const std::string& HeroKillUnitType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HeroKillUnitType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HeroKillUnitType_Name.");
  return HeroKillUnitType_Name(static_cast<HeroKillUnitType>(enum_t_value));
}
bool HeroKillUnitType_Parse(
    const std::string& name, HeroKillUnitType* value);
enum MobaOp : int {
  MobaOp_LevelSkill = 1,
  MobaOp_Upgrade = 2
};
bool MobaOp_IsValid(int value);
constexpr MobaOp MobaOp_MIN = MobaOp_LevelSkill;
constexpr MobaOp MobaOp_MAX = MobaOp_Upgrade;
constexpr int MobaOp_ARRAYSIZE = MobaOp_MAX + 1;

const std::string& MobaOp_Name(MobaOp value);
template<typename T>
inline const std::string& MobaOp_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MobaOp>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MobaOp_Name.");
  return MobaOp_Name(static_cast<MobaOp>(enum_t_value));
}
bool MobaOp_Parse(
    const std::string& name, MobaOp* value);
enum DHRState : int {
  DHR_CANNOT = 1,
  DHR_CAN_HAVEHOT = 2,
  DHR_CAN_HAVE = 3
};
bool DHRState_IsValid(int value);
constexpr DHRState DHRState_MIN = DHR_CANNOT;
constexpr DHRState DHRState_MAX = DHR_CAN_HAVE;
constexpr int DHRState_ARRAYSIZE = DHRState_MAX + 1;

const std::string& DHRState_Name(DHRState value);
template<typename T>
inline const std::string& DHRState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DHRState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DHRState_Name.");
  return DHRState_Name(static_cast<DHRState>(enum_t_value));
}
bool DHRState_Parse(
    const std::string& name, DHRState* value);
enum DHRReqOp : int {
  DHR_OP_LIST = 1,
  DHR_OP_FETCH_REWARD = 2,
  DHR_OP_WANT_BE_HELP = 3,
  DHR_OP_WANT_NOT_HELP = 4
};
bool DHRReqOp_IsValid(int value);
constexpr DHRReqOp DHRReqOp_MIN = DHR_OP_LIST;
constexpr DHRReqOp DHRReqOp_MAX = DHR_OP_WANT_NOT_HELP;
constexpr int DHRReqOp_ARRAYSIZE = DHRReqOp_MAX + 1;

const std::string& DHRReqOp_Name(DHRReqOp value);
template<typename T>
inline const std::string& DHRReqOp_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DHRReqOp>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DHRReqOp_Name.");
  return DHRReqOp_Name(static_cast<DHRReqOp>(enum_t_value));
}
bool DHRReqOp_Parse(
    const std::string& name, DHRReqOp* value);
enum PetOtherOp : int {
  DoPetPairRide = 1,
  InvitePetPairRide = 2,
  AgreePetPairRide = 3
};
bool PetOtherOp_IsValid(int value);
constexpr PetOtherOp PetOtherOp_MIN = DoPetPairRide;
constexpr PetOtherOp PetOtherOp_MAX = AgreePetPairRide;
constexpr int PetOtherOp_ARRAYSIZE = PetOtherOp_MAX + 1;

const std::string& PetOtherOp_Name(PetOtherOp value);
template<typename T>
inline const std::string& PetOtherOp_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PetOtherOp>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PetOtherOp_Name.");
  return PetOtherOp_Name(static_cast<PetOtherOp>(enum_t_value));
}
bool PetOtherOp_Parse(
    const std::string& name, PetOtherOp* value);
enum ArtifactComposeType : int {
  ArtifactCompose_Single = 1,
  ArtifactCompose_Multi = 2
};
bool ArtifactComposeType_IsValid(int value);
constexpr ArtifactComposeType ArtifactComposeType_MIN = ArtifactCompose_Single;
constexpr ArtifactComposeType ArtifactComposeType_MAX = ArtifactCompose_Multi;
constexpr int ArtifactComposeType_ARRAYSIZE = ArtifactComposeType_MAX + 1;

const std::string& ArtifactComposeType_Name(ArtifactComposeType value);
template<typename T>
inline const std::string& ArtifactComposeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ArtifactComposeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ArtifactComposeType_Name.");
  return ArtifactComposeType_Name(static_cast<ArtifactComposeType>(enum_t_value));
}
bool ArtifactComposeType_Parse(
    const std::string& name, ArtifactComposeType* value);
enum WeddingState : int {
  WeddingState_Prepare = 1,
  WeddingState_Running = 2
};
bool WeddingState_IsValid(int value);
constexpr WeddingState WeddingState_MIN = WeddingState_Prepare;
constexpr WeddingState WeddingState_MAX = WeddingState_Running;
constexpr int WeddingState_ARRAYSIZE = WeddingState_MAX + 1;

const std::string& WeddingState_Name(WeddingState value);
template<typename T>
inline const std::string& WeddingState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WeddingState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WeddingState_Name.");
  return WeddingState_Name(static_cast<WeddingState>(enum_t_value));
}
bool WeddingState_Parse(
    const std::string& name, WeddingState* value);
enum WeddingType : int {
  WeddingType_Normal = 1,
  WeddingType_Luxury = 2
};
bool WeddingType_IsValid(int value);
constexpr WeddingType WeddingType_MIN = WeddingType_Normal;
constexpr WeddingType WeddingType_MAX = WeddingType_Luxury;
constexpr int WeddingType_ARRAYSIZE = WeddingType_MAX + 1;

const std::string& WeddingType_Name(WeddingType value);
template<typename T>
inline const std::string& WeddingType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WeddingType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WeddingType_Name.");
  return WeddingType_Name(static_cast<WeddingType>(enum_t_value));
}
bool WeddingType_Parse(
    const std::string& name, WeddingType* value);
enum MarriageOpType : int {
  MarriageOpType_MarryApply = 1,
  MarriageOpType_MarryAgree = 2,
  MarriageOpType_MarryRefuse = 3,
  MarriageOpType_Divorce = 4,
  MarriageOpType_DivorceCancel = 5,
  MarriageOpType_Max = 6
};
bool MarriageOpType_IsValid(int value);
constexpr MarriageOpType MarriageOpType_MIN = MarriageOpType_MarryApply;
constexpr MarriageOpType MarriageOpType_MAX = MarriageOpType_Max;
constexpr int MarriageOpType_ARRAYSIZE = MarriageOpType_MAX + 1;

const std::string& MarriageOpType_Name(MarriageOpType value);
template<typename T>
inline const std::string& MarriageOpType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MarriageOpType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MarriageOpType_Name.");
  return MarriageOpType_Name(static_cast<MarriageOpType>(enum_t_value));
}
bool MarriageOpType_Parse(
    const std::string& name, MarriageOpType* value);
enum MarriageStatus : int {
  MarriageStatus_Null = 1,
  MarriageStatus_Marriaged = 2,
  MarriageStatus_WeddingHoldingNoCar = 3,
  MarriageStatus_WeddingHoldedNoCar = 4,
  MarriageStatus_WeddingCarNoWedding = 5,
  MarriageStatus_WeddingHoldingAndCar = 6,
  MarriageStatus_WeddingHoldedAndCar = 7,
  MarriageStatus_DivorceApply = 8,
  MarriageStatus_Divorced = 9,
  MarriageStatus_Max = 10
};
bool MarriageStatus_IsValid(int value);
constexpr MarriageStatus MarriageStatus_MIN = MarriageStatus_Null;
constexpr MarriageStatus MarriageStatus_MAX = MarriageStatus_Max;
constexpr int MarriageStatus_ARRAYSIZE = MarriageStatus_MAX + 1;

const std::string& MarriageStatus_Name(MarriageStatus value);
template<typename T>
inline const std::string& MarriageStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MarriageStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MarriageStatus_Name.");
  return MarriageStatus_Name(static_cast<MarriageStatus>(enum_t_value));
}
bool MarriageStatus_Parse(
    const std::string& name, MarriageStatus* value);
enum WeddingInviteOperType : int {
  Wedding_Invite = 1,
  Wedding_Apply = 2,
  Wedding_AgreeApply = 3,
  Wedding_DisagreeApply = 4,
  Wedding_PermitStranger = 5,
  Wedding_ForbidStranger = 6,
  Wedding_CarCutScene = 7,
  Wedding_Start = 8
};
bool WeddingInviteOperType_IsValid(int value);
constexpr WeddingInviteOperType WeddingInviteOperType_MIN = Wedding_Invite;
constexpr WeddingInviteOperType WeddingInviteOperType_MAX = Wedding_Start;
constexpr int WeddingInviteOperType_ARRAYSIZE = WeddingInviteOperType_MAX + 1;

const std::string& WeddingInviteOperType_Name(WeddingInviteOperType value);
template<typename T>
inline const std::string& WeddingInviteOperType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WeddingInviteOperType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WeddingInviteOperType_Name.");
  return WeddingInviteOperType_Name(static_cast<WeddingInviteOperType>(enum_t_value));
}
bool WeddingInviteOperType_Parse(
    const std::string& name, WeddingInviteOperType* value);
enum MarriagePos : int {
  MarriagePos_Null = 1,
  MarriagePos_Husband = 2,
  MarriagePos_Wife = 3,
  Marriage_Max = 4
};
bool MarriagePos_IsValid(int value);
constexpr MarriagePos MarriagePos_MIN = MarriagePos_Null;
constexpr MarriagePos MarriagePos_MAX = Marriage_Max;
constexpr int MarriagePos_ARRAYSIZE = MarriagePos_MAX + 1;

const std::string& MarriagePos_Name(MarriagePos value);
template<typename T>
inline const std::string& MarriagePos_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MarriagePos>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MarriagePos_Name.");
  return MarriagePos_Name(static_cast<MarriagePos>(enum_t_value));
}
bool MarriagePos_Parse(
    const std::string& name, MarriagePos* value);
enum WeddingOperType : int {
  WeddingOper_Flower = 1,
  WeddingOper_Fireworks = 2,
  WeddingOper_ApplyVows = 3,
  WeddingOper_AgreeVows = 4,
  WeddingOper_DisAgreeVows = 5,
  WeddingOper_VowsPrepare = 6,
  WeddingOper_VowsStart = 7,
  WeddingOper_FlowerRewardOverMax = 8,
  WeddingOper_FireworksRewardOverMax = 9,
  WeddingOper_CandyRewardOverMax = 10,
  WeddingOper_Candy = 11,
  WeddingOper_RoleNum = 12
};
bool WeddingOperType_IsValid(int value);
constexpr WeddingOperType WeddingOperType_MIN = WeddingOper_Flower;
constexpr WeddingOperType WeddingOperType_MAX = WeddingOper_RoleNum;
constexpr int WeddingOperType_ARRAYSIZE = WeddingOperType_MAX + 1;

const std::string& WeddingOperType_Name(WeddingOperType value);
template<typename T>
inline const std::string& WeddingOperType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WeddingOperType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WeddingOperType_Name.");
  return WeddingOperType_Name(static_cast<WeddingOperType>(enum_t_value));
}
bool WeddingOperType_Parse(
    const std::string& name, WeddingOperType* value);
enum ArtifactDeityStoveOpType : int {
  ArtifactDeityStove_Recast = 1,
  ArtifactDeityStove_Fuse = 2,
  ArtifactDeityStove_Inscription = 3
};
bool ArtifactDeityStoveOpType_IsValid(int value);
constexpr ArtifactDeityStoveOpType ArtifactDeityStoveOpType_MIN = ArtifactDeityStove_Recast;
constexpr ArtifactDeityStoveOpType ArtifactDeityStoveOpType_MAX = ArtifactDeityStove_Inscription;
constexpr int ArtifactDeityStoveOpType_ARRAYSIZE = ArtifactDeityStoveOpType_MAX + 1;

const std::string& ArtifactDeityStoveOpType_Name(ArtifactDeityStoveOpType value);
template<typename T>
inline const std::string& ArtifactDeityStoveOpType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ArtifactDeityStoveOpType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ArtifactDeityStoveOpType_Name.");
  return ArtifactDeityStoveOpType_Name(static_cast<ArtifactDeityStoveOpType>(enum_t_value));
}
bool ArtifactDeityStoveOpType_Parse(
    const std::string& name, ArtifactDeityStoveOpType* value);
enum DragonWeakType : int {
  DragonWeakType_Null = 1,
  DragonWeakType_Pass = 2,
  DragonWeakType_NotPass = 3,
  DragonWeakType_Max = 4
};
bool DragonWeakType_IsValid(int value);
constexpr DragonWeakType DragonWeakType_MIN = DragonWeakType_Null;
constexpr DragonWeakType DragonWeakType_MAX = DragonWeakType_Max;
constexpr int DragonWeakType_ARRAYSIZE = DragonWeakType_MAX + 1;

const std::string& DragonWeakType_Name(DragonWeakType value);
template<typename T>
inline const std::string& DragonWeakType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DragonWeakType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DragonWeakType_Name.");
  return DragonWeakType_Name(static_cast<DragonWeakType>(enum_t_value));
}
bool DragonWeakType_Parse(
    const std::string& name, DragonWeakType* value);
enum BattleFieldType : int {
  BATTLE_FIELD_READY_ENTER = 1,
  BATTLE_FIELD_READY_LEAVE = 2
};
bool BattleFieldType_IsValid(int value);
constexpr BattleFieldType BattleFieldType_MIN = BATTLE_FIELD_READY_ENTER;
constexpr BattleFieldType BattleFieldType_MAX = BATTLE_FIELD_READY_LEAVE;
constexpr int BattleFieldType_ARRAYSIZE = BattleFieldType_MAX + 1;

const std::string& BattleFieldType_Name(BattleFieldType value);
template<typename T>
inline const std::string& BattleFieldType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BattleFieldType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BattleFieldType_Name.");
  return BattleFieldType_Name(static_cast<BattleFieldType>(enum_t_value));
}
bool BattleFieldType_Parse(
    const std::string& name, BattleFieldType* value);
enum DragonGuildTaskType : int {
  TASK_NORMAL = 1,
  TASK_ACHIVEMENT = 2
};
bool DragonGuildTaskType_IsValid(int value);
constexpr DragonGuildTaskType DragonGuildTaskType_MIN = TASK_NORMAL;
constexpr DragonGuildTaskType DragonGuildTaskType_MAX = TASK_ACHIVEMENT;
constexpr int DragonGuildTaskType_ARRAYSIZE = DragonGuildTaskType_MAX + 1;

const std::string& DragonGuildTaskType_Name(DragonGuildTaskType value);
template<typename T>
inline const std::string& DragonGuildTaskType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DragonGuildTaskType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DragonGuildTaskType_Name.");
  return DragonGuildTaskType_Name(static_cast<DragonGuildTaskType>(enum_t_value));
}
bool DragonGuildTaskType_Parse(
    const std::string& name, DragonGuildTaskType* value);
enum DragonGuildTaskConditionType : int {
  TASK_PASS_SCENE = 1,
  TASK_PASS_NODIE = 2,
  TASK_TIME_SPAN = 3,
  TASK_PASS_PARTNER_COUNT = 4
};
bool DragonGuildTaskConditionType_IsValid(int value);
constexpr DragonGuildTaskConditionType DragonGuildTaskConditionType_MIN = TASK_PASS_SCENE;
constexpr DragonGuildTaskConditionType DragonGuildTaskConditionType_MAX = TASK_PASS_PARTNER_COUNT;
constexpr int DragonGuildTaskConditionType_ARRAYSIZE = DragonGuildTaskConditionType_MAX + 1;

const std::string& DragonGuildTaskConditionType_Name(DragonGuildTaskConditionType value);
template<typename T>
inline const std::string& DragonGuildTaskConditionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DragonGuildTaskConditionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DragonGuildTaskConditionType_Name.");
  return DragonGuildTaskConditionType_Name(static_cast<DragonGuildTaskConditionType>(enum_t_value));
}
bool DragonGuildTaskConditionType_Parse(
    const std::string& name, DragonGuildTaskConditionType* value);
enum DragonGuildSortType : int {
  DragonGuildSortByLevel = 1,
  DragonGuildSortByMemberCount = 2,
  DragongGuildSortByTotalPPT = 3,
  DragonGuildSortBySceneID = 4,
  DragonGuildSortByName = 5,
  DragonGuildSortByLeaderName = 6
};
bool DragonGuildSortType_IsValid(int value);
constexpr DragonGuildSortType DragonGuildSortType_MIN = DragonGuildSortByLevel;
constexpr DragonGuildSortType DragonGuildSortType_MAX = DragonGuildSortByLeaderName;
constexpr int DragonGuildSortType_ARRAYSIZE = DragonGuildSortType_MAX + 1;

const std::string& DragonGuildSortType_Name(DragonGuildSortType value);
template<typename T>
inline const std::string& DragonGuildSortType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DragonGuildSortType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DragonGuildSortType_Name.");
  return DragonGuildSortType_Name(static_cast<DragonGuildSortType>(enum_t_value));
}
bool DragonGuildSortType_Parse(
    const std::string& name, DragonGuildSortType* value);
enum DragonGuildUpdateType : int {
  DUType_AddMember = 1,
  DUType_LeaveMember = 2,
  DUType_Dissmiss = 3,
  DUType_ShopRefresh = 4,
  DUType_Level = 5
};
bool DragonGuildUpdateType_IsValid(int value);
constexpr DragonGuildUpdateType DragonGuildUpdateType_MIN = DUType_AddMember;
constexpr DragonGuildUpdateType DragonGuildUpdateType_MAX = DUType_Level;
constexpr int DragonGuildUpdateType_ARRAYSIZE = DragonGuildUpdateType_MAX + 1;

const std::string& DragonGuildUpdateType_Name(DragonGuildUpdateType value);
template<typename T>
inline const std::string& DragonGuildUpdateType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DragonGuildUpdateType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DragonGuildUpdateType_Name.");
  return DragonGuildUpdateType_Name(static_cast<DragonGuildUpdateType>(enum_t_value));
}
bool DragonGuildUpdateType_Parse(
    const std::string& name, DragonGuildUpdateType* value);
enum CompeteDragonOpArg : int {
  CompeteDragon_GetInfo = 1,
  CompeteDragon_GetReward = 2
};
bool CompeteDragonOpArg_IsValid(int value);
constexpr CompeteDragonOpArg CompeteDragonOpArg_MIN = CompeteDragon_GetInfo;
constexpr CompeteDragonOpArg CompeteDragonOpArg_MAX = CompeteDragon_GetReward;
constexpr int CompeteDragonOpArg_ARRAYSIZE = CompeteDragonOpArg_MAX + 1;

const std::string& CompeteDragonOpArg_Name(CompeteDragonOpArg value);
template<typename T>
inline const std::string& CompeteDragonOpArg_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CompeteDragonOpArg>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CompeteDragonOpArg_Name.");
  return CompeteDragonOpArg_Name(static_cast<CompeteDragonOpArg>(enum_t_value));
}
bool CompeteDragonOpArg_Parse(
    const std::string& name, CompeteDragonOpArg* value);
enum TaskConnType : int {
  TaskConn_ItemID = 1,
  TaskConn_StageID = 2,
  TaskConn_MonsterID = 3,
  TaskConn_ItemTypeQuality = 4,
  TaskConn_Activity = 5,
  TaskConn_WorldBossRank = 6,
  TaskConn_StageType = 7
};
bool TaskConnType_IsValid(int value);
constexpr TaskConnType TaskConnType_MIN = TaskConn_ItemID;
constexpr TaskConnType TaskConnType_MAX = TaskConn_StageType;
constexpr int TaskConnType_ARRAYSIZE = TaskConnType_MAX + 1;

const std::string& TaskConnType_Name(TaskConnType value);
template<typename T>
inline const std::string& TaskConnType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TaskConnType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TaskConnType_Name.");
  return TaskConnType_Name(static_cast<TaskConnType>(enum_t_value));
}
bool TaskConnType_Parse(
    const std::string& name, TaskConnType* value);
enum TaskActivityType : int {
  TaskActType_Dragonexp = 1,
  TaskActType_Tower = 2,
  TaskActType_SuperRisk = 3,
  TaskActType_SkyCityRound = 4,
  TaskActType_BigmeleeKill = 5,
  TaskActType_BigmeleeScore = 6,
  TaskActType_GuildBoss = 7,
  TaskActType_HeroBattleWin = 8,
  TaskActType_PkWin = 9,
  TaskActType_Help = 10,
  TaskActType_DonateItem = 11,
  TaskActType_Fish = 12,
  TaskActType_GardenSteal = 13,
  TaskActType_GardenHarvest = 14,
  TaskActType_Cooking = 15,
  TaskActType_Banquet = 16,
  TaskActType_JoinBanquet = 17,
  TaskActType_WorldBoss = 18
};
bool TaskActivityType_IsValid(int value);
constexpr TaskActivityType TaskActivityType_MIN = TaskActType_Dragonexp;
constexpr TaskActivityType TaskActivityType_MAX = TaskActType_WorldBoss;
constexpr int TaskActivityType_ARRAYSIZE = TaskActivityType_MAX + 1;

const std::string& TaskActivityType_Name(TaskActivityType value);
template<typename T>
inline const std::string& TaskActivityType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TaskActivityType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TaskActivityType_Name.");
  return TaskActivityType_Name(static_cast<TaskActivityType>(enum_t_value));
}
bool TaskActivityType_Parse(
    const std::string& name, TaskActivityType* value);
enum PeriodTaskType : int {
  PeriodTaskType_Daily = 1,
  PeriodTaskType_Weekly = 2
};
bool PeriodTaskType_IsValid(int value);
constexpr PeriodTaskType PeriodTaskType_MIN = PeriodTaskType_Daily;
constexpr PeriodTaskType PeriodTaskType_MAX = PeriodTaskType_Weekly;
constexpr int PeriodTaskType_ARRAYSIZE = PeriodTaskType_MAX + 1;

const std::string& PeriodTaskType_Name(PeriodTaskType value);
template<typename T>
inline const std::string& PeriodTaskType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PeriodTaskType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PeriodTaskType_Name.");
  return PeriodTaskType_Name(static_cast<PeriodTaskType>(enum_t_value));
}
bool PeriodTaskType_Parse(
    const std::string& name, PeriodTaskType* value);
enum TaskOper : int {
  TaskOper_Set = 1,
  TaskOper_Add = 2,
  TaskOper_Del = 3
};
bool TaskOper_IsValid(int value);
constexpr TaskOper TaskOper_MIN = TaskOper_Set;
constexpr TaskOper TaskOper_MAX = TaskOper_Del;
constexpr int TaskOper_ARRAYSIZE = TaskOper_MAX + 1;

const std::string& TaskOper_Name(TaskOper value);
template<typename T>
inline const std::string& TaskOper_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TaskOper>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TaskOper_Name.");
  return TaskOper_Name(static_cast<TaskOper>(enum_t_value));
}
bool TaskOper_Parse(
    const std::string& name, TaskOper* value);
enum NpcFlReqType : int {
  NPCFL_GIVE_GIFT = 1,
  NPCFL_EXCHANGE = 2,
  NPCFL_BASE_DATA = 3,
  NPCFL_NPC_LEVEL_UP = 4,
  NPCFL_UNITE_ACT = 5,
  NPCFL_BUY_GIFT_COUNT = 6
};
bool NpcFlReqType_IsValid(int value);
constexpr NpcFlReqType NpcFlReqType_MIN = NPCFL_GIVE_GIFT;
constexpr NpcFlReqType NpcFlReqType_MAX = NPCFL_BUY_GIFT_COUNT;
constexpr int NpcFlReqType_ARRAYSIZE = NpcFlReqType_MAX + 1;

const std::string& NpcFlReqType_Name(NpcFlReqType value);
template<typename T>
inline const std::string& NpcFlReqType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NpcFlReqType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NpcFlReqType_Name.");
  return NpcFlReqType_Name(static_cast<NpcFlReqType>(enum_t_value));
}
bool NpcFlReqType_Parse(
    const std::string& name, NpcFlReqType* value);
enum NpcFlItemType : int {
  NPCFL_ITEM_NORMAL = 1,
  NPCFL_ITEM_RANDOM = 2,
  NPCFL_ITEM_TRIGGER_FAVOR = 3
};
bool NpcFlItemType_IsValid(int value);
constexpr NpcFlItemType NpcFlItemType_MIN = NPCFL_ITEM_NORMAL;
constexpr NpcFlItemType NpcFlItemType_MAX = NPCFL_ITEM_TRIGGER_FAVOR;
constexpr int NpcFlItemType_ARRAYSIZE = NpcFlItemType_MAX + 1;

const std::string& NpcFlItemType_Name(NpcFlItemType value);
template<typename T>
inline const std::string& NpcFlItemType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NpcFlItemType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NpcFlItemType_Name.");
  return NpcFlItemType_Name(static_cast<NpcFlItemType>(enum_t_value));
}
bool NpcFlItemType_Parse(
    const std::string& name, NpcFlItemType* value);
enum DailyRefreshOperType : int {
  DROT_Refresh = 1,
  DROT_Refuse = 2,
  DROT_BuyCount = 3,
  DROT_AskHelp = 4
};
bool DailyRefreshOperType_IsValid(int value);
constexpr DailyRefreshOperType DailyRefreshOperType_MIN = DROT_Refresh;
constexpr DailyRefreshOperType DailyRefreshOperType_MAX = DROT_AskHelp;
constexpr int DailyRefreshOperType_ARRAYSIZE = DailyRefreshOperType_MAX + 1;

const std::string& DailyRefreshOperType_Name(DailyRefreshOperType value);
template<typename T>
inline const std::string& DailyRefreshOperType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DailyRefreshOperType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DailyRefreshOperType_Name.");
  return DailyRefreshOperType_Name(static_cast<DailyRefreshOperType>(enum_t_value));
}
bool DailyRefreshOperType_Parse(
    const std::string& name, DailyRefreshOperType* value);
enum DailyTaskIconType : int {
  DailyTaskIcon_AskHelp = 1,
  DailyTaskIcon_BeHelp = 2
};
bool DailyTaskIconType_IsValid(int value);
constexpr DailyTaskIconType DailyTaskIconType_MIN = DailyTaskIcon_AskHelp;
constexpr DailyTaskIconType DailyTaskIconType_MAX = DailyTaskIcon_BeHelp;
constexpr int DailyTaskIconType_ARRAYSIZE = DailyTaskIconType_MAX + 1;

const std::string& DailyTaskIconType_Name(DailyTaskIconType value);
template<typename T>
inline const std::string& DailyTaskIconType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DailyTaskIconType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DailyTaskIconType_Name.");
  return DailyTaskIconType_Name(static_cast<DailyTaskIconType>(enum_t_value));
}
bool DailyTaskIconType_Parse(
    const std::string& name, DailyTaskIconType* value);
enum SurviveFightEndType : int {
  SURVIVE_LOAD_TIMEOUT = 1,
  SURVIVE_DIE = 2,
  SURVIVE_QUIT = 3,
  SURVIVE_WIN = 4
};
bool SurviveFightEndType_IsValid(int value);
constexpr SurviveFightEndType SurviveFightEndType_MIN = SURVIVE_LOAD_TIMEOUT;
constexpr SurviveFightEndType SurviveFightEndType_MAX = SURVIVE_WIN;
constexpr int SurviveFightEndType_ARRAYSIZE = SurviveFightEndType_MAX + 1;

const std::string& SurviveFightEndType_Name(SurviveFightEndType value);
template<typename T>
inline const std::string& SurviveFightEndType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SurviveFightEndType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SurviveFightEndType_Name.");
  return SurviveFightEndType_Name(static_cast<SurviveFightEndType>(enum_t_value));
}
bool SurviveFightEndType_Parse(
    const std::string& name, SurviveFightEndType* value);
enum SurviveFightStage : int {
  SURVIVE_STAGE_READY = 1,
  SURVIVE_STAGE_FIGHT = 2
};
bool SurviveFightStage_IsValid(int value);
constexpr SurviveFightStage SurviveFightStage_MIN = SURVIVE_STAGE_READY;
constexpr SurviveFightStage SurviveFightStage_MAX = SURVIVE_STAGE_FIGHT;
constexpr int SurviveFightStage_ARRAYSIZE = SurviveFightStage_MAX + 1;

const std::string& SurviveFightStage_Name(SurviveFightStage value);
template<typename T>
inline const std::string& SurviveFightStage_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SurviveFightStage>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SurviveFightStage_Name.");
  return SurviveFightStage_Name(static_cast<SurviveFightStage>(enum_t_value));
}
bool SurviveFightStage_Parse(
    const std::string& name, SurviveFightStage* value);
enum BackFlowActOp : int {
  BackFlowAct_TreasureData = 1,
  BackFlowAct_GetTreasure = 2,
  BackFlowAct_ShopData = 3,
  BackFlowAct_ShopBuy = 4,
  BackFlowAct_ShopUpdate = 5
};
bool BackFlowActOp_IsValid(int value);
constexpr BackFlowActOp BackFlowActOp_MIN = BackFlowAct_TreasureData;
constexpr BackFlowActOp BackFlowActOp_MAX = BackFlowAct_ShopUpdate;
constexpr int BackFlowActOp_ARRAYSIZE = BackFlowActOp_MAX + 1;

const std::string& BackFlowActOp_Name(BackFlowActOp value);
template<typename T>
inline const std::string& BackFlowActOp_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BackFlowActOp>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BackFlowActOp_Name.");
  return BackFlowActOp_Name(static_cast<BackFlowActOp>(enum_t_value));
}
bool BackFlowActOp_Parse(
    const std::string& name, BackFlowActOp* value);
// ===================================================================


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace KKSG

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::KKSG::KickType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::ErrorCode> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::RoleType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::SceneType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::TableDef> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::EntitySpecies> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::BattleChestRewardType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::TaskOPEnum> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::ResetType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::LotteryType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::EntityCategory> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::RankeType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::MythShopOP> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::SystemRewardType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::TeamState> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::TeamOperate> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::ExpTeamMemberState> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::UnitAppearanceField> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::ChatChannel> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::LoginType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::FashionNTFType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::GuildSortType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::GuildMemberFlag> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::GuildLogType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::GuildLogEnum> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::GuildBonusType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::BoxType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::FightGroupType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::XQTEState> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::SceneFinishState> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::FishingState> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::AuctionSortType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::AuctionAccountType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::PetOP> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::CampID> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::FortType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::FortStatus> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::AuctDBDataOperate> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::CampTaskType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::CampTaskStatus> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::AbyssFlameStage> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::ExpBackType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::LogDBType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::buyextype> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::DesignationType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::AchieveType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::RewardStatus> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::LevelSealButtonType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::PlatType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::GameAppType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::LoginRewardState> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::PvpReqType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::FriendOpType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::FriendGiftSend> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::FriendGiftReceive> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::EnterSceneType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::RoleDataReadType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::LeaveSceneType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::InvHReqType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::MulActivityTimeState> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::XSkillSlot> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::LiveType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::BossRushReqStatus> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::StopMatchReason> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::GuildMatchFightState> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::TeamInvRoleState> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::ReadAccountDataType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::LogoutType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::MailOpType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::WorldBossState> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::GuildArenaState> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::GMFFailReason> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::PVP_ONEGAMEEND_REASON> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::SynsMsType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::SynsMsSubType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::NoticeType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::MSGiveItemType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::RoleState> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::SyncTeamM2C> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::PayCardType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::PayParamType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::PayButtonStatus> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::MSUseSumamryType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::TeamEventG2M> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::PkReqType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::AuctionReqType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::PunishType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::PunishDataType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::ServerTag> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::ItemFindBackType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::OutLookType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::SpriteType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::RiskGridType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::RiskBoxState> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::DEProgressState> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::ReviveType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::GuildOpType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::AuctionAllReqType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::ItemEnum> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::GuildCardOp> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::PkResultType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::HallIconState> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::TaskStatus> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::SkyCityTimeType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::GMFReadyType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::CardMatchOp> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::CardMatchState> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::GuildBindStatus> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::GmfBattleState> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::BroadCastType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::ActOpenState> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::PlantGrowState> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::GardenPlayEventType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::GMF_FINAL_WIN_TYPE> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::RoleEventType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::WageRewardState> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::ItemUseOp> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::ResWarTimeType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::ResWarResult> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::GuildAuctReqType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::GardenQuestType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::GuildArenaType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::StageRankCond> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::GuildAuctResultType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::IntegralState> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::ResWarState> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::ServerFlag> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::EnumServerState> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::OutLookStateType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::FunctionId> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::LeaveTeamType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::StartUpType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::AntiAddictionReportType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::DBOperType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::MentorApplyStatus> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::MentorRelationStatus> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::MentorMsgApplyType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::MentorRelationOpType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::EMentorRelationPosition> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::EMentorTaskStatus> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::EMentorMsgOpType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::PartnerUpdateType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::PartnerOperType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::InvFightReqType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::InvFightNotifyType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::GCFReqType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::GCFJvDianType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::GCFZhanLingType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::GCFsynType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::GUILDTERRTYPE> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::GCFG2CSynType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::UnitSpecialState> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::PayAccessDataType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::BroadCastG2RType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::HeroBattleOver> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::LeagueBattleTimeState> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::LeagueBattleReqType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::LeagueTeamState> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::LeagueBattleRoleState> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::LeagueBattleReadyOper> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::LeagueBattleType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::SkillTypeEnum> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::LeagueBattleFightState> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::LBEleRoomState> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::GuildQAType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::CommentType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::PersonalCarrerReqType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::CarrerDataType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::MatchToWorldType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::MentorTaskType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::KKVsRoleState> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::KMatchType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::GiftIbItemState> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::PayGiftIbStatus> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::MysqlOpType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::ArenaStarType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::ArenaStarReqType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::SkyTeamState> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::SkyCraftMatchReqTpe> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::SkyCraftMatchNtfType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::SkyCraftType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::SCEliRoundType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::TeamMemberType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::WeekReportDataType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::LeagueEliType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::QueryResWarEnum> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::CustomBattleOp> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::CustomBattleScale> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::CustomBattleType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::CustomBattleState> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::CustomBattleRoleState> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::SaveHistIbGiftEnum> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::GuildCampItemOperate> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::GuildCampPartyTradeType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::GiftIbShipStatus> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::EmblemSlotType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::KMatchOp> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::BagType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::CustomBattleTag> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::PkNVNType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::ForgeOpType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::HeroKillUnitType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::MobaOp> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::DHRState> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::DHRReqOp> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::PetOtherOp> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::ArtifactComposeType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::WeddingState> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::WeddingType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::MarriageOpType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::MarriageStatus> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::WeddingInviteOperType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::MarriagePos> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::WeddingOperType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::ArtifactDeityStoveOpType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::DragonWeakType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::BattleFieldType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::DragonGuildTaskType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::DragonGuildTaskConditionType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::DragonGuildSortType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::DragonGuildUpdateType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::CompeteDragonOpArg> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::TaskConnType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::TaskActivityType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::PeriodTaskType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::TaskOper> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::NpcFlReqType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::NpcFlItemType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::DailyRefreshOperType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::DailyTaskIconType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::SurviveFightEndType> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::SurviveFightStage> : ::std::true_type {};
template <> struct is_proto_enum< ::KKSG::BackFlowActOp> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_enum_2eproto
